<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaWeb"><meta name="keywords" content="JavaWeb"><meta name="author" content="Krab"><meta name="copyright" content="Krab"><title>JavaWeb | Krab's Blog</title><link rel="shortcut icon" href="/krab-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.6.0/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Krab's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#P1-JSP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">P1 JSP环境搭建及入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P2-%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">P2 虚拟路径和虚拟主机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P4-%E4%BD%BF%E7%94%A8eclipse%E5%BC%80%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">P4 使用eclipse开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P13-JDBC-Java-DataBase-Connectivity"><span class="toc-number">4.</span> <span class="toc-text">P13 JDBC: Java DataBase Connectivity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P18-JSP%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">P18 JSP访问数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P20-MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8CServelet%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">P20 MVC设计模式和Servelet执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P21-Servelet25%E5%92%8CServelet30%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">P21 Servelet25和Servelet30的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P22-Servlet-API%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">P22 Servlet API详解与源码分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P23-MVC%E6%A1%88%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">P23 MVC案例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P24-%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">P24 三层架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P29-%E4%BC%98%E5%8C%96%E4%B8%89%E5%B1%82%EF%BC%88%E6%8E%A5%E5%8F%A3%E5%92%8CDBUtil%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">P29 优化三层（接口和DBUtil）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P30-Web%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">P30 Web调试：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P21-%E5%88%86%E9%A1%B5SQL"><span class="toc-number">13.</span> <span class="toc-text">P21 分页SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P34-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">14.</span> <span class="toc-text">P34 文件上传</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P38-EL%E8%AF%AD%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E7%82%B9%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E4%B8%AD%E6%8B%AC%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">15.</span> <span class="toc-text">P38 EL语法表达式，点操作符和中括号操作符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P40-JSTL%E5%9F%BA%E7%A1%80%E5%8F%8Aset-out-remove"><span class="toc-number">16.</span> <span class="toc-text">P40 JSTL基础及set, out, remove</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P42-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">17.</span> <span class="toc-text">P42 过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P43-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">18.</span> <span class="toc-text">P43 监听器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P44-session%E7%BB%91%E5%AE%9A%E8%A7%A3%E7%BB%91%E3%80%81%E9%92%9D%E5%8C%96%E6%B4%BB%E5%8C%96"><span class="toc-number">19.</span> <span class="toc-text">P44 session绑定解绑、钝化活化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P45-Ajax%E5%8E%9F%E7%90%86%E5%8F%8Ajs%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">20.</span> <span class="toc-text">P45 Ajax原理及js方式实现</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/krab.jpg"></div><div class="author-info__name text-center">Krab</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/isxrh">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/Sea.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Krab's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JavaWeb</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">开发框架</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="P1-JSP环境搭建及入门"><a href="#P1-JSP环境搭建及入门" class="headerlink" title="P1 JSP环境搭建及入门"></a>P1 JSP环境搭建及入门</h1><ul>
<li><p>静态&#x2F;动态</p>
<p>  动态网页需要使用到 服务端脚本语言JSP</p>
</li>
<li><p>架构</p>
<p>  CS: Client Server</p>
<p>  BS: Broswer Server</p>
<p>  客户端可以通过浏览器直接访问服务端</p>
</li>
<li><p>tomcat目录：</p>
<ul>
<li>bin: 可执行文件</li>
<li>conf: 配置文件</li>
<li>lib: tomcat依赖的jar文件</li>
<li>log</li>
<li>temp</li>
<li>webapps：可执行的项目（将我们开发的项目放入该文件）</li>
<li>work：存放由jsp翻译成的java，以及编辑成的class文件 【jsp→java→work】</li>
</ul>
</li>
<li><p>配置tomcat</p>
<ul>
<li>配置jdk</li>
<li>配置CATALINA_HOME</li>
</ul>
<p>  双击bin&#x2F;startup.bat启动tomcat</p>
<p>  常见错误：与其他服务的端口号冲突</p>
<p>  默认端口号8080，建议修改为8888(conf&#x2F;server.xml)
  </p>
</li>
<li><p>访问tomcat</p>
<ul>
<li>localhost:8888</li>
<li>常见状态码：200：一切正常； 404：资源不存在； 403：权限不足； 300&#x2F;301： 页面重定向； 500：服务器内部错误（代码有误）</li>
</ul>
</li>
<li><p>Jsp</p>
<ul>
<li>jsp: 在html中嵌套的java代码</li>
<li>在WEB-INF&#x2F;web.xml中设置 默认的 初始页面</li>
</ul>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="P2-虚拟路径和虚拟主机"><a href="#P2-虚拟路径和虚拟主机" class="headerlink" title="P2 虚拟路径和虚拟主机"></a>P2 虚拟路径和虚拟主机</h1><ul>
<li>虚拟路径<ul>
<li>将web项目配置到webapps以外的目录</li>
<li>方式一： conf&#x2F;server.xml中配置， host标签中(需要重新启动)</li>
</ul>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\Mydoc\JspProject&quot;</span>, <span class="attr">path</span>=<span class="string">&quot;/JspProject&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方式二：在conf&#x2F;Catalina&#x2F;localhost中新建“项目名.xml”新增上面的一行代码</li>
</ul>
</li>
<li>虚拟主机<ul>
<li>通过<a target="_blank" rel="noopener" href="http://www.test.com访问本机/">www.test.com访问本机</a></li>
</ul>
<ol>
<li><p>conf&#x2F;server.xml</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;www.test.com&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">&quot;D:\Mydoc\JsaProject&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\Mydoc\JsaProject&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C:\Windows\System32\drives\etc\host 增加 127.0.0.1    <a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a></p>
</li>
</ol>
<ul>
<li>流程：<ul>
<li><a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> → host找映射关系 → server.xml找Engine的defaultHost → 通过“&#x2F;”映射到”D:\Mydoc\JsaProject”</li>
</ul>
</li>
</ul>
</li>
<li>JSP执行流程<ul>
<li>第一次访问：将jsp翻译成java,再将java编译成class文件 （速度慢）<ul>
<li>jsp - java(Servelet文件) - class</li>
<li>D:\ProgramFiles\apache-tomcat-8.5.99\work\Catalina\localhost\JspProject\org\apache\jsp</li>
</ul>
</li>
<li>第二次访问：直接访问class文件</li>
<li>如果服务端代码修改，再访问时将会重新翻译编译</li>
<li>Jsp和Servelet可以相互转换</li>
</ul>
</li>
</ul>
<h1 id="P4-使用eclipse开发"><a href="#P4-使用eclipse开发" class="headerlink" title="P4 使用eclipse开发"></a>P4 使用eclipse开发</h1><ul>
<li><p>在eclipse中创建的web项目：</p>
<ul>
<li>浏览器可以直接访问WebContent&#x2F;（src&#x2F;main&#x2F;wenapp）中的文件</li>
<li>但是WEB-INF中的文件无法通过客户端（浏览器）直接访问，只能通过 请求转发 来访问</li>
</ul>
</li>
<li><p>配置tomcat运行时环境</p>
</li>
<li><p>部署 tomcat</p>
<ul>
<li>在servers面板 新建一个tomcat示例， 再在该实例中 部署项目（右键→Add）， 之后运行</li>
</ul>
</li>
<li><p>统一字符集编码</p>
<ul>
<li>编码分类：<ul>
<li>设置jsp文件的编码（jsp文件中的pageEncoding属性）:  jsp → java</li>
<li>设置浏览器读取jsp文件的编码（jsp文件中meta charset属性）</li>
<li>文本编码：<ul>
<li>将整个eclipse中的文件 统一设置 （window→referecr→jsp）*</li>
<li>设置某一个项目</li>
<li>设置某一个文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>JSP的页面元素:HTML, JAVA代码（scriptlet脚本）， 注释， 指令</p>
<ul>
<li><p>脚本Scriptlet</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">	全局变量、定义方法</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	局部变量、<span class="title class_">Java</span>代码</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%=输出表达式 %&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  ps: 一般修改web.xml、配置文件、Java需要重启tomcat服务； 但修改Jsp&#x2F;html&#x2F;css&#x2F;js不用</p>
<p>  out.println不能回车，回车要写”<br/>”， out.println和输出表达式可以直接解析html代码
  </p>
</li>
<li><p>page指令</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<pre><code>  page指定的属性：
</code></pre>
<ul>
<li><p>language：jsp页面使用的脚本语言</p>
</li>
<li><p>import： 导入类</p>
</li>
<li><p>pageEncoding： jsp文件自身编码 jsp→java</p>
</li>
<li><p>contentType：浏览器解析jsp的编码</p>
</li>
<li><p>注释</p>
<ul>
<li>html &lt;!—注释—!&gt;</li>
<li>java：&#x2F;&#x2F;     &#x2F;<em>注释</em>&#x2F;</li>
<li>jsp： &lt;%—注释—&gt;</li>
</ul>
</li>
<li><p>九大JSP内置对象（自带的，不需要new也能使用）</p>
<ul>
<li>out: 输出对象，向客户端输出内容</li>
<li>request： 请求对象， 存储“客户端向服务端发送的请求信息”<ul>
<li>常见方法<ul>
<li>String getParameter(String name)：根据请求的字段名, 返回字段值value</li>
<li>String[] getParameterValues(String name)：根据请求的字段名，返回多个字段值value（checkbox）</li>
<li>void setCharacterEncoding(”编码格式utf-8”)： 设置请求编码 （tomcat7以前默认iso-8859-1, 8以后utf-8）</li>
<li>getRequestDispatcher(”b.jsp”).forward(requset， response): <strong>请求转发</strong>的方式跳转页面A→B</li>
<li>getServerContext(): 获取项目的ServerContext对象</li>
</ul>
</li>
<li>示例：register.jsp, show.jsp</li>
</ul>
</li>
<li>response： 响应信息<ul>
<li>常见方法：<ul>
<li>void addCookie(Cookie cookie); 服务端像客户端增加cookie对象</li>
<li>void sendRedirect(String location) throws IOException; 页面跳转的一种方式 ，<strong>重定向</strong></li>
<li>void setContentType(String type): 设置服务端响应的编码</li>
</ul>
</li>
<li>示例：login.jsp, check.jsp, success.jsp</li>
</ul>
</li>
<li>pageContent</li>
<li>session(服务端)<ul>
<li><p>Cookie(客户端， 不是内置对象)： Cookie是由服务端生成的，再发给客户端保存。</p>
<ul>
<li>相当于 本地缓存 的作用</li>
<li>作用: 提高访问服务端的效率， 但是安全性较差</li>
<li>key &#x3D; value</li>
<li>javax.servlet.http.Cookie<ul>
<li>public Cookie(String key, String name);</li>
<li>String getName();</li>
<li>String getValue();</li>
<li>String setMaxAge(int expiry); 设置最大有效期（秒）</li>
</ul>
</li>
<li>服务端准备给客户端：<strong>response</strong>.addCookie(Cookie cookie) → 页面跳转 → 客户端获取cookie： <strong>request</strong>.getCookie<strong>s</strong>();<ul>
<li>自动产生一个name为JSESSIONID的cookie</li>
</ul>
</li>
</ul>
</li>
<li><p>session：会话</p>
<ul>
<li><p>客户端<strong>第一次</strong>请求服务端时，服务端会产生一个session信息（用于保存该客户的信息）；并且每个session对象都会有一个sessionId(用于区分其他session)；服务端会产生一个cookie，并且该cookie的key&#x3D;JSEESIONID, value&#x3D;服务端sessionid的值；然后，服务端在响应客户端的同时，将该cookie发送给客户端，至此，客户端就有了一个cookie（JSESSIONID）。因此客户端的cookie和服务端的session一一对应。</p>
<p>  <strong>第二&#x2F;n次请求</strong>服务端时：服务端会先用客户端cookie中的JSESSIONID去服务端的SESSION中匹配sessionid。</p>
</li>
<li><p>总结：</p>
<ul>
<li>session存储在服务器</li>
<li>session在同一个用户（客户）请求时共享</li>
<li>实现机制：第一次客户请求时，产生一个sessionid并复制给cookie的jsessionid然后发给客户端。</li>
</ul>
</li>
<li><p>方法:</p>
<ul>
<li>String getId(): 获取sessionid</li>
<li>boolean isNew(): 判断是否是新用户（第一次访问）</li>
<li>void invalidate(): 使session失效（退出登录、注销）</li>
<li>setAttribute()</li>
<li>getSttribute()</li>
<li>void setMaxInactiveInterval（秒）：设置最大有效非活动时间</li>
<li>void getMaxInactiveInterval()</li>
<li>示例</li>
</ul>
</li>
</ul>
</li>
<li><p>cookie vs session</p>
<table>
<thead>
<tr>
<th></th>
<th>session</th>
<th>cookie</th>
</tr>
</thead>
<tbody><tr>
<td>保存位置</td>
<td>服务端</td>
<td>客户端</td>
</tr>
<tr>
<td>安全性</td>
<td>较安全</td>
<td>不安全</td>
</tr>
<tr>
<td>保存的内容</td>
<td>(key&#x3D;String, value&#x3D;Object)</td>
<td>(String, String)</td>
</tr>
</tbody></table>
</li>
<li><p>客户端在第一次请求服务端时，如果服务端发现此请求没有JSESSIONID，则会创建一个name&#x3D;JESESSIONID的cookie，并返回给客户端</p>
</li>
</ul>
</li>
<li>application 全局对象<ul>
<li>String getContextPath() 虚拟路径</li>
<li>String getRealPath(String ) 虚拟路径相对的绝对路径</li>
</ul>
</li>
<li>config 配置对象（服务器配置信息）</li>
<li>page 当前jsp页面对象（相当于java中的this）</li>
<li>exception 异常对象</li>
</ul>
</li>
<li><p>统一请求的编码 request</p>
<ul>
<li>GET方式：如果出现乱码，解决：<ul>
<li>统一每一个变量的编码 new String(旧编码， 新编码)； 例如：name &#x3D; new String(name.getBytes(“iso-8859-1”), “utf-8”);</li>
<li>修改server.xml一次性的更改tomcat默认get提交方式的编码(utf-8)</li>
<li>method&#x3D;”get”和 地址栏、超链接<a href=”xx”>请求方式 默认都属于get提交方式</li>
</ul>
</li>
<li>POST</li>
<li>get vs post<ul>
<li>get在地址栏显示请求信息（但地址栏容量有限4-5kb）； post不显示</li>
<li>文件上传操作，必须是post</li>
<li>推荐使用post</li>
</ul>
</li>
</ul>
</li>
<li><p>请求转发 vs 重定向</p>
<table>
<thead>
<tr>
<th></th>
<th>请求转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody><tr>
<td>地址栏是否改变</td>
<td>不变（check.jsp）</td>
<td>变(success.jsp)</td>
</tr>
<tr>
<td>是否保留第一次请求时候的数据</td>
<td>保留</td>
<td>不保留</td>
</tr>
<tr>
<td>请求的次数</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>跳转发生的位置</td>
<td>服务端</td>
<td>客户端发出的第二次跳转</td>
</tr>
</tbody></table>
<p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled.png" alt="Untitled"></p>
<p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%201.png" alt="Untitled"></p>
</li>
<li><p>四种范围对象(小→大)</p>
<ul>
<li>pageContext  JSP页面容器   当前页面有效（页面跳转后无效）</li>
<li>request         请求对象        同一次请求有效； 其他请求无效（请求转发后有效，重定向后无效）</li>
<li>session         会话对象        同一次会话有效（关闭&#x2F;切换浏览器后无效； 从登录→退出都有效）</li>
<li>application   全局对象        全局有效，整个项目运行期间都有效（切换浏览器仍然有效； 关闭服务，其他项目无效）</li>
</ul>
<p>  → 多个项目共享，重启后仍然有效：JNDI</p>
<p>  以上四个方法共有的方法：</p>
<ul>
<li>Object getAttribute(String name) 根据属性名，或者属性值</li>
<li>Object setAttribute(String name, Object obj)</li>
<li>Object setAttribute(”a”, “b”)</li>
<li>void removeAttribute(String name)</li>
</ul>
<p>  以上的4个范围对象，通过setAttribute赋值，getAttribute取值</p>
<p>  以上的4个范围对象，尽量使用范围最小的，对象的范围越大，造成的性能损耗越大</p>
</li>
</ul>
<h1 id="P13-JDBC-Java-DataBase-Connectivity"><a href="#P13-JDBC-Java-DataBase-Connectivity" class="headerlink" title="P13 JDBC: Java DataBase Connectivity"></a>P13 JDBC: Java DataBase Connectivity</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%202.png" alt="Untitled"></p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/">https://www.notion.so</a></p>
<ul>
<li><p>JSBC: Java DataBase Connectivity可以为多种关系型数据库提供统一的访问方式，用Java来操作数据</p>
</li>
<li><p>JDBC API主要功能。主要是通过以下的类&#x2F;接口实现：</p>
<ul>
<li><p>DriveManager: 管理jdbc驱动</p>
</li>
<li><p>Connection: 连接</p>
</li>
<li><p>Statement(PreparedStatement)：增删改查</p>
</li>
<li><p>CallableStatement: 调用数据库中的 存储过程&#x2F;存储函数</p>
</li>
<li><p>Result: 返回的结果集</p>
<p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%203.png" alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>JDBC访问数据库的具体步骤</p>
<ul>
<li>导入驱动，加载具体的驱动类</li>
<li>与数据库建立连接</li>
<li>发送sql，执行</li>
<li>处理结果集（查询）</li>
</ul>
</li>
<li><p>数据库驱动</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>驱动jar</th>
<th>具体驱动类</th>
<th>连接字符串</th>
</tr>
</thead>
<tbody><tr>
<td>Oracle</td>
<td>ojdbc-x.jar</td>
<td>oracle.jdbc.OracleDriver</td>
<td>jdbc:oracle:thin:@localhost:1521:ORCL</td>
</tr>
<tr>
<td>MySQL</td>
<td>mysql-connector-java-x.jar</td>
<td>com.mysql.jdbc.Driver</td>
<td>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库实例名</td>
</tr>
<tr>
<td>SqlServer</td>
<td>sqljdbc-x.jar</td>
<td>come.microsoft.sqlserver.jdbc.SQLServerDriver</td>
<td>jdbc:microdoft:sqlserver:localhost:1433;databasename&#x3D;数据库实例名</td>
</tr>
</tbody></table>
<ul>
<li><p>使用jdbc，如果更换了数据库，只需要替换：驱动，具体驱动类、连接字符串、用户名、密码</p>
</li>
<li><p>Connection产生操作数据库的对象</p>
<ul>
<li>产生Statement对象：createStatement();</li>
<li>产生PreparedStatement对象：prepareStatement();</li>
<li>产生CallableStatement对象：prepareCall();</li>
</ul>
</li>
<li><p>Statement操作数据库</p>
<ul>
<li>增删改：excuteUpdate()</li>
<li>查询：excuteQuery()</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt = connection.createStatement();	</span><br><span class="line"><span class="comment">//String sql = &quot;insert into student values(1, &#x27;zs&#x27;, 23, &#x27;s1&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//String sql = &quot;insert into student values(2, &#x27;ls&#x27;, 22, &#x27;s2&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//String sql = &quot;update student set stuname=&#x27;ww&#x27; where stuno=2&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from student where stuno=2&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure>
</li>
<li><p>PreparedStatement操作数据库</p>
<ul>
<li>public interface PreparedStatement extends Statement<ul>
<li>增删改：excuteUpdate()</li>
<li>查询：excuteQuery()</li>
</ul>
</li>
<li>赋值操作setXxx()</li>
<li>推荐使用，cause：编码简单； 预编译提高性能；安全（防止sql注入）<ul>
<li><p>statement sql注入：用户名：任意值 ‘ or 1&#x3D;1 —  密码：任意值</p>
<p>  select count(*) from login where uname&#x3D;’任意值’ or 1&#x3D;1’ and upwd&#x3D;’任意值’</p>
</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into student values(?,?,?,?)&quot;</span>;</span><br><span class="line">pstmt = connection.prepareStatement(sql); <span class="comment">//预编译</span></span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">333</span>);</span><br><span class="line">pstmt.setString(<span class="number">2</span>, <span class="string">&quot;hh&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line">pstmt.setString(<span class="number">4</span>, <span class="string">&quot;s4&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Result: 保存结果集</p>
<ul>
<li>next(): 判断是否有下一条数据</li>
<li>previous()</li>
<li>getXxx(字段名&#x2F;位置)</li>
</ul>
</li>
<li><p>DriveManager: 管理jdbc驱动</p>
</li>
<li><p>CallableStatement: 调用数据库中的 存储过程&#x2F;存储函数</p>
</li>
</ul>
<hr>
<ul>
<li>jdbc总结（模板、八股文）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">a.导入驱动包、加载具体驱动类Class.forName(<span class="string">&quot;具体驱动类&quot;</span>);</span><br><span class="line">b.与数据库建立连接connection = DriverManager.getConnection(...);</span><br><span class="line">c.通过connection，获取操作数据库的对象（Statement\preparedStatement\callablestatement）</span><br><span class="line">stmt = connection.createStatement();</span><br><span class="line">d.(查询)处理结果集rs = pstmt.executeQuery()</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123; rs.getXxx(..) ;&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException e  )</span><br><span class="line">&#123; ...&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开顺序，与关闭顺序相反</span></span><br><span class="line"><span class="keyword">if</span>(rs!=<span class="literal">null</span>)rs.close()</span><br><span class="line"><span class="keyword">if</span>(stmt!=<span class="literal">null</span>) stmt.close();</span><br><span class="line"><span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> ps：jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException
</code></pre>
<ul>
<li>CallableStatement:调用 存储过程、存储函数<br>connection.prepareCall(参数：存储过程或存储函数名)<br>参数格式：<ul>
<li>存储过程（无返回值return，用out参数替代）：<br>  { call  存储过程名(参数列表) }</li>
<li>存储函数（有返回值return）：<br>  { ? &#x3D; call  存储函数名(参数列表) }</li>
</ul>
</li>
<li>存储过程：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `AddNumbers`(<span class="keyword">IN</span> a <span class="type">INT</span>, <span class="keyword">IN</span> b <span class="type">INT</span>, <span class="keyword">OUT</span> sum <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> sum <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>JDBC调用存储过程的步骤：(oracle)<br>a.产生 调用存储过程的对象（CallableStatement） cstmt &#x3D; 	connection.prepareCall(   “…” ) ;<br>b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);<br>c.通过 registerOutParameter(…)处理输出参数类型<br>d.cstmt.execute()执行<br>e.接受 输出值（返回值）getXxx()</p>
<ul>
<li>调存储函数：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">FUNCTION</span> `AddNumbers`(a <span class="type">INT</span>, b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA</span><br><span class="line">    <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JDBC调用存储函数：与调存储过程的区别：<br> 在调用时，注意参数：”{? &#x3D;  call addTwoNumfunction	(?,?) }”</li>
</ul>
<hr>
<ul>
<li>处理CLOB&#x2F;BLOB类型<br>处理稍大型数据：<ol>
<li>存储路径	E:\JDK_API_zh_CN.CHM<br>  通过JDBC存储文件路径，然后 根据IO操作处理<br>  例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\JDK_API_zh_CN.CHM”存储到数据库中<br>  获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  <a target="_blank" rel="noopener" href="http://2.io/">2.IO</a></li>
<li>CLOB：大文本数据 （小说-&gt;数据）<br>  BLOB：二进制</li>
</ol>
</li>
<li>clob:大文本数据   字符流 Reader Writer<ul>
<li>存：<br>  1.先通过pstmt 的? 代替小说内容 （占位符）<br>  2.再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是Int类型</li>
<li>取：<br>  1.通过Reader reader &#x3D; rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中</li>
</ul>
<ol start="2">
<li>将Reader通过Writer输出即可。</li>
</ol>
</li>
<li>blob:二进制  字节流 InputStream OutputStream<br>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)</li>
</ul>
<h1 id="P18-JSP访问数据库"><a href="#P18-JSP访问数据库" class="headerlink" title="P18 JSP访问数据库"></a>P18 JSP访问数据库</h1><p>JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;%  … %&gt;）</p>
<ul>
<li>导包操作：<ul>
<li>java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path</li>
<li>Web项目：jar复制到WEB-INF&#x2F;lib</li>
</ul>
</li>
<li>核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt;</li>
<li>注意：如果jsp出现错误：The import Xxx cannot be resolved， 尝试解决步骤：<br>a.(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入<br>b.清空各种缓存：右键项目-&gt;Clean tomcat… clean  （Project -clean或者 进tomcat目录 删除里面work的子目录）<br>c.删除之前的tomcat，重新解压缩、配置tomcat，重启计算机<br>d.如果类之前没有包，则将该类加入包中</li>
</ul>
<hr>
<ul>
<li>JavaBean<br>将 jsp中 登录操作的代码  转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean<ul>
<li>JavaBean的作用：<ul>
<li>减轻的jsp复杂度</li>
<li>提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现）</li>
</ul>
</li>
<li>JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean<br>  a. public 修饰的类  ,public 无参构造<br>  b. 所有属性(如果有) 都是private，并且提供set&#x2F;get   (如果boolean 则get 可以替换成is)</li>
<li>使用层面, 分为2大类：<ul>
<li>a.封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑)			逻辑<br>  可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java）</li>
<li>b.封装数据的JavaBean   （实体类，Student.java  Person.java  ）		数据<br>  对应于数据库中的一张表<br>  Login login &#x3D; new Login(uname,upwd) ;&#x2F;&#x2F;即用Login对象 封装了2个数据（用户名 和密码）</li>
</ul>
</li>
<li>封装数据的JavaBean 对应于数据库中的一张表   (Login(name,pwd))<br>  封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean</li>
<li>JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java)</li>
</ul>
</li>
</ul>
<h1 id="P20-MVC设计模式和Servelet执行流程"><a href="#P20-MVC设计模式和Servelet执行流程" class="headerlink" title="P20 MVC设计模式和Servelet执行流程"></a>P20 MVC设计模式和Servelet执行流程</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%204.png" alt="Untitled"></p>
<ul>
<li><p>MVC设计模式：</p>
<table>
<thead>
<tr>
<th>M</th>
<th>Model</th>
<th>模型：一个功能</th>
<th>用JavaBean实现</th>
</tr>
</thead>
<tbody><tr>
<td>V</td>
<td>View</td>
<td>视图： 用于展示、以及与用户交互</td>
<td>使用html  js  css jsp jquery等前端技术实现</td>
</tr>
<tr>
<td>C</td>
<td>Controller</td>
<td>控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果返回给 请求处</td>
<td>可以用jsp实现，  但是一般建议使用 Servlet实现控制器</td>
</tr>
</tbody></table>
</li>
</ul>
<p>Jsp-&gt;Java(Servlet)-&gt;JSP</p>
<ul>
<li><p>Servlet: Java类必须符合一定的 规范：<br>a. 必须继承  javax.servlet.http.HttpServlet<br>b. 重写其中的 doGet()或doPost()方法</p>
</li>
<li><p>doGet()： 接受 并处 所有get提交方式的请求<br>doPost()：接受 并处 所有post提交方式的请求</p>
</li>
<li><p>Servlet要想使用，必须配置<br>Serlvet2.5：web.xml<br>Servle3.0： @WebServlet</p>
</li>
<li><p>Serlvet2.5：web.xml:</p>
<p>  项目的根目录：WebContent 、src</p>
<p>  <a href="WelcomeServlet">所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet  是去请求项目的根目录。</p>
<ul>
<li>Servlet流程：<br>  请求 -&gt;<url-pattern> -&gt; 根据<servlet-mapping>中的<servlet-name> 去匹配  <servlet> 中的<servlet-name>，然后寻找到<servlet-class>，求中将请求交由该<servlet-class>执行。</li>
</ul>
</li>
</ul>
<p>2个&#x2F;:<br>jsp:&#x2F;  localhost:8888<br>web.xml: &#x2F;   <a target="_blank" rel="noopener" href="http://localhost:8888/%E9%A1%B9%E7%9B%AE%E5%90%8D/">http://localhost:8888/项目名/</a></p>
<h1 id="P21-Servelet25和Servelet30的使用"><a href="#P21-Servelet25和Servelet30的使用" class="headerlink" title="P21 Servelet25和Servelet30的使用"></a>P21 Servelet25和Servelet30的使用</h1><ul>
<li><p>回顾 纯手工方法 创建第一个Servlet，步骤：<br>编写一个类，继承HttpServlet<br>重写doGet()、doPost()方法<br>编写web.xml 中的servlet映射关系</p>
</li>
<li><p>借助于Eclipse快速生成Servlet<br>直接新建Servlet即可！（继承、重写、web.xml  可以借助Eclipse自动生成）</p>
</li>
<li><p>Servlet3.0，与Servlet2.5的区别：<br>Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)</p>
<ul>
<li>匹配流程：  请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类</li>
</ul>
</li>
<li><p>项目根目录：WebContent、src（即 所有的构建路径）</p>
<ul>
<li>例如：<br>  WebContent中有一个文件index.jsp<br>  src中有一个Servlet.java</li>
<li>如果: index.jsp中请求 <a href="abc">…</a> ，则 寻找范围：既会在src根目录中找  也会在WebContent根目录中找</li>
<li>如果：index.jsp中请求<a href="a/abc"></a>，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc</li>
</ul>
</li>
<li><p>&#x2F;</p>
<ul>
<li>web.xml中的 &#x2F;:  代表项目根路径，例如：<a target="_blank" rel="noopener" href="http://localhost:8888/Servlet25Project/">http://localhost:8888/Servlet25Project/</a></li>
<li>jsp中的&#x2F;: 服务器根路径，<a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a>（&#x2F;a &#x3D; <a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a>a; a&#x3D; <a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a><a target="_blank" rel="noopener" href="http://localhost:8888/Servlet25Project/">Servlet25Project&#x2F;</a>webcontent&#x2F;a）</li>
<li>构建路径、WebContent都属于根目录</li>
</ul>
</li>
<li><p>Servlet生命周期：<strong>5</strong>个阶段<br>加载<br>初始化： init()  ，该方法会在 Servlet被加载并实例化的以后 执行<br>服务  ：service() -&gt;doGet()  doPost<br>销毁  ：destroy()，  Servlet被系统回收时执行<br>卸载</p>
</li>
</ul>
<p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%205.png" alt="Untitled"></p>
<ul>
<li><p>init():<br>a. 默认第一次访问 Servlet时会被执行 （只执行这一次）<br>b. 可以修改为 Tomcat启动时自动执行</p>
<ul>
<li>Servlet2.5：  web.xml</li>
</ul>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">其中的“1”代表第一个。</span><br></pre></td></tr></table></figure>
<ul>
<li>Servlet3.0</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value=&quot;/WelcomeServlet&quot;, loadOnStartup=1  )</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>service() -&gt;doGet()  doPost ：调用几次，则执行几次</p>
</li>
<li><p>destroy()：关闭tomcat服务时，执行一次。</p>
</li>
</ul>
<h1 id="P22-Servlet-API详解与源码分析"><a href="#P22-Servlet-API详解与源码分析" class="headerlink" title="P22 Servlet API详解与源码分析"></a>P22 Servlet API详解与源码分析</h1><ul>
<li><p>Servlet API：由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包 （即Servlet  API可以适用于 任何 通信协议）<br>我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。</p>
</li>
<li><p>Servlet继承关系</p>
<p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%206.png" alt="Untitled"></p>
</li>
<li><p>ServletConfig:接口</p>
<ul>
<li>ServletContext getServletContext():获取Servlet上下文对象   application</li>
<li>String  getInitParameter(String name):在<strong>当前Servlet</strong>范围内，获取名为name的参数值（初始化参数）</li>
</ul>
</li>
<li><p>ServletContext中的常见方法(application)：</p>
<ul>
<li>getContextPath():相对路径</li>
<li>getRealPath()：绝对路径<br>  setAttribute() 、getAttribute()</li>
<li>String getInitParameter(String name);在<strong>当前Web容器</strong>范围内，获取名为name的参数值（初始化参数）</li>
</ul>
</li>
</ul>
<p>Servlet3.0方式 给当前Servlet设置初始值：<br>@WebServlet( …. , initParams&#x3D; {@WebInitParam(name&#x3D;”serveltparaname30”,value&#x3D;”servletparavalue30”)   }   )<br>注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）</p>
<p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%207.png" alt="Untitled"></p>
<ul>
<li><p>HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()<br>HttpServletResponse中的方法：同response</p>
</li>
<li><p>Servlet使用层面：</p>
<p>  Eclipse中在src创建一个Servlet，然后重写doGet()  doPost()就可以  （doGet() doPost()只需要编写一个）。</p>
</li>
</ul>
<h1 id="P23-MVC案例"><a href="#P23-MVC案例" class="headerlink" title="P23 MVC案例"></a>P23 MVC案例</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%208.png" alt="Untitled"></p>
<h1 id="P24-三层架构"><a href="#P24-三层架构" class="headerlink" title="P24 三层架构"></a>P24 三层架构</h1><p>与MVC设计模式的目标一致：都是为了解耦合、提高代码复用；</p>
<p>区别：两者对项目理解的角度不同</p>
<ul>
<li>三层组成<ul>
<li>表示层（USL, User Show layer; 视图层）<ul>
<li>前台：对应MVC中的V， 用于和用户交互、界面显示<ul>
<li>jsp, js, html, css, jquery等前端web技术</li>
<li>代码位置：webcontent</li>
</ul>
</li>
<li>后台：对应MVC中的C，用于 控制跳转、调用<ul>
<li>Servlet(Spring MVC Strusts2)</li>
<li>代码位置：xxx.servlet包</li>
</ul>
</li>
</ul>
</li>
<li>业务逻辑层（BLL，Business Logic Layer; Service层）<ul>
<li>接收表示层的请求 调用</li>
<li>组装数据访问层，逻辑性操作（增删改查， 删：查+删）</li>
<li>位于xxx.service包</li>
</ul>
</li>
<li>数据访问层（DAL，Data Access Layer; Dao层）<ul>
<li>直接访问数据库的操作，原子性操作（增删改查）</li>
<li>位于xxx.dao包</li>
</ul>
</li>
</ul>
</li>
<li>三层的关系：<ul>
<li>上层将请求传递给下层，下层处理后返回给上层</li>
<li>上层依赖于下层</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * jsp常见的内置对象都可以在servlet里面拿到</span><br><span class="line"> * out: PrintWriter writer = response.getWriter()</span><br><span class="line"> * session: request.getSession()</span><br><span class="line"> * application: request.getServletContext()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%209.png" alt="Untitled"></p>
<ul>
<li>一个Servlet对应一个功能</li>
</ul>
<h1 id="P29-优化三层（接口和DBUtil）"><a href="#P29-优化三层（接口和DBUtil）" class="headerlink" title="P29 优化三层（接口和DBUtil）"></a>P29 优化三层（接口和DBUtil）</h1><ul>
<li>加入接口<br>建议面向接口开发：先接口-再实现类<br>–service、dao加入接口<br>–接口与实现类的命名规范<br>接口：interface，	起名   I实体类Service		IStudentService<br>IStudentDao	<br>实现类：implements	起名   实体类ServiceImpl		StudentServiceImpl<br>StudentDaoImpl<br>接口：	I实体类层所在包名	IStudentService、IStudentDao	<br>接口所在的包：  xxx.service		xx.dao</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	实现类：	 实体类层所在包名Impl	StudentServiceImpl、StudentDaoImpl</span><br><span class="line">		实现类所在的包：xxx.service.impl		xx.dao.impl</span><br><span class="line"></span><br><span class="line">以后使用接口/实现类时，推荐写法：</span><br><span class="line">接口 x = new 实现类();</span><br><span class="line">IStudentDao studentDao = new StudentDaoImpl();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>DBUtil 通用的数据库帮助类，可以简化Dao层的代码量</p>
<p>  帮助类 一般建议写在  xxx.util包</p>
</li>
<li><p>方法重构：  将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可</p>
</li>
</ul>
<h1 id="P30-Web调试："><a href="#P30-Web调试：" class="headerlink" title="P30 Web调试："></a>P30 Web调试：</h1><p>与java代码的调试 区别：启动方式不同</p>
<p>index.jsp -&gt;index_jsp.java -&gt;index_jsp.class</p>
<p>jsp-&gt;java-&gt;class<br>jsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中</p>
<p>10000</p>
<h1 id="P21-分页SQL"><a href="#P21-分页SQL" class="headerlink" title="P21 分页SQL"></a>P21 分页SQL</h1><ul>
<li>分页<br>要实现分页，必须知道  某一页的 数据 从哪里开始 到哪里结束</li>
<li>页面大小：每页显示的数据量</li>
</ul>
<p>假设每页显示10条数据</p>
<ul>
<li><p>mysql分页：</p>
<ul>
<li><p>mysql:从0开始计数<br>  0		0		9<br>  1		10		19<br>  2		20		29<br>  n		n*10	      (n+1)*10-1</p>
<p>  结论：<br>  分页：<br>  第n页的数据：  第(n-1)<em>10+1条  – 第n</em>10条</p>
</li>
<li><p>MYSQL实现分页的sql：<br>  limit  开始,多少条<br>  第0页<br>  select * from student limit 0,10 ;<br>  第1页<br>  select * from student limit 10,10 ;<br>  第2页<br>  select * from student limit  20,10 ;<br>  第n页<br>  select * from student limit n*10,10</p>
</li>
<li><p>mysql的分页语句：</p>
</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student limit 页数<span class="operator">*</span>页面大小,页面大小</span><br></pre></td></tr></table></figure>
</li>
<li><p>oracle分页：</p>
</li>
<li><p>SQLServer分页：  3种分页sql</p>
</li>
</ul>
<p>dao和DBUtil的区别：<br>dao 是处理特定 类的 数据库操作类：<br>DBUtil是通用  数据库操作类</p>
<h1 id="P34-文件上传"><a href="#P34-文件上传" class="headerlink" title="P34 文件上传"></a>P34 文件上传</h1><ul>
<li><p>上传文件</p>
<ul>
<li>引入2个jar<br>  apache: commons-fileupload.jar组件<br>  commons-fileupload.jar依赖 commons-io.jar</li>
<li>代码：<ul>
<li>前台jsp：  <input type="file"  name="spicture"/>
  表单提交方式必须为post
  在表单中必须增加一个属性 entype="multipart/form-data"</li>
<li>后台servlet：</li>
</ul>
</li>
<li>注意的问题：<br>  上传的目录  upload ：</li>
</ul>
<ol>
<li><p>如果修改代码，则在tomcat重新启动时 会被删除<br>  原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录）</p>
<p>   2.如果不修改代码，则不会删除<br> 原因： 没有修改代码，class仍然是之前的class</p>
</li>
</ol>
<p>  因此，为了防止 上传目录丢失： a.虚拟路径	b.直接更换上传目录 到非tomcat目录
  </p>
</li>
<li><p>限制上传：<br>类型、<br>大小<br>注意 对文件的限制条件 写再parseRequest之前</p>
</li>
<li><p>下载：不需要依赖任何jar	<br>a.请求（地址a  form），请求Servlet	<br>b.Servlet通过文件的地址  将文件转为输入流 读到Servlet中<br>c.通过输出流 将 刚才已经转为输入流的文件  输出给用户<br>注意：下载文件 需要设置2个 响应头：<br>response.addHeader(“content-Type”,”application&#x2F;octet-stream” );&#x2F;&#x2F;MIME类型:二进制文件（任意文件）<br>response.addHeader(“content-Disposition”,”attachement;filename&#x3D;”+fileName );&#x2F;&#x2F;fileName包含了文件后缀：abc.txt</p>
</li>
<li><p>下载时 ，文件名乱码问题：</p>
<ul>
<li><p>edge：</p>
<p>  URLEncoder.encode(fileName,”UTF-8”)</p>
</li>
<li><p>firefox：<br>  给文件名 加：<br>  前缀   &#x3D;?UTF-8?B?</p>
<p>  String构造方法<br>  Base64.encode</p>
<p>  后缀   ?&#x3D;<br>  示例：<br>  response.addHeader(“content-Disposition”,”attachment;filename&#x3D;&#x3D;?UTF-8?B?”+   new String(  Base64.encodeBase64(fileName.getBytes(“UTF-8”))  ) +”?&#x3D;” );&#x2F;&#x2F;fileName包含了文件后缀：abc.txt</p>
</li>
</ul>
</li>
</ul>
<h1 id="P38-EL语法表达式，点操作符和中括号操作符"><a href="#P38-EL语法表达式，点操作符和中括号操作符" class="headerlink" title="P38 EL语法表达式，点操作符和中括号操作符"></a>P38 EL语法表达式，点操作符和中括号操作符</h1><p>EL ：为了消除jsp中的Java代码</p>
<ul>
<li>语法：<br>${EL表达式}<br>a.EL不需要导包<br>b.在el中调用属性，其实是调用的getXxx()方法</li>
<li>${范围.对象.属性.属性的属性 }</li>
<li>操作符：操作：属性，不是对象<br>. : 使用方便<br>[] : 如果是常量属性，需要使用双引号&#x2F;单引号 引起来;比点操作符更加强大</li>
<li>[]强大之处:<ul>
<li>可以容纳一些 特殊符号 （.  ?   -）</li>
<li>[]可以容纳 变量属性 （可以动态赋值）<br>  String x &#x3D; “a”;<br>  ${requestScope.a}等价于${requestScope[“a”]}等价于${${requestScope[x]}</li>
<li>可以处理数组<br>  ${requestScope.arr[0] }</li>
<li>普通对象、map中的变量</li>
</ul>
</li>
<li>关系运算符，逻辑运算符</li>
<li>empty运算符：判断一个值null&#x2F;不存在→true</li>
<li>EL表达式的隐式对象（不需要new就能使用的对象，自带的对象）<ul>
<li>作用域访问的对象（EL域对象）: pageScope,  requestScope, sessionScope, applicationScope<ul>
<li>如果不指定域对象，则默认 会根据从小到大的顺序 依此取值</li>
</ul>
</li>
<li>参数访问对象： 获取表单数据 （request.getParameter()&#x2F;超链接中传的值&#x2F;地址栏中的值→${param}, request.getParameterValues()→${paramValues}）</li>
<li>JSP隐式对象：pageContext<ul>
<li>在jsp中可以通过pageContext获取jsp的其他隐式对象；因此如果要在el中使用jsp隐式对象，可以通过pageContext获取</li>
<li>例如：${pageContext.request}; pageContext.getSession→${pageContext.session}hia</li>
<li>还可以获取级联对象：${pageContext.request.serverPort}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="P40-JSTL基础及set-out-remove"><a href="#P40-JSTL基础及set-out-remove" class="headerlink" title="P40 JSTL基础及set, out, remove"></a>P40 JSTL基础及set, out, remove</h1><ul>
<li><p>JSTL：比EL更加强大</p>
<ul>
<li>需要引入2个jar ：jstl.jar   standard.jar</li>
<li>引入tablib：&lt;%@ taglib uri&#x3D;”<a target="_blank" rel="noopener" href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ prefix&#x3D;”c” %&gt;   (其中prefix&#x3D;”c” :前缀)</li>
<li>核心标签库：  通用标签库、条件标签库 、迭代标签库</li>
</ul>
</li>
<li><p>通用标签库<br>&lt;c:set&gt;赋值，作用：</p>
<ul>
<li><p>在某个作用域之中（4个范围对象），给<strong>某个变量赋值</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;变量名&quot;</span>    value=<span class="string">&quot;变量值&quot;</span>   scope=<span class="string">&quot;4个范围对象的作用域&quot;</span>/&gt;</span><br><span class="line">例如：</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;name&quot;</span>    value=<span class="string">&quot;zhangsan&quot;</span>   scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br><span class="line">等价于：</span><br><span class="line">request.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>) ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给<strong>某个对象的属性</strong>赋值: 在某个作用域之中（4个范围对象），给<strong>某个对象的属性复制</strong> （此种写法，不能指定scope属性）</p>
<ul>
<li>给普通对象赋值:</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set target=<span class="string">&quot;对象&quot;</span> property=<span class="string">&quot;对象的属性&quot;</span>  value=<span class="string">&quot;赋值&quot;</span> /&gt;</span><br><span class="line">&lt;c:set target=<span class="string">&quot;$&#123;requestScope.student&#125;&quot;</span> property=<span class="string">&quot;sname&quot;</span>  value=<span class="string">&quot;zxs&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>给map对象赋值:</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set target=<span class="string">&quot;对象&quot;</span> property=<span class="string">&quot;对象的属性&quot;</span>  value=<span class="string">&quot;赋值&quot;</span> /&gt;</span><br><span class="line">&lt;c:set target=<span class="string">&quot;$&#123;requestScope.countries&#125;&quot;</span> property=<span class="string">&quot;cn&quot;</span>  value=<span class="string">&quot;中国&quot;</span> /&gt;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>注意 &lt;c:set&gt;可以给<strong>不存在的变量</strong>赋值 （但不能给不存在的对象赋值）</p>
</li>
</ul>
</li>
<li><p>&lt;c:out&gt;  ：显示</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>:&lt;c:out value=<span class="string">&#x27;&lt;a href=&quot;[https://www.baidu.com](https://www.baidu.com/)&quot;&gt;百度&lt;/a&gt;&#x27;</span> <span class="keyword">default</span>=<span class="string">&quot;当value为空的，显示的默认值&quot;</span> escapeXml=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line"><span class="literal">false</span>：	&lt;c:out value=<span class="string">&#x27;&lt;a href=&quot;[https://www.baidu.com](https://www.baidu.com/)&quot;&gt;百度&lt;/a&gt;&#x27;</span> escapeXml=<span class="string">&quot;false&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;c:remove &gt;：删除属性</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:remove <span class="keyword">var</span>=<span class="string">&quot;a&quot;</span> scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择：<ul>
<li><p>if(boolean): 单重选择<br>  &lt;c:if test&#x3D;”” &gt;</p>
</li>
<li><p>if else if… esle if… else  &#x2F;switch</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test=<span class="string">&quot;...&quot;</span>&gt;   &lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=<span class="string">&quot;...&quot;</span>&gt;   &lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=<span class="string">&quot;...&quot;</span>&gt;   &lt;/c:when&gt;</span><br><span class="line">	&lt;c:otherwise&gt;   &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用 test&#x3D;”” 一定要注意后面是否有空格<br>  例如：test&#x3D;”${10&gt;2 }”   true<br>  test&#x3D;”${10&gt;2 } “  非true</p>
</li>
</ul>
</li>
<li>循环（迭代标签库）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">&lt;c:forEach  begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;5&quot;</span> step=<span class="string">&quot;1&quot;</span> varStatus=<span class="string">&quot;status&quot;</span>&gt;</span><br><span class="line">	$&#123;status.index&#125; </span><br><span class="line">	test...&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:names)</span><br><span class="line">&lt;c:forEach  <span class="keyword">var</span>=<span class="string">&quot;student&quot;</span> items=<span class="string">&quot;$&#123;requestScope.students &#125;&quot;</span> &gt;</span><br><span class="line">$&#123;student.sname &#125;-$&#123;student.sno &#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<h1 id="P42-过滤器"><a href="#P42-过滤器" class="headerlink" title="P42 过滤器"></a>P42 过滤器</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/d1517cf2-51f7-48e8-bad8-825bb781ae57.png" alt="Untitled"></p>
<ul>
<li>过滤器：<br>实现一个Filter接口<br>init()、destroy() 原理、执行时机 同Servlet<br>配置过滤器，类似servlet<br>通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行</li>
<li>filter映射<ul>
<li>只拦截 访问MyServlet的请求<br>  <url-pattern>&#x2F;MyServlet</url-pattern></li>
<li>拦截一切请求（每一次访问 都会被拦截）<br>  <url-pattern>&#x2F;*</url-pattern></li>
</ul>
</li>
<li>通配符<ul>
<li>dispatcher请求方式：<ul>
<li>REQUEST：拦截HTTP请求 get post</li>
<li>FORWARD：只拦截 通过 请求转发方式 的请求</li>
<li>INCLUDE: 只拦截通过 request.getRequestDispatcher(“”).include()  、通过&lt;jsp:include page&#x3D;”…” &#x2F;&gt;此种方式发出的请求</li>
<li>ERROR：只拦截<error-page>发出的请求</li>
</ul>
</li>
</ul>
</li>
<li>过滤器中doFilter方法参数：ServletRequest<br>在Servlet中的方法参数：HttpServletRequest</li>
<li>过滤器链<br>可以配置多个过滤器，过滤器的先后顺序 是由 <filter-mapping>的位置 决定</li>
</ul>
<h1 id="P43-监听器"><a href="#P43-监听器" class="headerlink" title="P43 监听器"></a>P43 监听器</h1><ul>
<li>监听器<ul>
<li>步骤：<ul>
<li>编写监听器，实现接口</li>
<li>配置web.xml</li>
</ul>
</li>
<li>监听对象：request session application<ul>
<li>request：ServerRequestListener</li>
<li>session: HttpSessionListener</li>
<li>application: ServletContextListener;</li>
<li>每个监听器各自两个方法，监听开始和结束</li>
<li>ServletContext在servlet容器启动时自动创建</li>
</ul>
</li>
<li>监听属性的变更<ul>
<li>request：ServerRequestAttributeListener</li>
<li>session: HttpSessionAttributeListener</li>
<li>application: ServletContextAttributeListener;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="P44-session绑定解绑、钝化活化"><a href="#P44-session绑定解绑、钝化活化" class="headerlink" title="P44 session绑定解绑、钝化活化"></a>P44 session绑定解绑、钝化活化</h1><ul>
<li><p>钝化：内存→硬盘</p>
</li>
<li><p>活化：硬盘→内存</p>
</li>
<li><p>session对象的四种状态</p>
<ul>
<li>session.setAttribute(”a”, xxx) 将对象<strong>绑定</strong>到session中</li>
<li>session.removeAttribute(”a”) 将对象从session中<strong>解绑</strong></li>
<li>钝化</li>
<li>活化</li>
</ul>
</li>
<li><p>监听：</p>
<ul>
<li>监听session对象的绑定和解绑：HttpSessionBindingListener  不需要配置web.xml</li>
<li>监听session对象的钝化活化：HttpSessionActivationListener  不需要配置web.xml</li>
</ul>
</li>
<li><p>如何钝化、活化：配置tomcat安装目录&#x2F;conf&#x2F;context.xml</p>
</li>
<li><p>钝化、活化的本质 就是序列化、反序列化，需要实现Serializable接口</p>
</li>
<li><p>总结：钝化、活化 实际执行 是通过context.xml中进行配置而进行；</p>
<p>  HttpSessionActivationListener只是负责在 session钝化 和 活化 时予以监听。</p>
</li>
</ul>
<h1 id="P45-Ajax原理及js方式实现"><a href="#P45-Ajax原理及js方式实现" class="headerlink" title="P45 Ajax原理及js方式实现"></a>P45 Ajax原理及js方式实现</h1><ul>
<li>Ajax： 异步js 和 xml<ul>
<li><p>异步刷新可以使得：只刷新需要修改的地方，页面中其他部分保持不变</p>
<p>  例如:视频点赞</p>
</li>
<li><p>实现：</p>
<ul>
<li>js： XMLHttpRequest对象<ul>
<li>XMLHttpRequest对象的方法<ul>
<li>open(方法名（提交方式get&#x2F;post）, 服务器地址, true)：(与服务段端建立链接)</li>
<li>send():<ul>
<li>get: send(null)</li>
<li>post: send(参数值)</li>
</ul>
</li>
<li>setRequestHeader(header, value)<ul>
<li>get不需要设置此值</li>
<li>post<ul>
<li>如果请求元素中包含了文件上传：setRequestHeader(”Content-Tyoe”, “multipart&#x2F;form-data”)</li>
<li>不包含：setRequestHeader(”Content-Tyoe”, “application&#x2F;x-www-form-urlencoded”)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>XMLHttpRequest对象的属性<ul>
<li>readyState:请求状态。 4：请求完毕</li>
<li>state:响应状态。 200：响应正常</li>
<li>onreadystatechange: 回调函数</li>
<li>responseText: 响应格式为text</li>
<li>responseXML</li>
</ul>
</li>
</ul>
</li>
<li>jquery（推荐）  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: 服务器地址，</span><br><span class="line">type：get | post,</span><br><span class="line"><span class="attr">data</span>: 请求数据，</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result, testStatus</span>) &#123;&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">xhr, errorMessage, e</span>) &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">请求数据,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">result, testStatus</span>) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">预期返回值类型（<span class="title class_">String</span>\xml),</span><br><span class="line">);</span><br><span class="line">$.<span class="title function_">post</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">请求数据,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">result, testStatus</span>) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">预期返回值类型（<span class="title class_">String</span>\xml),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(xxx).<span class="title function_">load</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">请求数据,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  load: 将服务端的返回值，直接加载到$(xxx)所选择的元素  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">json格式的请求数据,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Krab</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://isxrh.github.io/2024/01/18/202401_JavaWeb/">https://isxrh.github.io/2024/01/18/202401_JavaWeb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaWeb/">JavaWeb</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/02/15/202402_MyBatis/"><i class="fa fa-chevron-left">  </i><span>Mybatis</span></a></div><div class="next-post pull-right"><a href="/2021/09/17/202009_%E8%AE%BF%E9%97%AEgoogle.com%E6%98%BE%E7%A4%BA%E8%AF%81%E5%AE%9E%E6%97%A0%E6%95%88%EF%BC%88%E6%8C%87%E5%90%91vmware)/"><span>访问google.com显示证书无效（指向vmware）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/Sea.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Krab</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>