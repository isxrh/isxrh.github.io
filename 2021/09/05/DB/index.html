<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="DB"><meta name="keywords" content="DB"><meta name="author" content="Krab"><meta name="copyright" content="Krab"><title>DB | Krab's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Krab's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 数据库系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 数据库管理技术的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 数据库系统的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E4%B8%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 两类数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 概念模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 数据模型的组成要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 常用的数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.2.5 关系模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">完整性约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 数据库系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 数据库系统模式的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 数据库系统的三级模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%83%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 数据库的二级映像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 功能与数据独立性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2 关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 关系数据结构及形式化定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">关系的性质：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 关系的完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">2.4 关系代数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-SQL"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 模式定义与删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 基本表的定义、删除与修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 数据查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.4.1 单表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%88%97"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">1. 选择表中的若干列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%85%83%E7%BB%84"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">2. 选择表中的若干元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ORDER-BY%E5%AD%90%E5%8F%A5"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">3. ORDER BY子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">4. 聚集函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-GROUP-BY%E5%AD%90%E5%8F%A5"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">5. GROUP BY子句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.4.2 连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AD%89%E5%80%BC%E4%B8%8E%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">1. 等值与非等值连接查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E8%BA%AB%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">2. 自身连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">3. 外连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">4. 多表连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.4.3 嵌套查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%A6%E6%9C%89IN%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">1. 带有IN谓词的子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%A6%E6%9C%89%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">2. 带有比较运算符的子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%A6%E6%9C%89ANY%EF%BC%88SOME%EF%BC%89%E6%88%96ALL%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">3. 带有ANY（SOME）或ALL谓词的子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%A6%E6%9C%89EXISTS%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">4. 带有EXISTS谓词的子查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4.4 集合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.4.5 基于派生表的查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 数据更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E5%85%83%E7%BB%84"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">1. 插入元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%EF%BC%88%E5%8F%AF%E4%BB%A5%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%EF%BC%89"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">2. 插入子查询结果（可以一次插入多个元组）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 修改数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">1. 修改某一个元组的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">2. 修改多个元组的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BF%AE%E6%94%B9%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">3. 带子查询的修改语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 删除数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">1. 删除某一个元组的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">2. 删除多个元组的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">3. 带子查询的删除语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 空值的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1 定义视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BB%BA%E7%AB%8B%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">1. 建立视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">2. 删除视图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.6.2 查询视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.6.3 更新视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.6.4.</span> <span class="toc-text">3.6.4 视图的作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4 数据库安全性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">Chapter 5 数据库完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 实体完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 实体完整性定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9C%A8%E5%88%97%E7%BA%A7%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">（1）在列级定义主码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%A8%E8%A1%A8%E7%BA%A7%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">（2）在表级定义主码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 实体完整性检查和违约处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 参照完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 参照完整性定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 参照完整性检查和违约处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 用户定义的完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 属性上的约束条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 元组上的约束条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%91%BD%E5%90%8D%E5%AD%97%E5%8F%A5"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 完整性约束命名字句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%96%AD%E8%A8%80"><span class="toc-number">5.5.</span> <span class="toc-text">5.6 断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%96%AD%E8%A8%80"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">1. 创建断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E6%96%AD%E8%A8%80"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">2. 删除断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">5.7 触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-%E5%AE%9A%E4%B9%89%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.7.1 定义触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-%E6%BF%80%E6%B4%BB%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.7.2 激活触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-3-%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.6.3.</span> <span class="toc-text">5.7.3 删除触发器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">Chapter 6 关系数据理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 规范化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 函数依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">1. 函数依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%9D%9E%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">2. 平凡函数依赖与非平凡函数依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">3. 完全函数依赖与部分函数依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.1.4.</span> <span class="toc-text">4. 传递函数依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E7%A0%81"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E8%8C%83%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7-%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.7 多值依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-8-%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.2.8 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 数据依赖的公理系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">Chapter 7 数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 概念结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 逻辑结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 物理结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%96%BD"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 数据库实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 数据库运行和维护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text">Chapter 10 数据库恢复技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">10.1 事务的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.1.1.</span> <span class="toc-text">10.1.1 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.2.</span> <span class="toc-text">10.1.2 事务的ACID特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">10.3 故障的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">8.3.</span> <span class="toc-text">10.4 恢复的实现技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-number">8.4.</span> <span class="toc-text">10.5 恢复策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-1-%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">8.4.1.</span> <span class="toc-text">10.5.1 事务故障的恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-2-%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">8.4.2.</span> <span class="toc-text">10.5.2 系统故障的恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-3-%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">8.4.3.</span> <span class="toc-text">10.5.3 介质故障的恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">8.5.</span> <span class="toc-text">10.6 具有检查点的恢复技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%95%9C%E5%83%8F"><span class="toc-number">8.6.</span> <span class="toc-text">10.7 数据库镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-11-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">Chapter 11 并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">11.1 并发控制概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%B0%81%E9%94%81"><span class="toc-number">9.2.</span> <span class="toc-text">11.2 封锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.3.</span> <span class="toc-text">11.3 封锁协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-number">9.4.</span> <span class="toc-text">11.4 活锁和死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7"><span class="toc-number">9.5.</span> <span class="toc-text">11.5 并发调度的可串行性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-1-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"><span class="toc-number">9.5.1.</span> <span class="toc-text">11.5.1 可串行化调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-2-%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"><span class="toc-number">9.5.2.</span> <span class="toc-text">11.5.2 冲突可串行化调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.6.</span> <span class="toc-text">11.6 两段锁协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-%E5%B0%81%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">9.7.</span> <span class="toc-text">11.7 封锁的粒度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-1-%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81"><span class="toc-number">9.7.1.</span> <span class="toc-text">11.7.1 多粒度封锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-2-%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">9.7.2.</span> <span class="toc-text">11.7.2 意向锁</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.imgtp.com/2024/04/18/xioEzq6G.jpg"></div><div class="author-info__name text-center">Krab</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/isxrh">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Krab's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">DB</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 绪论"></a><a href="#chapter-1-%E7%BB%AA%E8%AE%BA"></a>Chapter 1 绪论</h1><h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a><a href="#11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"></a>1.1 数据库系统概述</h2><h3 id="1-1-1-基本概念"><a href="#1-1-1-基本概念" class="headerlink" title="1.1.1 基本概念"></a><a href="#111-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>1.1.1 基本概念</h3><ul>
<li><strong>数据</strong>（Data）: 数据库中存储的基本对象, 描述事物的符号记录</li>
<li><strong>数据库</strong>（Database）: 是长期储存在计算机内、有组织的、可共享的大量数据的集合。</li>
<li><strong>数据库管理系统</strong>（DBMS）: 位于用户与操作系统之间的一层数据管理软件; 是基础软件，是一个大型复杂的软件系统 。主要功能：<ul>
<li>数据定义</li>
<li>数据组织、存储、管理</li>
<li>数据操纵</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护</li>
<li>others</li>
</ul>
</li>
<li><strong>数据库系统</strong>（DBS）: 由数据库、数据库管理系统（及其应用开发工具）、应用程序、数据库管理员组成的存储、管理、处理和维护数据的系统</li>
</ul>
<h3 id="1-1-2-数据库管理技术的发展"><a href="#1-1-2-数据库管理技术的发展" class="headerlink" title="1.1.2 数据库管理技术的发展"></a><a href="#112-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95"></a>1.1.2 数据库管理技术的发展</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th>人工管理阶段</th>
<th>文件系统阶段</th>
<th>数据库系统阶段</th>
</tr>
</thead>
<tbody><tr>
<td>背景</td>
<td>应用背景</td>
<td>科学计算</td>
<td>科学计算、数据管理</td>
<td>大规模数据管理</td>
</tr>
<tr>
<td></td>
<td>硬件背景</td>
<td>无直接存取存储设备</td>
<td>磁盘</td>
<td>大容量磁盘、磁盘阵列</td>
</tr>
<tr>
<td></td>
<td>软件背景</td>
<td>没有操作系统</td>
<td>有文件系统</td>
<td>有DBMS</td>
</tr>
<tr>
<td></td>
<td>处理方式</td>
<td>批处理</td>
<td>联机实时处理、批处理</td>
<td>联机实时处理,分布处理,批处理</td>
</tr>
<tr>
<td>特点</td>
<td>数据的管理者</td>
<td>用户</td>
<td>文件系统，数据可长期保存</td>
<td>DBMS</td>
</tr>
<tr>
<td></td>
<td>数据面向的对象</td>
<td>某一应用程序</td>
<td>某一应用</td>
<td>现实世界</td>
</tr>
<tr>
<td></td>
<td>数据的共享程度</td>
<td>无共享、冗余度极大</td>
<td>共享性差、冗余度大</td>
<td>共享性高、冗余度小</td>
</tr>
<tr>
<td></td>
<td>数据的独立性</td>
<td>不独立，完全依赖于程序</td>
<td>独立性差</td>
<td>具有高度的物理独立性和一定的逻辑独立性</td>
</tr>
<tr>
<td></td>
<td>数据的结构化</td>
<td>无结构</td>
<td>记录内有结构，整体无结构</td>
<td>整体结构化，用数据模型描述</td>
</tr>
<tr>
<td></td>
<td>数据控制能力</td>
<td>应用程序自己控制</td>
<td>应用程序自己控制</td>
<td>有DBMS提供数据安全性、完整性、并发控制和恢复能力</td>
</tr>
</tbody></table>
<h3 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a><a href="#113-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"></a>1.1.3 数据库系统的特点</h3><ul>
<li>数据结构化</li>
<li>数据的共享性高，冗余度低且易扩充</li>
<li>数据独立性高：数据的物理独立性和逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制：数据的安全性（Security）保护；数据的完整性（Integrity）检查；并发（Concurrency）控制；数据库恢复（Recovery）</li>
</ul>
<h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a><a href="#12-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"></a>1.2 数据模型</h2><h3 id="1-2-1-两类数据模型"><a href="#1-2-1-两类数据模型" class="headerlink" title="1.2.1 两类数据模型"></a><a href="#121-%E4%B8%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"></a>1.2.1 两类数据模型</h3><ul>
<li><strong>概念模型</strong> 也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</li>
<li><strong>逻辑模型</strong>和<strong>物理模型</strong><ul>
<li><strong>逻辑模型</strong>：主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。按计算机系统的观点对数据建模，用于DBMS实现。</li>
<li><strong>物理模型</strong>：是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li>
</ul>
</li>
</ul>
<p>现实世界→数据库设计人员概念模型→数据库设计人员+设计工具逻辑模型→DBMS物理模型现实世界 \xrightarrow{数据库设计人员} 概念模型\xrightarrow{数据库设计人员+设计工具} 逻辑模型\xrightarrow{DBMS}物理模型 现实世界数据库设计人员​概念模型数据库设计人员+设计工具​逻辑模型DBMS​物理模型</p>
<h3 id="1-2-2-概念模型"><a href="#1-2-2-概念模型" class="headerlink" title="1.2.2 概念模型"></a><a href="#122-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"></a>1.2.2 概念模型</h3><p>基本概念:</p>
<ul>
<li>实体（Entity）：客观存在并可相互区别的事物</li>
<li>属性（Attribute）：实体所具有的某一特性</li>
<li>码（Key）：唯一标识实体的属性集</li>
<li>实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体</li>
<li>实体集（Entity Set）：同一类型实体的集合</li>
<li>联系（Relationship）：实体（型）内部的联系和实体（型）之间的联系</li>
<li>实体-联系方法（Entity-Relationship Approach）：用E-R图来描述现实世界的概念模型。E-R方法也称为E-R模型</li>
</ul>
<h3 id="1-2-3-数据模型的组成要素"><a href="#1-2-3-数据模型的组成要素" class="headerlink" title="1.2.3 数据模型的组成要素"></a><a href="#123-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"></a>1.2.3 数据模型的组成要素</h3><ul>
<li>数据结构</li>
<li>数据操作 ：查询、更新（包括插入、删除、修改）</li>
<li>数据的完整性约束条件</li>
</ul>
<h3 id="1-2-4-常用的数据模型"><a href="#1-2-4-常用的数据模型" class="headerlink" title="1.2.4 常用的数据模型"></a><a href="#124-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"></a>1.2.4 常用的数据模型</h3><ul>
<li>层次模型（Hierarchical Model）</li>
<li>网状模型（Network Model）</li>
<li>关系模型（Relational Model)）</li>
<li>面向对象数据模型（Object Oriented Data Model）</li>
<li>对象关系数据模型（Object Relational Data Model）</li>
<li>半结构化数据模型（Semistruture Data Model）</li>
</ul>
<h3 id="1-2-5-关系模型"><a href="#1-2-5-关系模型" class="headerlink" title="1.2.5 关系模型"></a><a href="#125-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"></a>1.2.5 关系模型</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"></a>数据结构</h4><ul>
<li>关系: 由行和列组成的二维表格(表框架 + 元组*n)</li>
<li>属性: 表框架中的每一列</li>
<li>值域(域): 元组在某一属性下的取值范围</li>
<li>元组: 关系中的每一行</li>
<li>关系数据库模式: 该关系数据库中所有关系的关系模式的集合</li>
<li>关键字: 能唯一标识关系中的一个元组, 且又不含多余的属性值 的 属性集</li>
</ul>
<h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a><a href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"></a>完整性约束</h4><ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ul>
<h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a><a href="#13-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"></a>1.3 数据库系统的结构</h2><h3 id="1-3-1-数据库系统模式的概念"><a href="#1-3-1-数据库系统模式的概念" class="headerlink" title="1.3.1 数据库系统模式的概念"></a><a href="#131-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5"></a>1.3.1 数据库系统模式的概念</h3><ul>
<li><p>模式（Schema）：数据库逻辑结构和特征的描述</p>
</li>
<li><p>实例（Instance）：模式的一个具体值</p>
</li>
</ul>
<h3 id="1-3-2-数据库系统的三级模式结构"><a href="#1-3-2-数据库系统的三级模式结构" class="headerlink" title="1.3.2 数据库系统的三级模式结构"></a><a href="#132-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"></a>1.3.2 数据库系统的三级模式结构</h3><ul>
<li>模式（Schema）：整个数据库中数据的全局逻辑结构；一个数据库只有一个模式</li>
<li>外模式（External Schema）：数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述；一个数据库可以有多个外模式</li>
<li>内模式（Internal Schema）：是数据物理结构和存储方式的描述；一个数据库只有一个内模式</li>
</ul>
<p><img src="https://i.loli.net/2021/08/31/N62AKnC1bakVXxG.png" alt="image-20210831202834790"></p>
<h3 id="1-3-3-数据库的二级映像"><a href="#1-3-3-数据库的二级映像" class="headerlink" title="1.3.3 数据库的二级映像"></a><a href="#133-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%83%8F"></a>1.3.3 数据库的二级映像</h3><ul>
<li>外模式／模式映像：多个外模式 -&gt;一个模式</li>
<li>模式／内模式映像: 数据全局逻辑结构与存储结构之间的对应关系</li>
</ul>
<h3 id="1-3-4-功能与数据独立性"><a href="#1-3-4-功能与数据独立性" class="headerlink" title="1.3.4 功能与数据独立性"></a><a href="#134-%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7"></a>1.3.4 功能与数据独立性</h3><ul>
<li>概念-&gt;内: 物理独立性</li>
<li>外-&gt;概念: 逻辑独立性</li>
</ul>
<h1 id="Chapter-2-关系数据库"><a href="#Chapter-2-关系数据库" class="headerlink" title="Chapter 2 关系数据库"></a><a href="#chapter-2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"></a>Chapter 2 关系数据库</h1><h2 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a><a href="#21-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"></a>2.1 关系数据结构及形式化定义</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>基本概念</h3><ul>
<li><p><strong>关系</strong>：D1×D2×…×DnD1×D2×…×DnD1×D2×…×Dn的子集叫做在域D1,D2,…,DnD1,D2,…,DnD1,D2,…,Dn上的关系，记做：R(D1，D2，…，Dn)R(D1，D2，…，Dn)R(D1，D2，…，Dn)。</p>
</li>
<li><p><strong>候选码</strong>（key）：某一属性组的值能唯一地标识一个元组，而其自己不能，则称该属性组为候选码(candidate key)</p>
</li>
<li><p><strong>主码</strong>：若一个关系有多个候选码，则选定其中一个为主码(primary key)，主码只可以有一个</p>
</li>
<li><p><strong>主属性</strong>(prime attribute)：候选码的各属性称为（主属性）</p>
</li>
<li><p>非主属性：不包含在任何候选码中的属性</p>
</li>
<li><p>全码(all key)：关系模式的所有属性是这个关系模式的候选码.</p>
</li>
</ul>
<h3 id="关系的性质："><a href="#关系的性质：" class="headerlink" title="关系的性质："></a><a href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"></a>关系的性质：</h3><ul>
<li>同质的列</li>
<li>不同属性应该有不同的名称</li>
<li>属性是无序的</li>
<li>元组不能重复</li>
<li>元组无序</li>
<li>分量是原子（即每一个分量都必须是不可分的数据项）</li>
</ul>
<h2 id="2-2-关系的完整性"><a href="#2-2-关系的完整性" class="headerlink" title="2.2 关系的完整性"></a><a href="#22-%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"></a>2.2 关系的完整性</h2><ul>
<li><strong>实体完整性</strong>：主属性非空</li>
<li><strong>参照完整性</strong>：外键要么取空值, 要么是被引用表中的主键值</li>
<li><strong>用户定义的完整性</strong> ：用户自己定义的属性取值约束</li>
</ul>
<h2 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a><a href="#24-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"></a>2.4 关系代数</h2><table>
<thead>
<tr>
<th></th>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>集合运算符</td>
<td>∪\cup∪</td>
<td>并</td>
</tr>
<tr>
<td></td>
<td>−-−</td>
<td>差</td>
</tr>
<tr>
<td></td>
<td>∩\cap∩</td>
<td>交</td>
</tr>
<tr>
<td></td>
<td>×\times×</td>
<td>笛卡尔积</td>
</tr>
<tr>
<td>专门的关系运算符</td>
<td>σ\sigmaσ</td>
<td>选择</td>
</tr>
<tr>
<td></td>
<td>Π\PiΠ</td>
<td>投影</td>
</tr>
<tr>
<td></td>
<td>⋈\Join⋈</td>
<td>连接</td>
</tr>
<tr>
<td></td>
<td>÷\div÷</td>
<td>除</td>
</tr>
</tbody></table>
<ul>
<li>选择运算: σF(R)\sigma_{F}(R)σF​(R)<ul>
<li>由关系R中满足条件F的各元组构成</li>
</ul>
</li>
<li>投影运算：ΠA(R)\Pi_A(R)ΠA​(R)<ul>
<li>从R中选择出若干属性列®组成新的关系</li>
<li>注意消除重复元组(行)</li>
</ul>
</li>
<li>连接运算: R⋈SR\Join SR⋈S<ul>
<li>等值连接</li>
<li>自然连接：所有同名属性上的取值都一样, 就连接元组, 同名属性保留一份</li>
<li>悬浮元组(dangling tuple)：因为公共属性组不相等被舍弃的元组</li>
<li>外连接(outer join)：把悬浮元组保存在结果关系中（ 有”外”的一侧, 其所有元组均出现, 另一侧无匹配元组就用null代替）</li>
<li>左外连接(left outer join或left join)：只保留左边关系R中的悬浮元组</li>
<li>右外连接(right outer join或right join)：只保留右边关系S中的悬浮元组</li>
</ul>
</li>
<li>除运算：R÷S=TR\div S &#x3D; TR÷S=T<ul>
<li>设$ x\in T,则, 则,则∀y\in S(x,y)\in R(x,y)\in R$ 所有满足条件的xxx构成结果</li>
</ul>
</li>
</ul>
<h1 id="Chapter-3-SQL"><a href="#Chapter-3-SQL" class="headerlink" title="Chapter 3 SQL"></a><a href="#chapter-3-sql"></a>Chapter 3 SQL</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a><a href="#31-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>3.1 基本概念</h2><p>SQL（Structured Query Language）：结构化查询语言，是关系数据库的标准语言</p>
<table>
<thead>
<tr>
<th>SQL功能</th>
<th>动词</th>
</tr>
</thead>
<tbody><tr>
<td>数据查询</td>
<td>select</td>
</tr>
<tr>
<td>数据定义</td>
<td>create, drop, alter</td>
</tr>
<tr>
<td>数据操纵</td>
<td>insert, update, delete</td>
</tr>
<tr>
<td>数据控制</td>
<td>grant, revoke</td>
</tr>
</tbody></table>
<p>SQL支持数据库三级模式结构</p>
<table><tbody><tr><td class="code"><pre><span class="line">SQL</span><br><span class="line">视图		 (外模式)</span><br><span class="line">基本表		 (模式)</span><br><span class="line">存储文件	(内模式)</span><br></pre></td></tr></tbody></table>

<h2 id="3-2-数据定义"><a href="#3-2-数据定义" class="headerlink" title="3.2 数据定义"></a><a href="#32-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"></a>3.2 数据定义</h2><table>
<thead>
<tr>
<th>操作对象</th>
<th></th>
<th>操作方式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>创建</td>
<td>删除</td>
<td>修改</td>
</tr>
<tr>
<td>模式</td>
<td>CREATE SCHEMA</td>
<td>DROP SCHEMA</td>
<td></td>
</tr>
<tr>
<td>表</td>
<td>CREATE TABLE</td>
<td>DROP TABLE</td>
<td>ALTER TABLE</td>
</tr>
<tr>
<td>视图</td>
<td>CREATE VIEW</td>
<td>DROP VIEW</td>
<td></td>
</tr>
<tr>
<td>索引</td>
<td>CREATE INDEX</td>
<td>DROP INDEX</td>
<td>ALTER INDEX</td>
</tr>
</tbody></table>
<h3 id="3-2-1-模式定义与删除"><a href="#3-2-1-模式定义与删除" class="headerlink" title="3.2.1 模式定义与删除"></a><a href="#321-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%A0%E9%99%A4"></a>3.2.1 模式定义与删除</h3><ul>
<li><p>模式定义</p>
<ul>
<li>&#96;&#96;&#96;sql<br>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]<!--code 1-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">+   模式删除</span><br><span class="line">    </span><br><span class="line">    +   ```sql</span><br><span class="line">        DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</span><br><span class="line">        &lt;!--code 2--&gt;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-2-2-基本表的定义、删除与修改"><a href="#3-2-2-基本表的定义、删除与修改" class="headerlink" title="3.2.2 基本表的定义、删除与修改"></a><a href="#322-%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9"></a>3.2.2 基本表的定义、删除与修改</h3><ul>
<li><p>定义表</p>
<ul>
<li>&#96;&#96;&#96;sql<br>CREATE TABLE &lt;表名&gt;<br>  (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]<br>  [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ]<br>      …<br>  [,&lt;表级完整性约束条件&gt; ] );<!--code 3-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">    +   | 数据类型 | 含义 |</span><br><span class="line">        | --- | --- |</span><br><span class="line">        | CHAR,CHARACTER（n） | 长度为n的定长字符串 |</span><br><span class="line">        | VARCHAR(n), CHARACTERVARYING(n) | 最大长度为n的变长字符串 |</span><br><span class="line">        | CLOB | 字符串大对象 |</span><br><span class="line">        | BLOB | 二进制大对象 |</span><br><span class="line">        | INT，INTEGER | 长整数（4字节） |</span><br><span class="line">        | SMALLINT | 短整数（2字节） |</span><br><span class="line">        | BIGINT | 大整数（8字节） |</span><br><span class="line">        | NUMERIC(p，d) | 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 |</span><br><span class="line">        | DECIMAL(p, d), DEC(p, d) | 同NUMERIC |</span><br><span class="line">        | REAL | 取决于机器精度的单精度浮点数 |</span><br><span class="line">        | DOUBLE PRECISION | 取决于机器精度的双精度浮点数 |</span><br><span class="line">        | FLOAT(n) | 可选精度的浮点数，精度至少为n位数字 |</span><br><span class="line">        | BOOLEAN | 逻辑布尔量 |</span><br><span class="line">        | DATE | 日期，包含年、月、日，格式为YYYY-MM-DD |</span><br><span class="line">        | TIME | 时间，包含一日的时、分、秒，格式为HH:MM:SS |</span><br><span class="line">        | TIMESTAMP | 时间戳类型 |</span><br><span class="line">        | INTERVAL | 时间间隔类型 |</span><br><span class="line">        </span><br><span class="line">+   修改表</span><br><span class="line">    </span><br><span class="line">    +   ```sql</span><br><span class="line">        ALTER TABLE &lt;表名&gt;</span><br><span class="line">        [ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</span><br><span class="line">        [ ADD &lt;表级完整性约束&gt;]</span><br><span class="line">        [ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ]</span><br><span class="line">        [ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ]</span><br><span class="line">        [ ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ;</span><br><span class="line">        &lt;!--code 4--&gt;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除表</p>
<ul>
<li>&#96;&#96;&#96;sql<br>DROP TABLE &lt;表名&gt;［ RESTRICT| CASCADE］<!--code 5-->



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">    +   例：为学生-课程数据库中的Student，Course，SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引</span><br><span class="line">        </span><br><span class="line">        &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; INDEX  Stusno &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; Student(Sno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; INDEX  Coucno &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; Course(Cno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; INDEX  SCno &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; SC(Sno &lt;span class=&quot;keyword&quot;&gt;ASC&lt;/span&gt;,Cno &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</span><br><span class="line">        </span><br><span class="line">+   修改索引</span><br><span class="line">    </span><br><span class="line">    +   ```sql</span><br><span class="line">        ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</span><br><span class="line">        &lt;!--code 7--&gt;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除索引</p>
<ul>
<li><pre><code class="sql">DROP INDEX &lt;索引名&gt;;
&lt;!--code 8--&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-数据查询"><a href="#3-3-数据查询" class="headerlink" title="3.3 数据查询"></a><a href="#33-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"></a>3.3 数据查询</h2><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line"> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句)      </span><br><span class="line">                   [<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></tbody></table>

<ul>
<li>SELECT子句：指定要显示的属性列</li>
<li>FROM子句：指定查询对象（基本表或视图）</li>
<li>WHERE子句：指定查询条件</li>
<li>GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。</li>
<li>HAVING短语：只有满足指定条件的组才予以输出</li>
<li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序</li>
</ul>
<h3 id="3-4-1-单表查询"><a href="#3-4-1-单表查询" class="headerlink" title="3.4.1 单表查询"></a><a href="#341-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"></a>3.4.1 单表查询</h3><h4 id="1-选择表中的若干列"><a href="#1-选择表中的若干列" class="headerlink" title="1. 选择表中的若干列"></a><a href="#1-%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%88%97"></a>1. 选择表中的若干列</h4><ul>
<li><p>查询指定列：</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询全体学生的学号与姓名</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student;&nbsp;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>查询全部列：</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student; </span><br></pre></td></tr></tbody></table>
</li>
<li><p>查询经过计算的值 :</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查全体学生的姓名及其出生年份。</span><br><span class="line"><span class="keyword">SELECT</span> Sname, <span class="number">2021</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>使用列别名改变查询结果的列标题:</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">as</span> NAME,<span class="string">'Year of Birth:'</span> <span class="keyword">as</span> BIRTH, <span class="number">2021</span><span class="operator">-</span>Sage <span class="keyword">as</span> BIRTHDAY, <span class="built_in">LOWER</span>(Sdept) DEPARTMENT	</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table>

<blockquote>
<p>注：as可写可不写</p>
</blockquote>
</li>
</ul>
<h4 id="2-选择表中的若干元组"><a href="#2-选择表中的若干元组" class="headerlink" title="2. 选择表中的若干元组"></a><a href="#2-%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%85%83%E7%BB%84"></a>2. 选择表中的若干元组</h4><ul>
<li><p>消除取值重复的行:</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC; </span><br></pre></td></tr></tbody></table>
</li>
<li><p>查询满足条件的元组</p>
<table>
<thead>
<tr>
<th>查询条件</th>
<th>谓词</th>
</tr>
</thead>
<tbody><tr>
<td>比较</td>
<td>=, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, !&#x3D;, &lt;&gt;, !&gt;, !&lt;; NOT+上述比较运算符</td>
</tr>
<tr>
<td>确定范围</td>
<td>BETWEEN AND, NOT BETWEEN AND</td>
</tr>
<tr>
<td>确定集合</td>
<td>IN, NOT IN</td>
</tr>
<tr>
<td>字符匹配</td>
<td>LIKE, NOT LIKE</td>
</tr>
<tr>
<td>空值</td>
<td>IS NULL, IS NOT NULL</td>
</tr>
<tr>
<td>多重条件（逻辑运算）</td>
<td>AND, OR, NOT</td>
</tr>
</tbody></table>
<ul>
<li><p>比较：</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询考试成绩有不及格的学生的学号。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sn</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade<span class="operator">&lt;</span><span class="number">60</span>; </span><br></pre></td></tr></tbody></table>
</li>
<li><p>确定范围（<code>BETWEEN AND, NOT BETWEEN AND</code>）：</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询年龄在<span class="number">20</span><span class="operator">~</span><span class="number">23</span>岁（包括<span class="number">20</span>岁和<span class="number">23</span>岁）之间的学生的姓名、系别和年龄</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>   Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>; </span><br></pre></td></tr></tbody></table>
</li>
<li><p>确定集合（<code>IN &lt;值表&gt;, NOT IN &lt;值表&gt;</code>）：</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询计算机科学系（CS）、数学系（MA）和信息系（<span class="keyword">IS</span>）学生的姓名和性别。</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="string">'CS'</span>,<span class="string">'MA’,'</span><span class="keyword">IS</span><span class="string">' );</span></span><br></pre></td></tr></tbody></table>
</li>
<li><p>字符匹配(<code>[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]</code>):</p>
<p>&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和 _</p>
<ul>
<li><code>%</code> 代表任意长度（长度可以为0）的字符串<br>例如a%b表示以a开头，以b结尾的任意长度的字符串</li>
<li><code>_</code>代表任意单个字符。<br>例如a_b表示以a开头，以b结尾的长度为3的任意字符串</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> 匹配串为固定字符串</span><br><span class="line">## 查询学号为<span class="number">201215121</span>的学生的详细情况。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>    </span><br><span class="line"><span class="keyword">FROM</span> Student  </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">LIKE</span> ‘<span class="number">201215121</span><span class="string">' </span></span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">2.</span> 匹配串为含通配符的字符串</span><br><span class="line">## 查询所有姓刘学生的姓名、学号和性别</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sno, Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">'刘%'</span>;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">3.</span> 使用换码字符将通配符转义为普通字符</span><br><span class="line">## 查询DB_Design课程的课程号和学分。</span><br><span class="line"><span class="keyword">SELECT</span> Cno，Ccredit</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">'DB\_Design'</span> <span class="keyword">ESCAPE</span> <span class="string">'\ '</span> ;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>涉及空值的查询(<code>IS NULL 或 IS NOT NULL</code>):</p>
<blockquote>
<p>注： “IS”不可以用”&#x3D;”代替</p>
</blockquote>
<table><tbody><tr><td class="code"><pre><span class="line"># 查所有有成绩的学生学号和课程号。</span><br><span class="line"><span class="keyword">SELECT</span> Sno，Cno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>多重条件查询:</p>
<p>逻辑运算符：AND和OR来连接多个查询条件(AND的优先级高于OR; 可以用括号改变优先级)</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询计算机系年龄在<span class="number">20</span>岁以下的学生姓名。</span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">'CS'</span> <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br></pre></td></tr></tbody></table></li>
</ul>
</li>
</ul>
<h4 id="3-ORDER-BY子句"><a href="#3-ORDER-BY子句" class="headerlink" title="3. ORDER BY子句"></a><a href="#3-order-by%E5%AD%90%E5%8F%A5"></a>3. ORDER BY子句</h4><ul>
<li>可以按一个或多个属性列排序</li>
<li>升序(默认)：ASC; 降序：DESC</li>
<li>对于空值，排序时显示的次序由具体系统实现来决定</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了<span class="number">3</span>号课程的学生的学号及其成绩，查询结果按分数降序排列。</span><br><span class="line"><span class="keyword">SELECT</span> Sno, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">' 3 '</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sdept, Sage <span class="keyword">DESC</span>; </span><br></pre></td></tr></tbody></table>

<h4 id="4-聚集函数"><a href="#4-聚集函数" class="headerlink" title="4. 聚集函数"></a><a href="#4-%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"></a>4. 聚集函数</h4><blockquote>
<p>注：聚集函数不能用在WHERE子句中的条件表达式中！！！</p>
</blockquote>
<ul>
<li><p>统计元组个数:</p>
<p>COUNT(*)</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询学生总人数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span>  Student;&nbsp;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>统计一列中值的个数:</p>
<p>COUNT([DISTINCT|ALL] &lt;列名&gt;)</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了课程的学生人数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>计算一列值的总和（此列必须为数值型）:</p>
<p>SUM([DISTINCT|ALL] &lt;列名&gt;)</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询学生<span class="number">201215012</span>选修课程的总学分数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Ccredit)</span><br><span class="line"><span class="keyword">FROM</span>  SC,Course</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">'201215012'</span> <span class="keyword">AND</span> SC.Cno<span class="operator">=</span>Course.Cno;</span><br></pre></td></tr></tbody></table>

<p>​</p>
</li>
<li><p>计算一列值的平均值（此列必须为数值型）:</p>
<p>AVG([DISTINCT|ALL] &lt;列名&gt;)</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 计算<span class="number">1</span>号课程的学生平均成绩。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>求一列中的最大值和最小值</p>
<p>MAX([DISTINCT|ALL] &lt;列名&gt;)</p>
<p>MIN([DISTINCT|ALL] &lt;列名&gt;)</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询选修<span class="number">1</span>号课程的学生最高分数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table></li>
</ul>
<h4 id="5-GROUP-BY子句"><a href="#5-GROUP-BY子句" class="headerlink" title="5. GROUP BY子句"></a><a href="#5-group-by%E5%AD%90%E5%8F%A5"></a>5. GROUP BY子句</h4><p>细化聚集函数的作用对象</p>
<ul>
<li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li>
<li>对查询结果分组后，聚集函数将分别作用于每个组</li>
<li>按指定的一列或多列值分组，值相等的为一组</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 求各个课程号及相应的选课人数。</span><br><span class="line"><span class="keyword">SELECT</span> Cno，<span class="built_in">COUNT</span>(Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;&nbsp;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了<span class="number">3</span>门以上课程的学生学号。</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span><span class="number">3</span>;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># 查询平均成绩大于等于<span class="number">90</span>分的学生学号和平均成绩</span><br><span class="line"><span class="keyword">SELECT</span>  Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></tbody></table>

<blockquote>
<p>注：WHERE子句中不能用聚集函数作为条件表达式！！！</p>
</blockquote>
<blockquote>
<p>注：HAVING短语与WHERE子句的区别：作用对象不同</p>
<ul>
<li>WHERE子句作用于基表或视图，从中选择满足条件的元组</li>
<li>HAVING短语作用于组，从中选择满足条件的组。</li>
</ul>
</blockquote>
<h3 id="3-4-2-连接查询"><a href="#3-4-2-连接查询" class="headerlink" title="3.4.2 连接查询"></a><a href="#342-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"></a>3.4.2 连接查询</h3><ul>
<li>连接查询：同时涉及两个以上的表的查询</li>
<li>连接条件或连接谓词：用来连接两个表的条件。一般格式：<br>[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;<br>[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li>
<li>连接字段：连接谓词中的列名称</li>
<li>连接条件中的各连接字段类型必须是可比的，但名字不必相同</li>
</ul>
<h4 id="1-等值与非等值连接查询"><a href="#1-等值与非等值连接查询" class="headerlink" title="1. 等值与非等值连接查询"></a><a href="#1-%E7%AD%89%E5%80%BC%E4%B8%8E%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"></a>1. 等值与非等值连接查询</h4><ul>
<li><p>等值连接：连接运算符为&#x3D;</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询每个学生及其选修课程的情</span><br><span class="line"><span class="keyword">SELECT</span> Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>自然连接</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询选修<span class="number">2</span>号课程且成绩在<span class="number">90</span>分以上的所有学生的学号和姓名。</span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student, SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC.Sno  <span class="keyword">AND</span>  SC.Cno<span class="operator">=</span><span class="string">' 2 '</span> <span class="keyword">AND</span> SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></tbody></table></li>
</ul>
<h4 id="2-自身连接"><a href="#2-自身连接" class="headerlink" title="2. 自身连接"></a><a href="#2-%E8%87%AA%E8%BA%AB%E8%BF%9E%E6%8E%A5"></a>2. 自身连接</h4><ul>
<li>自身连接：一个表与其自己进行连接</li>
<li>需要给表起别名以示区别</li>
<li>由于所有属性名都是同名属性，因此必须使用别名前缀</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询每一门课的间接先修课（即先修课的先修课）</span><br><span class="line"><span class="keyword">SELECT</span> FIRST.Cno, SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course  <span class="keyword">FIRST</span>, Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br></pre></td></tr></tbody></table>

<h4 id="3-外连接"><a href="#3-外连接" class="headerlink" title="3. 外连接"></a><a href="#3-%E5%A4%96%E8%BF%9E%E6%8E%A5"></a>3. 外连接</h4><p>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出（左外连接、右外连接）</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询每个学生及其选修课程的情</span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student <span class="keyword">LEFT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> (Student.Sno<span class="operator">=</span>SC.Sno); </span><br></pre></td></tr></tbody></table>

<h4 id="4-多表连接"><a href="#4-多表连接" class="headerlink" title="4. 多表连接"></a><a href="#4-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5"></a>4. 多表连接</h4><table><tbody><tr><td class="code"><pre><span class="line"># 查询每个学生的学号、姓名、选修的课程名及成绩</span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> Student, SC, Course    <span class="comment">/*多表连接*/</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno <span class="keyword">AND</span> SC.Cno <span class="operator">=</span> Course.Cno;</span><br></pre></td></tr></tbody></table>

<h3 id="3-4-3-嵌套查询"><a href="#3-4-3-嵌套查询" class="headerlink" title="3.4.3 嵌套查询"></a><a href="#343-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"></a>3.4.3 嵌套查询</h3><ul>
<li><p>一个SELECT-FROM-WHERE语句称为一个<strong>查询块</strong></p>
</li>
<li><p>将一个查询块嵌套在另一个查询块的<strong>WHERE</strong>子句或<strong>HAVING</strong>短语的条件中的查询称为<strong>嵌套查询</strong></p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname 	<span class="comment">/*外层查询/父查询*/</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">		( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">          <span class="keyword">FROM</span> SC</span><br><span class="line">          <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">' 2 '</span>);</span><br></pre></td></tr></tbody></table>
</li>
<li><p>上层的查询块称为<strong>外层查询</strong>或<strong>父查询</strong><br>下层查询块称为<strong>内层查询</strong>或<strong>子查询</strong></p>
</li>
<li><p>SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询</p>
</li>
<li><p>子查询的限制：不能使用ORDER BY子句！</p>
</li>
<li><p><strong>不相关子查询</strong>：子查询的查询条件不依赖于父查询</p>
<ul>
<li>由里向外 逐层处理</li>
<li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li>
<li>然后再取外层表的下一个元组</li>
<li>重复这一过程，直至外层表全部检查完为止</li>
</ul>
</li>
</ul>
<h4 id="1-带有IN谓词的子查询"><a href="#1-带有IN谓词的子查询" class="headerlink" title="1. 带有IN谓词的子查询"></a><a href="#1-%E5%B8%A6%E6%9C%89in%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>1. 带有IN谓词的子查询</h4><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了课程名为“信息系统”的学生学号和姓名</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname	# step3: 最后在Student关系中取出Sno和Sname</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> Sno		# step2: 然后在SC关系中找出选修了<span class="number">3</span>号课程的学生学号</span><br><span class="line">	 <span class="keyword">FROM</span> SC                         </span><br><span class="line">	 <span class="keyword">WHERE</span>  Cno <span class="keyword">IN</span></span><br><span class="line"> 		(<span class="keyword">SELECT</span> Cno		# step1: 首先在Course关系中找出“信息系统”的课程号(<span class="number">3</span>号)</span><br><span class="line">         <span class="keyword">FROM</span> Course           </span><br><span class="line">         <span class="keyword">WHERE</span> Cname<span class="operator">=</span> <span class="string">'信息系统'</span>)</span><br><span class="line">        );</span><br></pre></td></tr></tbody></table>

<h4 id="2-带有比较运算符的子查询"><a href="#2-带有比较运算符的子查询" class="headerlink" title="2. 带有比较运算符的子查询"></a><a href="#2-%E5%B8%A6%E6%9C%89%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>2. 带有比较运算符的子查询</h4><ul>
<li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，&#x3D;，&gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&lt; &gt;）</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 找出每个学生超过他选修课程平均成绩的课程号。</span><br><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC  x</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> AVG（Grade） </span><br><span class="line">		        <span class="keyword">FROM</span>  SC y</span><br><span class="line">               <span class="keyword">WHERE</span> y.Sno<span class="operator">=</span>x.Sno);</span><br></pre></td></tr></tbody></table>

<h4 id="3-带有ANY（SOME）或ALL谓词的子查询"><a href="#3-带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="3. 带有ANY（SOME）或ALL谓词的子查询"></a><a href="#3-%E5%B8%A6%E6%9C%89anysome%E6%88%96all%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>3. 带有ANY（SOME）或ALL谓词的子查询</h4><ul>
<li><p>ANY: 某个; ALL: 所有</p>
</li>
<li><p>使用ANY或ALL谓词时必须同时使用比较运算:</p>
<ul>
<li><code>&gt; ANY</code> 大于子查询结果中的某个值</li>
<li><code>&gt; ALL</code> 大于子查询结果中的所有值</li>
<li><code>!=（或&lt;&gt;）ANY</code> 不等于子查询结果中的某个值</li>
<li><code>!=（或&lt;&gt;）ALL</code> 不等于子查询结果中的任何一个值</li>
<li>…</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄</span><br><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span>  Sage</span><br><span class="line">                  <span class="keyword">FROM</span>    Student</span><br><span class="line">                  <span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">' CS '</span>)</span><br><span class="line">      <span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> ‘CS <span class="string">';</span></span><br></pre></td></tr></tbody></table></li>
</ul>
<h4 id="4-带有EXISTS谓词的子查询"><a href="#4-带有EXISTS谓词的子查询" class="headerlink" title="4. 带有EXISTS谓词的子查询"></a><a href="#4-%E5%B8%A6%E6%9C%89exists%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>4. 带有EXISTS谓词的子查询</h4><ul>
<li><strong>EXISTS</strong>谓词<ul>
<li>存在量词 ∃\exist∃</li>
<li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。<ul>
<li>若内层查询结果非空，则外层的WHERE子句返回真值</li>
<li>若内层查询结果为空，则外层的WHERE子句返回假值</li>
</ul>
</li>
</ul>
</li>
<li><strong>NOT EXISTS</strong>谓词</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询没有选修<span class="number">1</span>号课程的学生姓名。</span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">          (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> SC</span><br><span class="line">           <span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">'1'</span>);</span><br></pre></td></tr></tbody></table>

<ul>
<li><p>不同形式的查询间的替换</p>
<ul>
<li>一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换</li>
<li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li>
</ul>
</li>
<li><p>用EXISTS&#x2F;NOT EXISTS实现<strong>全称量词</strong></p>
<ul>
<li><p>SQL语言中没有全称量词 $\forall $</p>
</li>
<li><p>可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：</p>
<p>(∀x)P≡(∃x(¬P))(\forall x)P \equiv (\exist x (\lnot P)) (∀x)P≡(∃x(¬P))</p>
</li>
</ul>
</li>
<li><p>用EXISTS&#x2F;NOT EXISTS实现逻辑<strong>蕴涵</strong></p>
</li>
<li><p>SQL语言中没有蕴涵（Implication）逻辑运算</p>
</li>
<li><p>可以利用谓词演算将逻辑蕴涵谓词等价转换为:</p>
<p>p \to q \equiv \lnot p \or q</p>
</li>
</ul>
<h3 id="3-4-4-集合查询"><a href="#3-4-4-集合查询" class="headerlink" title="3.4.4 集合查询"></a><a href="#344-%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2"></a>3.4.4 集合查询</h3><ul>
<li><p>集合操作的种类</p>
<ul>
<li>并操作 <strong>UNION</strong></li>
<li>交操作 <strong>INTERSECT</strong></li>
<li>差操作 <strong>EXCEPT</strong></li>
</ul>
</li>
<li><p>参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了课程<span class="number">1</span>或者选修了课程<span class="number">2</span>的学生。</span><br><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">' 1 '</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">' 2 '</span>;</span><br></pre></td></tr></tbody></table></li>
</ul>
<h3 id="3-4-5-基于派生表的查询"><a href="#3-4-5-基于派生表的查询" class="headerlink" title="3.4.5 基于派生表的查询"></a><a href="#345-%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"></a>3.4.5 基于派生表的查询</h3><ul>
<li><p>子查询出现在FROM子句中，此时子查询生成的临时派生表（Derived Table）成为主查询的查询对象</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 找出每个学生超过他自己选修课程平均成绩的课程号</span><br><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC, (<span class="keyword">SELECT</span> Sno, <span class="built_in">Avg</span>(Grade) </span><br><span class="line">		  <span class="keyword">FROM</span> SC</span><br><span class="line">    	  <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno) <span class="keyword">AS</span> Avg_sc(avg_sno,avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno <span class="operator">=</span> Avg_sc.avg_sno <span class="keyword">and</span> SC.Grade <span class="operator">&gt;=</span>Avg_sc.avg_grade</span><br></pre></td></tr></tbody></table>
</li>
<li><p>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性。</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 查询所有选修了<span class="number">1</span>号课程的学生姓名，可以用如下查询完成：</span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">' 1 '</span>) <span class="keyword">AS</span> SC1</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC1.Sno;</span><br></pre></td></tr></tbody></table></li>
</ul>
<h2 id="3-4-数据更新"><a href="#3-4-数据更新" class="headerlink" title="3.4 数据更新"></a><a href="#34-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"></a>3.4 数据更新</h2><h3 id="3-4-1-插入数据"><a href="#3-4-1-插入数据" class="headerlink" title="3.4.1 插入数据"></a><a href="#341-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"></a>3.4.1 插入数据</h3><h4 id="1-插入元组"><a href="#1-插入元组" class="headerlink" title="1. 插入元组"></a><a href="#1-%E6%8F%92%E5%85%A5%E5%85%83%E7%BB%84"></a>1. 插入元组</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>属性列<span class="number">2</span> <span class="operator">&gt;</span>…)]</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>]… );</span><br></pre></td></tr></tbody></table>

<ul>
<li>INTO子句:<ul>
<li>指定要插入数据的表名及属性列</li>
<li>属性列的顺序可与表定义中的顺序不一致</li>
<li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致</li>
<li>指定部分属性列：插入的元组在其余属性列上取空值</li>
</ul>
</li>
<li>VALUES子句：<ul>
<li>提供的值必须与INTO子句匹配<ul>
<li>值的个数</li>
<li>值的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 插入一条选课记录（ <span class="string">'200215128'</span>,<span class="string">'1 '</span>）。</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> SC(Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'201215128 '</span>,<span class="string">'1'</span>); # 关系数据库管理系统将在新插入记录的Grade列上自动赋空值</span><br></pre></td></tr></tbody></table>

<h4 id="2-插入子查询结果（可以一次插入多个元组）"><a href="#2-插入子查询结果（可以一次插入多个元组）" class="headerlink" title="2. 插入子查询结果（可以一次插入多个元组）"></a><a href="#2-%E6%8F%92%E5%85%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8F%AF%E4%BB%A5%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84"></a>2. 插入子查询结果（可以一次插入多个元组）</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>  [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>…  )]</span><br><span class="line">子查询;</span><br></pre></td></tr></tbody></table>

<ul>
<li>子查询中 SELECT子句目标列 必须与 INTO子句 匹配<ul>
<li>值的个数</li>
<li>值的类型</li>
</ul>
</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 对每一个系，求学生的平均年龄，并把结果存入数据库</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Dept_age(Sdept,Avg_age)</span><br><span class="line"><span class="keyword">SELECT</span> Sdept，<span class="built_in">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sdept;</span><br></pre></td></tr></tbody></table>

<ul>
<li>关系数据库管理系统在执行插入语句时会检查所插元组是否破坏表上已定义的完整性规则:实体完整性; 参照完整性; 用户定义的完整性(NOT NULL约束, UNIQUE约束, 值域约束)</li>
</ul>
<h3 id="3-4-2-修改数据"><a href="#3-4-2-修改数据" class="headerlink" title="3.4.2 修改数据"></a><a href="#342-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"></a>3.4.2 修改数据</h3><table><tbody><tr><td class="code"><pre><span class="line">UPDATE  <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span>  <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>]…</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></tbody></table>

<h4 id="1-修改某一个元组的值"><a href="#1-修改某一个元组的值" class="headerlink" title="1. 修改某一个元组的值"></a><a href="#1-%E4%BF%AE%E6%94%B9%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>1. 修改某一个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将学生<span class="number">201215121</span>的年龄改为<span class="number">22</span>岁</span><br><span class="line">UPDATE Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">'201215121'</span>;</span><br></pre></td></tr></tbody></table>

<h4 id="2-修改多个元组的值"><a href="#2-修改多个元组的值" class="headerlink" title="2. 修改多个元组的值"></a><a href="#2-%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>2. 修改多个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将所有学生的年龄增加<span class="number">1</span>岁</span><br><span class="line">UPDATE Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span>Sage<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></tbody></table>

<h4 id="3-带子查询的修改语句"><a href="#3-带子查询的修改语句" class="headerlink" title="3. 带子查询的修改语句"></a><a href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BF%AE%E6%94%B9%E8%AF%AD%E5%8F%A5"></a>3. 带子查询的修改语句</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将计算机科学系全体学生的成绩置零。</span><br><span class="line">UPDATE SC</span><br><span class="line"><span class="keyword">SET</span> Grade<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">	(SELETE Sno</span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">'CS'</span> );</span><br></pre></td></tr></tbody></table>

<ul>
<li>关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则</li>
</ul>
<h3 id="3-4-3-删除数据"><a href="#3-4-3-删除数据" class="headerlink" title="3.4.3 删除数据"></a><a href="#343-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"></a>3.4.3 删除数据</h3><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></tbody></table>

<h4 id="1-删除某一个元组的值"><a href="#1-删除某一个元组的值" class="headerlink" title="1. 删除某一个元组的值"></a><a href="#1-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>1. 删除某一个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 删除学号为<span class="number">201215128</span>的学生记录。</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span> <span class="number">201215128</span> <span class="string">';</span></span><br></pre></td></tr></tbody></table>

<h4 id="2-删除多个元组的值"><a href="#2-删除多个元组的值" class="headerlink" title="2. 删除多个元组的值"></a><a href="#2-%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>2. 删除多个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 删除所有的学生选课记录。</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></tbody></table>

<h4 id="3-带子查询的删除语句"><a href="#3-带子查询的删除语句" class="headerlink" title="3. 带子查询的删除语句"></a><a href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5"></a>3. 带子查询的删除语句</h4><table><tbody><tr><td class="code"><pre><span class="line"># 删除计算机科学系所有学生的选课记录。</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sno  <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span>  Sno</span><br><span class="line">     <span class="keyword">FROM</span>   Student</span><br><span class="line">     <span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">'CS'</span>) ;</span><br></pre></td></tr></tbody></table>

<h2 id="3-5-空值的处理"><a href="#3-5-空值的处理" class="headerlink" title="3.5 空值的处理"></a><a href="#35-%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86"></a>3.5 空值的处理</h2><ul>
<li>判断：<code>IS NULL</code>或<code>IS NOT NULL</code></li>
<li>约束条件：属性定义（或者域定义）中<ul>
<li>有NOT NULL约束条件的不能取空值</li>
<li>加了UNIQUE限制的属性不能取空值</li>
<li>码属性不能取空值</li>
</ul>
</li>
<li>运算：<ul>
<li>空值与另一个值（包括另一个空值）的算术运算的结果为空值</li>
<li>空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。</li>
<li>有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑</li>
</ul>
</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 选出选修<span class="number">1</span>号课程的不及格的学生以及缺考的学生。</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">'1'</span> <span class="keyword">AND</span> (Grade<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">OR</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></tbody></table>

<h2 id="3-6-视图"><a href="#3-6-视图" class="headerlink" title="3.6 视图"></a><a href="#36-%E8%A7%86%E5%9B%BE"></a>3.6 视图</h2><ul>
<li>虚表，是从一个或几个基本表（或视图）导出的表</li>
<li>只存放视图的定义，不存放视图对应的数据</li>
<li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li>
</ul>
<h3 id="3-6-1-定义视图"><a href="#3-6-1-定义视图" class="headerlink" title="3.6.1 定义视图"></a><a href="#361-%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE"></a>3.6.1 定义视图</h3><h4 id="1-建立视图"><a href="#1-建立视图" class="headerlink" title="1. 建立视图"></a><a href="#1-%E5%BB%BA%E7%AB%8B%E8%A7%86%E5%9B%BE"></a>1. 建立视图</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> </span><br><span class="line"> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>  [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>  [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]…)]</span><br><span class="line"><span class="keyword">AS</span>  <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span>  <span class="keyword">CHECK</span>  OPTION];</span><br></pre></td></tr></tbody></table>

<ul>
<li><code>WITH CHECK OPTION</code>: 对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</li>
<li>子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现。</li>
<li>关系数据库管理系统执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句。</li>
<li>在对视图查询时，按视图的定义从基本表中将数据查出。</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> 行列子集视图(一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码)</span><br><span class="line">## 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">'IS'</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">2.</span> 基于多个基表的视图</span><br><span class="line">## 建立信息系选修了<span class="number">1</span>号课程的学生的视图（包括学号、姓名、成绩）。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">'IS'</span> <span class="keyword">AND</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span> SC.Cno<span class="operator">=</span> <span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">3.</span> 基于视图的视图</span><br><span class="line">## 建立信息系选修了<span class="number">1</span>号课程且成绩在<span class="number">90</span>分以上的学生的视图。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  IS_S1</span><br><span class="line"><span class="keyword">WHERE</span>  Grade<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">4.</span> 带表达式的视图</span><br><span class="line">## 定义一个反映学生出生年份的视图。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,<span class="number">2014</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># 分组视图</span><br><span class="line">## 将学生的学号及平均成绩定义为一个视图</span><br><span class="line">CREAT  <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line"><span class="keyword">AS</span>  </span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></tbody></table>

<h4 id="2-删除视图"><a href="#2-删除视图" class="headerlink" title="2. 删除视图"></a><a href="#2-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"></a>2. 删除视图</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span>  <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE];</span><br></pre></td></tr></tbody></table>

<ul>
<li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li>
</ul>
<h3 id="3-6-2-查询视图"><a href="#3-6-2-查询视图" class="headerlink" title="3.6.2 查询视图"></a><a href="#362-%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE"></a>3.6.2 查询视图</h3><ul>
<li>用户角度：查询视图与查询基本表相同</li>
<li>关系数据库管理系统实现视图查询的方法：<ul>
<li>视图消解法（View Resolution）：进行有效性检查；转换成等价的对基本表的查询；执行修正后的查询</li>
<li>视图消解法的局限：有些情况下，视图消解法不能生成正确的查询。（比如：聚集函数不能用于WHERE子句，需转换成HAVING）</li>
</ul>
</li>
</ul>
<h3 id="3-6-3-更新视图"><a href="#3-6-3-更新视图" class="headerlink" title="3.6.3 更新视图"></a><a href="#363-%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"></a>3.6.3 更新视图</h3><ul>
<li>允许对行列子集视图进行更新</li>
<li>对其他类型视图的更新不同系统有不同限制</li>
</ul>
<h3 id="3-6-4-视图的作用"><a href="#3-6-4-视图的作用" class="headerlink" title="3.6.4 视图的作用"></a><a href="#364-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"></a>3.6.4 视图的作用</h3><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰的表达查询</li>
</ul>
<h1 id="Chapter-4-数据库安全性"><a href="#Chapter-4-数据库安全性" class="headerlink" title="Chapter 4 数据库安全性"></a><a href="#chapter-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7"></a>Chapter 4 数据库安全性</h1><ul>
<li><p>数据库的不安全因素</p>
<ul>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄露</li>
<li>安全环境的脆弱性</li>
</ul>
</li>
<li><p>安全标准:TCSEC&#x2F;TDI安全级别划分</p>
<table>
<thead>
<tr>
<th>安 全 级 别</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>A1</td>
<td>验证设计（Verified Design）</td>
</tr>
<tr>
<td>B3</td>
<td>安全域（Security Domains）</td>
</tr>
<tr>
<td>B2</td>
<td>结构化保护（Structural Protection）</td>
</tr>
<tr>
<td>B1</td>
<td>标记安全保护（Labeled Security Protection）</td>
</tr>
<tr>
<td>C2</td>
<td>受控的存取保护（Controlled Access Protection）</td>
</tr>
<tr>
<td>C1</td>
<td>自主安全保护（Discretionary Security Protection）</td>
</tr>
<tr>
<td>D</td>
<td>最小保护（Minimal Protection）</td>
</tr>
</tbody></table>
</li>
<li><p>计算机系统中，安全措施是一级一级层层设置</p>
<p><img src="https://i.loli.net/2021/09/04/wGJx7iAsvb51tYV.png" alt="image-20210904162607592"></p>
</li>
<li><p>数据库安全性控制的常用方法</p>
<ul>
<li><p>用户标识和鉴定: 静态口令鉴别, 动态口令鉴别, 生物特征鉴别,智能卡鉴别</p>
</li>
<li><p>存取控制: 定义用户权限，并将用户权限登记到数据字典中; 合法权限检查</p>
<ul>
<li>自主存取控制方法: 通过 SQL 的GRANT 语句和REVOKE 语句实现</li>
<li>强制存取控制方法</li>
</ul>
</li>
<li><p>视图</p>
</li>
<li><p>审计</p>
<ul>
<li>启用一个专用的审计日志（Audit Log）, 将用户对数据库的所有操作记录在上面</li>
<li>AUDIT语句：设置审计功能</li>
<li>NOAUDIT语句：取消审计功能</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 对修改SC表结构或修改SC表数据的操作进行审计</span><br><span class="line">AUDIT <span class="keyword">ALTER</span>,UPDATE  </span><br><span class="line"><span class="keyword">ON</span>  SC;</span><br><span class="line"></span><br><span class="line"># 取消对SC表的一切审计</span><br><span class="line">NOAUDIT  <span class="keyword">ALTER</span>,UPDATE  </span><br><span class="line"><span class="keyword">ON</span>  SC;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>数据加密: 存储加密; 传输加密</p>
</li>
</ul>
</li>
<li><p>授权</p>
<ul>
<li><p><code>GRANT</code>:</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]... </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></tbody></table>

<ul>
<li>发出GRANT：数据库管理员, 数据库对象创建者（即属主Owner）,拥有该权限的用户</li>
<li>按受权限的用户: 一个或多个具体用户, PUBLIC（即全体用户）</li>
<li><code>WITH GRANT OPTION</code>子句:<ul>
<li>指定：可以再授予</li>
<li>没有指定：不能传播</li>
</ul>
</li>
<li>不允许循环授权</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 把对Student表和Course表的全部权限授予用户U2和U3</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student,Course </span><br><span class="line"><span class="keyword">TO</span> U2,U3;</span><br><span class="line"></span><br><span class="line"># 把对表SC的查询权限授予所有用户</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> PUBLIC;</span><br><span class="line"></span><br><span class="line"># 把查询Student表和修改学生学号的权限授给用户U4</span><br><span class="line"><span class="keyword">GRANT</span> UPDATE(Sno), <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">TO</span> U4;</span><br><span class="line"></span><br><span class="line"># 把对表SC的<span class="keyword">INSERT</span>权限授予U5用户，并允许他再将此权限授予其他用户</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> U5</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></tbody></table>
</li>
<li><p><code>REVOKE</code></p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]... </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...[CASCADE <span class="operator">|</span> RESTRICT];</span><br></pre></td></tr></tbody></table>

<ul>
<li>授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 把用户U4修改学生学号的权限收回</span><br><span class="line"><span class="keyword">REVOKE</span> UPDATE(Sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">FROM</span> U4;</span><br><span class="line"></span><br><span class="line"># 收回所有用户对表SC的查询权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">FROM</span> PUBLIC;</span><br><span class="line"></span><br><span class="line"># 把用户U5对SC表的<span class="keyword">INSERT</span>权限收回</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">FROM</span> U5 CASCADE;</span><br></pre></td></tr></tbody></table>
</li>
<li><p>创建数据库模式的权限（数据库管理员在创建用户时实现）</p>
<table><tbody><tr><td class="code"><pre><span class="line"># <span class="keyword">CREATE</span> <span class="keyword">USER</span>语句格式(不是<span class="keyword">SQL</span>标准，各个系统的实现不同)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span> </span><br><span class="line">[<span class="keyword">WITH</span>] [DBA<span class="operator">|</span>RESOURCE<span class="operator">|</span><span class="keyword">CONNECT</span>];</span><br></pre></td></tr></tbody></table>

<ul>
<li><p>只有系统的超级用户才有权创建一个新的数据库用户</p>
</li>
<li><p>新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA</p>
<table>
<thead>
<tr>
<th></th>
<th>CREATE USER</th>
<th>CREATE SCHEMA</th>
<th>CREATE TABLE</th>
<th>登录数据库，执行数据查询和操作</th>
</tr>
</thead>
<tbody><tr>
<td>DBA</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>RESOURCE</td>
<td>❌</td>
<td>❌</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>CONNECT</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✔(但必须拥有相应权限)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库角色</p>
<ul>
<li><p>角色的创建</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table>
</li>
<li><p>给角色授权</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]… </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span>对象名  </span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]…</span><br></pre></td></tr></tbody></table>
</li>
<li><p>将一个角色授予其他的角色或用户</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>角色<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="number">2</span><span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="number">3</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span>]… </span><br><span class="line">[<span class="keyword">WITH</span> ADMIN OPTION]		# 指定了<span class="keyword">WITH</span> ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色</span><br></pre></td></tr></tbody></table>
</li>
<li><p>角色权限的收回</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]…</span><br></pre></td></tr></tbody></table></li>
</ul>
</li>
</ul>
<h1 id="Chapter-5-数据库完整性"><a href="#Chapter-5-数据库完整性" class="headerlink" title="Chapter 5 数据库完整性"></a><a href="#chapter-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"></a>Chapter 5 数据库完整性</h1><h2 id="5-1-实体完整性"><a href="#5-1-实体完整性" class="headerlink" title="5.1 实体完整性"></a><a href="#51-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"></a>5.1 实体完整性</h2><h3 id="5-1-1-实体完整性定义"><a href="#5-1-1-实体完整性定义" class="headerlink" title="5.1.1 实体完整性定义"></a><a href="#511-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E5%AE%9A%E4%B9%89"></a>5.1.1 实体完整性定义</h3><p>CREATE TABLE 中用<code>PRIMARY KEY</code>定义</p>
<h4 id="（1）在列级定义主码"><a href="#（1）在列级定义主码" class="headerlink" title="（1）在列级定义主码"></a><a href="#1%E5%9C%A8%E5%88%97%E7%BA%A7%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81"></a>（1）在列级定义主码</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将Student表中的Sno属性定义为码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	( Sno  <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	  Sname  <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,     </span><br><span class="line">	  Ssex  <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">	  Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">	  Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">	);</span><br></pre></td></tr></tbody></table>

<h4 id="（2）在表级定义主码"><a href="#（2）在表级定义主码" class="headerlink" title="（2）在表级定义主码"></a><a href="#2%E5%9C%A8%E8%A1%A8%E7%BA%A7%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81"></a>（2）在表级定义主码</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将SC表中的Sno，Cno属性组定义为码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">	( Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">      Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">      Grade <span class="type">SMALLINT</span>,</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (Sno,Cno)    <span class="comment">/*只能在表级定义主码*/</span></span><br><span class="line">    ); </span><br></pre></td></tr></tbody></table>

<h3 id="5-1-2-实体完整性检查和违约处理"><a href="#5-1-2-实体完整性检查和违约处理" class="headerlink" title="5.1.2 实体完整性检查和违约处理"></a><a href="#512-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"></a>5.1.2 实体完整性检查和违约处理</h3><ul>
<li>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：<ul>
<li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li>
<li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li>
</ul>
</li>
<li>检查记录中主码值是否唯一的一种方法是进行<strong>全表扫描</strong>，依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同</li>
<li>为避免对基本表进行全表扫描（耗时），RDBMS核心一般都在主码上自动建立一个索引（B+树索引）</li>
</ul>
<h2 id="5-2-参照完整性"><a href="#5-2-参照完整性" class="headerlink" title="5.2 参照完整性"></a><a href="#52-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7"></a>5.2 参照完整性</h2><h3 id="5-2-1-参照完整性定义"><a href="#5-2-1-参照完整性定义" class="headerlink" title="5.2.1 参照完整性定义"></a><a href="#521-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%AE%9A%E4%B9%89"></a>5.2.1 参照完整性定义</h3><ul>
<li>在CREATE TABLE中用<code>FOREIGN KEY</code>短语定义哪些列为外码</li>
<li>用<code>REFERENCES</code>短语指明这些外码参照哪些表的主码</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 关系SC中（Sno，Cno）是主码。Sno，Cno分别参照Student表的主码和Course表的主码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">	( Sno <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">	  Cno <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">	  Grade <span class="type">SMALLINT</span>,</span><br><span class="line">	  <span class="keyword">PRIMARY</span> KEY (Sno, Cno),   <span class="comment">/*在表级定义实体完整性*/</span></span><br><span class="line">	  <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),  <span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">	  <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)	<span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">	);</span><br></pre></td></tr></tbody></table>

<h3 id="5-2-2-参照完整性检查和违约处理"><a href="#5-2-2-参照完整性检查和违约处理" class="headerlink" title="5.2.2 参照完整性检查和违约处理"></a><a href="#522-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"></a>5.2.2 参照完整性检查和违约处理</h3><table>
<thead>
<tr>
<th>被参照表</th>
<th></th>
<th>参照表</th>
<th>违约处理</th>
</tr>
</thead>
<tbody><tr>
<td>（可能破坏参照完整性）</td>
<td>←\leftarrow←</td>
<td>插入元组</td>
<td>拒绝</td>
</tr>
<tr>
<td>（可能破坏参照完整性）</td>
<td>←\leftarrow←</td>
<td>修改外码值</td>
<td>拒绝</td>
</tr>
<tr>
<td>删除元组</td>
<td>→\rightarrow→</td>
<td>（可能破坏参照完整性）</td>
<td>拒绝&#x2F;级连删除&#x2F;设置为空值</td>
</tr>
<tr>
<td>修改主码值</td>
<td>→\rightarrow→</td>
<td>（可能破坏参照完整性）</td>
<td>拒绝&#x2F;级连删除&#x2F;设置为空值</td>
</tr>
</tbody></table>
<ul>
<li>参照完整性违约处理<ul>
<li>拒绝（NO ACTION）执行<br>不允许该操作执行。该策略一般设置为默认策略</li>
<li>级联（CASCADE）操作<br>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组</li>
<li>设置为空值（SET-NULL）<br>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</li>
</ul>
</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"> # 显式说明参照完整性的违约处理示例</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    ( Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">      Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">      Grade <span class="type">SMALLINT</span>,</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY(Sno,Cno)，</span><br><span class="line">      <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno) </span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE		<span class="comment">/*级联删除SC表中相应的元组*/</span></span><br><span class="line">      <span class="keyword">ON</span> UPDATE CASCADE, 	<span class="comment">/*级联更新SC表中相应的元组*/</span></span><br><span class="line">      <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION	<span class="comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span></span><br><span class="line">      <span class="keyword">ON</span> UPDATE CASCADE		<span class="comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span></span><br><span class="line">     );</span><br></pre></td></tr></tbody></table>

<h2 id="5-3-用户定义的完整性"><a href="#5-3-用户定义的完整性" class="headerlink" title="5.3 用户定义的完整性"></a><a href="#53-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"></a>5.3 用户定义的完整性</h2><ul>
<li>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求</li>
<li>关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</li>
</ul>
<h3 id="5-3-1-属性上的约束条件"><a href="#5-3-1-属性上的约束条件" class="headerlink" title="5.3.1 属性上的约束条件"></a><a href="#531-%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"></a>5.3.1 属性上的约束条件</h3><ul>
<li><p>CREATE TABLE时定义属性上的约束条件</p>
<ul>
<li><p>列值非空（<code>NOT NULL</code>）</p>
</li>
<li><p>列值唯一（<code>UNIQUE</code>）</p>
</li>
<li><p>检查列值是否满足一个条件表达式（<code>CHECK</code>）:</p>
<table><tbody><tr><td class="code"><pre><span class="line"># Student表的Ssex只允许取“男”或“女”。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    ( Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">      Sname <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                     </span><br><span class="line">      Ssex <span class="type">CHAR</span>(<span class="number">2</span>)  <span class="keyword">CHECK</span> （Ssex <span class="keyword">IN</span> （‘男’,’女’））, <span class="comment">/*性别属性Ssex只允许取'男'或'女' */</span></span><br><span class="line">      Sage <span class="type">SMALLINT</span>,</span><br><span class="line">      Sdept <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></li>
</ul>
</li>
<li><p>属性上的约束条件检查和违约处理</p>
<ul>
<li>插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足</li>
<li>不满足则拒绝执行</li>
</ul>
</li>
</ul>
<h3 id="5-3-2-元组上的约束条件"><a href="#5-3-2-元组上的约束条件" class="headerlink" title="5.3.2 元组上的约束条件"></a><a href="#532-%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"></a>5.3.2 元组上的约束条件</h3><ul>
<li>在CREATE TABLE时可以用<code>CHECK</code>短语定义元组上的约束条件，即元组级的限制; 元组级的限制可以设置不同属性之间的取值的相互约束条件</li>
</ul>
<table><tbody><tr><td class="code"><pre><span class="line"># 当学生的性别是男时，其名字不能以Ms.打头。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    ( Sno    <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">      Sname  <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      Ssex   <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">      Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">      Sdept  <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (Sno),</span><br><span class="line">      <span class="keyword">CHECK</span> (Ssex<span class="operator">=</span><span class="string">'女'</span> <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">'Ms.%'</span>) <span class="comment">/*定义了元组中Sname和Ssex两个属性值之间的约束条件*/</span></span><br><span class="line">    );</span><br></pre></td></tr></tbody></table>

<ul>
<li>元组上的约束条件检查和违约处理<ul>
<li>插入元组或修改属性的值时，关系数据库管理系统检查元组上的约束条件是否被满足</li>
<li>不满足则拒绝执行</li>
</ul>
</li>
</ul>
<h2 id="5-4-完整性约束命名字句"><a href="#5-4-完整性约束命名字句" class="headerlink" title="5.4 完整性约束命名字句"></a><a href="#54-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%91%BD%E5%90%8D%E5%AD%97%E5%8F%A5"></a>5.4 完整性约束命名字句</h2><ul>
<li><p>完整性约束命名子句</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束条件名<span class="operator">&gt;</span> <span class="operator">&lt;</span>完整性约束条件<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table>

<p>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</p>
<table><tbody><tr><td class="code"><pre><span class="line"># 建立学生登记表Student，要求学号在<span class="number">90000</span><span class="operator">~</span><span class="number">99999</span>之间，姓名不能取空值，年龄小于<span class="number">30</span>，性别只能是“男”或“女”。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">     ( Sno  <span class="type">NUMERIC</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">90000</span> <span class="keyword">AND</span> <span class="number">99999</span>),</span><br><span class="line">       Sname  <span class="type">CHAR</span>(<span class="number">20</span>)  </span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">       Sage  <span class="type">NUMERIC</span>(<span class="number">3</span>)</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;</span> <span class="number">30</span>),</span><br><span class="line">       Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> ( ‘男’,<span class="string">'女'</span>)),</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">     );</span><br></pre></td></tr></tbody></table>
</li>
<li><p>修改表中的完整性限制：<code>ALTER TABLE</code>语句</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C4;</span><br></pre></td></tr></tbody></table></li>
</ul>
<h2 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a><a href="#56-%E6%96%AD%E8%A8%80"></a>5.6 断言</h2><ul>
<li>SQL中，可以使用<code>CREATE ASSERTION</code>语句，通过声明性断言来指定更具一般性的约束。</li>
<li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li>
<li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li>
</ul>
<h4 id="1-创建断言"><a href="#1-创建断言" class="headerlink" title="1. 创建断言"></a><a href="#1-%E5%88%9B%E5%BB%BA%E6%96%AD%E8%A8%80"></a>1. 创建断言</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span></span><br><span class="line"># <span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span>中的约束条件与<span class="keyword">WHERE</span>子句的条件表达式类似</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"># 限制数据库课程最多<span class="number">60</span>名学生选修</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="number">60</span> <span class="operator">&gt;=</span> ( <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">			   <span class="keyword">from</span> Course,SC</span><br><span class="line">			   <span class="keyword">Where</span> SC.Cno<span class="operator">=</span>Course.Cno <span class="keyword">and</span> Course.Cname <span class="operator">=</span><span class="string">'数据库'</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table>

<h4 id="2-删除断言"><a href="#2-删除断言" class="headerlink" title="2. 删除断言"></a><a href="#2-%E5%88%A0%E9%99%A4%E6%96%AD%E8%A8%80"></a>2. 删除断言</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span>;</span><br></pre></td></tr></tbody></table>

<h2 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a><a href="#57-%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7 触发器</h2><h3 id="5-7-1-定义触发器"><a href="#5-7-1-定义触发器" class="headerlink" title="5.7.1 定义触发器"></a><a href="#571-%E5%AE%9A%E4%B9%89%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7.1 定义触发器</h3><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span>  </span><br><span class="line">{BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span><span class="operator">&lt;</span>变量<span class="operator">&gt;</span></span><br><span class="line">FOR EACH  {ROW | STATEMENT}</span><br><span class="line">[<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>]<span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table>

<h3 id="5-7-2-激活触发器"><a href="#5-7-2-激活触发器" class="headerlink" title="5.7.2 激活触发器"></a><a href="#572-%E6%BF%80%E6%B4%BB%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7.2 激活触发器</h3><ul>
<li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li>
<li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序:<br>（1） 执行该表上的BEFORE触发器;<br>（2） 激活触发器的SQL语句;<br>（3） 执行该表上的AFTER触发器。</li>
</ul>
<h3 id="5-7-3-删除触发器"><a href="#5-7-3-删除触发器" class="headerlink" title="5.7.3 删除触发器"></a><a href="#573-%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7.3 删除触发器</h3><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></tbody></table>

<ul>
<li>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</li>
</ul>
<h1 id="Chapter-6-关系数据理论"><a href="#Chapter-6-关系数据理论" class="headerlink" title="Chapter 6 关系数据理论"></a><a href="#chapter-6-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"></a>Chapter 6 关系数据理论</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a><a href="#61-%E6%A6%82%E8%BF%B0"></a>6.1 概述</h2><ul>
<li><p>关系模式由五部分组成，是一个五元组：R(U,D,DOM,F)R(U, D, DOM, F)R(U,D,DOM,F)</p>
<ul>
<li>关系名R是符号化的元组语义</li>
<li>U为一组属性</li>
<li>D为属性组U中的属性所来自的域</li>
<li>DOM为属性到域的映射</li>
<li>F为属性组U上的一组数据依赖</li>
</ul>
</li>
<li><p>数据依赖</p>
<ul>
<li>是一个关系内部 属性与属性之间的一种约束关系<ul>
<li>通过属性间值的相等与否体现出来的数据间相互联系</li>
</ul>
</li>
<li>是现实世界属性间相互联系的抽象</li>
<li>是数据内在的性质, 是语义的体现</li>
<li>数据依赖的主要类型<ul>
<li>函数依赖（Functional Dependency，简记为FD）</li>
<li>多值依赖（Multi-Valued Dependency，简记为MVD）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a><a href="#62-%E8%A7%84%E8%8C%83%E5%8C%96"></a>6.2 规范化</h2><h3 id="6-2-1-函数依赖"><a href="#6-2-1-函数依赖" class="headerlink" title="6.2.1 函数依赖"></a><a href="#621-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>6.2.1 函数依赖</h3><h4 id="1-函数依赖"><a href="#1-函数依赖" class="headerlink" title="1. 函数依赖"></a><a href="#1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>1. 函数依赖</h4><ul>
<li><p>一个关系中，两组属性之间的 取值约束</p>
</li>
<li><p>定义：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称“X函数确定Y”或“Y函数依赖于X”，记作X→YX \rightarrow YX→Y。</p>
</li>
<li><p>若X→YX→YX→Y，并且Y→XY \rightarrow XY→X, 则记为X←→YX \leftarrow \rightarrow YX←→Y。</p>
</li>
<li><p>X：决定因素； Y：依赖因素</p>
</li>
</ul>
<h4 id="2-平凡函数依赖与非平凡函数依赖"><a href="#2-平凡函数依赖与非平凡函数依赖" class="headerlink" title="2. 平凡函数依赖与非平凡函数依赖"></a><a href="#2-%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%9D%9E%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>2. 平凡函数依赖与非平凡函数依赖</h4><ul>
<li>非平凡的函数依赖：X→YX \rightarrow YX→Y，但Y⊊XY\subsetneq XY⊊X。</li>
<li>平凡的函数依赖：X→YX \rightarrow YX→Y，但Y⊆XY \subseteq XY⊆X。(任一R必成立)</li>
</ul>
<h4 id="3-完全函数依赖与部分函数依赖"><a href="#3-完全函数依赖与部分函数依赖" class="headerlink" title="3. 完全函数依赖与部分函数依赖"></a><a href="#3-%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>3. 完全函数依赖与部分函数依赖</h4><ul>
<li><strong>完全函数依赖</strong>：X→YX \rightarrow YX→Y，∀X′⊂X\forall X’ \subset X∀X′⊂X，X’↛YX’ \nrightarrow YX’↛Y，则X→FYX \xrightarrow{F} YXF​Y。</li>
<li><strong>部分函数依赖</strong>: X→YX \rightarrow YX→Y，∃X′⊂X\exists X’ \subset X∃X′⊂X，X′↛YX’ \nrightarrow YX′↛Y，则X→PYX \xrightarrow{P} YXP​Y。</li>
</ul>
<h4 id="4-传递函数依赖"><a href="#4-传递函数依赖" class="headerlink" title="4. 传递函数依赖"></a><a href="#4-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>4. 传递函数依赖</h4><ul>
<li>在R(U)中，如果X→Y(Y⊊X)X \rightarrow Y(Y \subsetneq X)X→Y(Y⊊X)，Y↛XY \nrightarrow XY↛X，Y→ZY→ZY→Z，Z⊊YZ \subsetneq YZ⊊Y, 则称Z对X<strong>传递函数依赖</strong>(transitive functional dependency)。记为：X→传递ZX \xrightarrow{传递} ZX传递​Z。</li>
<li>注: 如果Y→XY \rightarrow XY→X, 即X←→YX \leftarrow \rightarrow YX←→Y，则Z直接依赖于X，而不是传递函数依赖。</li>
</ul>
<h3 id="6-2-2-码"><a href="#6-2-2-码" class="headerlink" title="6.2.2 码"></a><a href="#622-%E7%A0%81"></a>6.2.2 码</h3><ul>
<li>设K为R&lt;U,F&gt;中的属性或属性组合。若K→FUK \xrightarrow{F} UKF​U，则K称为R的一个<strong>候选码</strong>(Candidate Key)。</li>
<li>如果U部分函数依赖于K，即K→PUK \xrightarrow{P} UKP​U,则K称为<strong>超码</strong>(Surpkey）。候选码是最小的超码，即K的任意一个真子集都不是候选码。</li>
<li>若关系模式R有多个候选码，则选定其中的一个做为<strong>主码</strong>(Primary key)</li>
<li>包含在任何一个候选码中的属性，称为<strong>主属性</strong>（Prime attribute）,不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</li>
<li>全码：整个属性组是码，称为<strong>全码</strong>（All-key）</li>
<li>R中属性或属性组X并非R的码，但是另一个关系模式的码，则称X是R的<strong>外码</strong>。</li>
</ul>
<h3 id="6-2-3-范式"><a href="#6-2-3-范式" class="headerlink" title="6.2.3 范式"></a><a href="#623-%E8%8C%83%E5%BC%8F"></a>6.2.3 范式</h3><ul>
<li><p>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF</p>
</li>
<li><p>规范化（normalization）: 一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合</p>
</li>
<li><p><strong>1NF</strong>: 属性不可再分</p>
</li>
<li><p><strong>2NF</strong>：满足1NF，每个非主属性都完全依赖于关键字</p>
</li>
<li><p><strong>3NF</strong>：满足2NF，每个非主属性都不传递依赖于关键字</p>
</li>
<li><p><strong>BCNF</strong>: 满足1NF，若X→YX \rightarrow YX→Y,则X必含有该模式的关键字</p>
<ul>
<li>BCNF-&gt;3NF</li>
</ul>
</li>
</ul>
<h3 id="6-2-7-多值依赖"><a href="#6-2-7-多值依赖" class="headerlink" title="6.2.7 多值依赖"></a><a href="#627-%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"></a>6.2.7 多值依赖</h3><ul>
<li>多值依赖：X→→YX \rightarrow \rightarrow YX→→Y<ul>
<li>定义：对X的一个取值，存在一组Y与其对应；Y的取值与U-X-Y不相关</li>
<li>非平凡多值依赖： U-X-Y不为空集</li>
<li>平凡多值依赖：反之</li>
</ul>
</li>
<li>4NF<ul>
<li>定义：若X→→YX \rightarrow \rightarrow YX→→Y是非平凡多值依赖，则X必有关键字</li>
<li>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际上是函数依赖。</li>
<li>如果一个关系模式是4NF， 则必为BCNF</li>
</ul>
</li>
</ul>
<h3 id="6-2-8-总结"><a href="#6-2-8-总结" class="headerlink" title="6.2.8 总结"></a><a href="#628-%E6%80%BB%E7%BB%93"></a>6.2.8 总结</h3><ul>
<li><p>关系模式规范化过程：</p>
<p><img src="https://i.loli.net/2021/09/06/j87KIQ1NnRaZgYy.png" alt="image-20210906204151632"></p>
</li>
<li><p>并不是规范化程度越高的关系模式越好</p>
</li>
</ul>
<h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a><a href="#63-%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"></a>6.3 数据依赖的公理系统</h2><p>Armstrong公理系统</p>
<ul>
<li>基本规则：<ul>
<li>自反律： 若Y⊆X⊆UY \subseteq X \subseteq UY⊆X⊆U, 则X→YX \rightarrow YX→Y为F所蕴含</li>
<li>增广律： 若X→YX \rightarrow YX→Y为F所蕴涵，且Z⊆UZ \subseteq UZ⊆U，则XZ→YZXZ \rightarrow YZXZ→YZ 为F所蕴涵</li>
<li>传递律： 若X→YX \rightarrow YX→Y及Y→ZY \rightarrow ZY→Z为F所蕴涵，则X→ZX \rightarrow ZX→Z为F所蕴涵。</li>
</ul>
</li>
<li>推理规则：<ul>
<li>合并规则（union rule）：由X→YX \rightarrow YX→Y，X→ZX \rightarrow ZX→Z，有X→YZX \rightarrow YZX→YZ。</li>
<li>伪传递规则（pseudo transitivity rule）：由X→YX \rightarrow YX→Y，WY→ZWY \rightarrow ZWY→Z，有XW→ZX W\rightarrow ZXW→Z</li>
<li>分解规则（decomposition rule）：由X→YX \rightarrow YX→Y及Z⊆YZ \subseteq YZ⊆Y，有X→ZX \rightarrow ZX→Z。</li>
</ul>
</li>
</ul>
<h1 id="Chapter-7-数据库设计"><a href="#Chapter-7-数据库设计" class="headerlink" title="Chapter 7 数据库设计"></a><a href="#chapter-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"></a>Chapter 7 数据库设计</h1><h2 id="7-1-需求分析"><a href="#7-1-需求分析" class="headerlink" title="7.1 需求分析"></a><a href="#71-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"></a>7.1 需求分析</h2><ul>
<li>数据字典<ul>
<li>内容：数据项，数据结构，数据流，数据存储，处理过程</li>
</ul>
</li>
</ul>
<h2 id="7-2-概念结构设计"><a href="#7-2-概念结构设计" class="headerlink" title="7.2 概念结构设计"></a><a href="#72-%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>7.2 概念结构设计</h2><ul>
<li>将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程</li>
<li>描述概念模型的工具：E-R模型<ul>
<li>实体之间的联系：<ul>
<li>两个实体型之间的联系：一对一联系（1∶1），一对多联系（1∶n），多对多联系（m∶n）</li>
<li>两个以上的实体型之间的联系：同上。</li>
<li>单个实体型内的联系：同上。</li>
</ul>
</li>
<li>E-R图：<ul>
<li>实体型：用矩形表示，矩形框内写明实体名。</li>
<li>属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来</li>
<li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1∶1，1∶n或m∶n）</li>
<li>联系可以具有属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-3-逻辑结构设计"><a href="#7-3-逻辑结构设计" class="headerlink" title="7.3 逻辑结构设计"></a><a href="#73-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>7.3 逻辑结构设计</h2><ul>
<li><p>把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p>
</li>
<li><p>E-R图向关系模型的转换。转换原则：</p>
<ul>
<li>一个实体型转换为一个关系模式。<ul>
<li>关系的属性：实体的属性</li>
<li>关系的码：实体的码</li>
</ul>
</li>
<li>实体型间的联系：<ul>
<li>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li>
<li>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li>
<li>一个m:n联系转换为一个关系模式</li>
<li>三个或三个以上实体间的一个多元联系转换为一个关系模式</li>
<li>具有相同码的关系模式可合并</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-4-物理结构设计"><a href="#7-4-物理结构设计" class="headerlink" title="7.4 物理结构设计"></a><a href="#74-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>7.4 物理结构设计</h2><h2 id="7-5-数据库实施"><a href="#7-5-数据库实施" class="headerlink" title="7.5 数据库实施"></a><a href="#75-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%96%BD"></a>7.5 数据库实施</h2><h2 id="7-6-数据库运行和维护"><a href="#7-6-数据库运行和维护" class="headerlink" title="7.6 数据库运行和维护"></a><a href="#76-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BB%B4%E6%8A%A4"></a>7.6 数据库运行和维护</h2><h1 id="Chapter-10-数据库恢复技术"><a href="#Chapter-10-数据库恢复技术" class="headerlink" title="Chapter 10 数据库恢复技术"></a><a href="#chapter-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"></a>Chapter 10 数据库恢复技术</h1><h2 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a><a href="#101-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>10.1 事务的基本概念</h2><h3 id="10-1-1-事务"><a href="#10-1-1-事务" class="headerlink" title="10.1.1 事务"></a><a href="#1011-%E4%BA%8B%E5%8A%A1"></a>10.1.1 事务</h3><ul>
<li><p>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p>
</li>
<li><p>事务 VS 程序</p>
<ul>
<li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li>
<li>一个程序通常包含多个事务</li>
</ul>
</li>
<li><p>事务是恢复和并发控制的基本单位</p>
</li>
<li><p>定义</p>
<ul>
<li><p>显式定义：</p>
<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">	<span class="keyword">SQL</span> 语句<span class="number">1</span></span><br><span class="line">	<span class="keyword">SQL</span> 语句<span class="number">2</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"># 事务正常结束   </span><br><span class="line"># 提交事务的所有操作（读<span class="operator">+</span>更新）</span><br><span class="line"># 事务中所有对数据库的更新写回到磁盘上的物理数据库中</span><br></pre></td></tr></tbody></table>

<table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">	<span class="keyword">SQL</span> 语句<span class="number">1</span></span><br><span class="line">	<span class="keyword">SQL</span> 语句<span class="number">2</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"># 事务异常终止</span><br><span class="line"># 事务运行的过程中发生了故障，不能继续执行</span><br><span class="line"># 系统将事务中对数据库的所有已完成的操作全部撤销 </span><br><span class="line"># 事务滚回到开始时的状态</span><br></pre></td></tr></tbody></table>
</li>
<li><p>隐式定义: 当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务</p>
</li>
</ul>
</li>
</ul>
<h3 id="10-1-2-事务的ACID特性"><a href="#10-1-2-事务的ACID特性" class="headerlink" title="10.1.2 事务的ACID特性"></a><a href="#1012-%E4%BA%8B%E5%8A%A1%E7%9A%84acid%E7%89%B9%E6%80%A7"></a>10.1.2 事务的ACID特性</h3><ul>
<li>原子性（Atomicity）: 事务中包括的诸操作要么都做，要么都不做</li>
<li>一致性（Consistency）: 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li>
<li>隔离性（Isolation）: 一个事务的执行不能被其他事务干扰。并发结果与某种串行执行结果相同</li>
<li>持续性（Durability）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</li>
</ul>
<h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a><a href="#103-%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB"></a>10.3 故障的种类</h2><ol>
<li>事务内部的故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒</li>
</ol>
<h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a><a href="#104-%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"></a>10.4 恢复的实现技术</h2><ul>
<li>恢复操作的基本原理：冗余</li>
<li>数据转储<ul>
<li>转储： 数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li>
<li>备用的数据文本称为后备副本(backup)或后援副本</li>
<li>转储方法：<ul>
<li>静态转储与动态转储<ul>
<li>静态转储：在系统中无运行事务时进行的转储操作；转储开始时数据库处于一致性状态；转储期间不允许对数据库的任何存取、修改活动<br>得到的一定是一个数据一致性的副本</li>
<li>动态转储：转储操作与用户事务并发进行；转储期间允许对数据库进行存取或修改</li>
</ul>
</li>
<li>海量转储与增量转储<ul>
<li>海量转储: 每次转储全部数据库</li>
<li>增量转储: 只转储上次转储后更新过的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>登记日志文件<ul>
<li>日志文件(log file)：用来记录事务对数据库的更新操作的文件</li>
<li>登记日志文件时必须遵循两条原则：<ul>
<li>登记的次序严格按并发事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-5-恢复策略"><a href="#10-5-恢复策略" class="headerlink" title="10.5 恢复策略"></a><a href="#105-%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"></a>10.5 恢复策略</h2><h3 id="10-5-1-事务故障的恢复"><a href="#10-5-1-事务故障的恢复" class="headerlink" title="10.5.1 事务故障的恢复"></a><a href="#1051-%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"></a>10.5.1 事务故障的恢复</h3><ul>
<li>事务故障：事务在运行至正常终止点前被终止</li>
<li>恢复方法<ul>
<li>由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改</li>
</ul>
</li>
<li>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</li>
<li>恢复步骤：<ul>
<li>反向扫描文件日志，查找该事务的更新操作。</li>
<li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库<ul>
<li>插入操作， “更新前的值”为空，则相当于做删除操作</li>
<li>删除操作，“更新后的值”为空，则相当于做插入操作</li>
<li>若是修改操作，则相当于用修改前值代替修改后值</li>
</ul>
</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理</li>
<li>如此处理下去，直至读到此事务的开始标记，恢复完成</li>
</ul>
</li>
</ul>
<h3 id="10-5-2-系统故障的恢复"><a href="#10-5-2-系统故障的恢复" class="headerlink" title="10.5.2 系统故障的恢复"></a><a href="#1052-%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"></a>10.5.2 系统故障的恢复</h3><ul>
<li><p>系统故障造成数据库不一致状态的原因</p>
<ul>
<li>未完成事务对数据库的更新可能已写入数据库</li>
<li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li>
</ul>
</li>
<li><p>恢复方法</p>
<ul>
<li>Undo 故障发生时未完成的事务</li>
</ul>
<ol start="2">
<li>Redo 已完成的事务</li>
</ol>
</li>
<li><p>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</p>
</li>
<li><p>恢复步骤：</p>
<ul>
<li>正向扫描日志文件<ul>
<li>重做(REDO) 队列: 在故障发生前已经提交的事务（这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录</li>
<li>撤销 (UNDO)队列:故障发生时尚未完成的事务（这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录</li>
</ul>
</li>
<li>对撤销(UNDO)队列事务进行撤销(UNDO)处理</li>
<li>对重做(REDO)队列事务进行重做(REDO)处理</li>
</ul>
</li>
</ul>
<h3 id="10-5-3-介质故障的恢复"><a href="#10-5-3-介质故障的恢复" class="headerlink" title="10.5.3 介质故障的恢复"></a><a href="#1053-%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"></a>10.5.3 介质故障的恢复</h3><ul>
<li>重装数据库</li>
<li>重做已完成的事务</li>
<li>恢复步骤：<ul>
<li>装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态</li>
<li>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务</li>
</ul>
</li>
<li>介质故障的恢复需要数据库管理员介入</li>
</ul>
<h2 id="10-6-具有检查点的恢复技术"><a href="#10-6-具有检查点的恢复技术" class="headerlink" title="10.6 具有检查点的恢复技术"></a><a href="#106-%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"></a>10.6 具有检查点的恢复技术</h2><ul>
<li>在日志文件中增加检查点记录（checkpoint）</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志</li>
<li>检查点记录的内容<ul>
<li>建立检查点时刻所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址</li>
</ul>
</li>
<li>重新开始文件的内容<ul>
<li>记录各个检查点记录在日志文件中的地址</li>
</ul>
</li>
</ul>
<h2 id="10-7-数据库镜像"><a href="#10-7-数据库镜像" class="headerlink" title="10.7 数据库镜像"></a><a href="#107-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%95%9C%E5%83%8F"></a>10.7 数据库镜像</h2><ul>
<li>数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上</li>
<li>数据库管理系统自动保证镜像数据与主数据的一致性。每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去</li>
</ul>
<h1 id="Chapter-11-并发控制"><a href="#Chapter-11-并发控制" class="headerlink" title="Chapter 11 并发控制"></a><a href="#chapter-11-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"></a>Chapter 11 并发控制</h1><h2 id="11-1-并发控制概述"><a href="#11-1-并发控制概述" class="headerlink" title="11.1 并发控制概述"></a><a href="#111-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0"></a>11.1 并发控制概述</h2><ul>
<li><p>事务是并发控制的基本单位</p>
</li>
<li><p>并发操作带来的数据不一致性</p>
<table>
<thead>
<tr>
<th>不一致现象</th>
<th>描述</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>丢失修改（Lost Update）</td>
<td>一个修改破坏另一个修改结果</td>
<td>多个事务并发修改同一个数据</td>
</tr>
<tr>
<td>不可重复读（Non-repeatable Read）</td>
<td>读到错误的数据</td>
<td>其他事务未提交的修改</td>
</tr>
<tr>
<td>读“脏”数据（Dirty Read）</td>
<td>前后两次读不一致</td>
<td>其他事务已提交的写操作</td>
</tr>
<tr>
<td>幻像读</td>
<td>一个事务中, 执行相同的查询多次, 结果不同</td>
<td>其他事务已提交的插入操作</td>
</tr>
</tbody></table>
</li>
<li><p>并发控制的主要技术</p>
<ul>
<li>封锁(Locking)</li>
<li>时间戳(Timestamp)</li>
<li>乐观控制法</li>
<li>多版本并发控制(MVCC)</li>
</ul>
</li>
</ul>
<h2 id="11-2-封锁"><a href="#11-2-封锁" class="headerlink" title="11.2 封锁"></a><a href="#112-%E5%B0%81%E9%94%81"></a>11.2 封锁</h2><ul>
<li><p>基本封锁类型</p>
<ul>
<li>排它锁&#x2F;写锁（Exclusive Locks，简记为X锁）<ul>
<li>自己可以读写, 其他事务啥也不行</li>
<li>一个对象同时只能上一次, 维持到事务结束</li>
</ul>
</li>
<li>共享锁&#x2F;读锁（Share Locks，简记为S锁）<ul>
<li>所有事务只读</li>
<li>可以与其他S锁并存</li>
</ul>
</li>
</ul>
</li>
<li><p>锁的相容矩阵：</p>
<table>
<thead>
<tr>
<th>T2T_2T2​\ T1T_1T1​</th>
<th>X</th>
<th>S</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>S</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="11-3-封锁协议"><a href="#11-3-封锁协议" class="headerlink" title="11.3 封锁协议"></a><a href="#113-%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"></a>11.3 封锁协议</h2><ul>
<li><p>封锁协议（Locking Protocol）：在运用X锁和S锁对数据对象加锁时，约定的一些规则</p>
</li>
<li><p>三级封锁协议：</p>
<ul>
<li>一级封锁协议：写之前加X锁, 事务结束释放</li>
<li>二级封锁协议：一级 + 读前加S锁, 读完释放</li>
<li>三级封锁协议：一级 + 读前加S锁, 事务结束释放</li>
</ul>
</li>
<li><p>三级封锁协议的防止的不一致</p>
<ul>
<li><p>一级：丢失修改</p>
</li>
<li><p>二级：丢失修改，读脏</p>
</li>
<li><p>三级：丢失修改，读脏，不可重复读</p>
<table>
<thead>
<tr>
<th></th>
<th>X锁</th>
<th></th>
<th>S锁</th>
<th></th>
<th>一致性保证</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>操作结束释放</td>
<td>事务结束释放</td>
<td>操作结束释放</td>
<td>事务结束释放</td>
<td>不丢失修改</td>
<td>不读脏</td>
<td>可重复读</td>
</tr>
<tr>
<td>一级封锁协议</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>二级封锁协议</td>
<td></td>
<td>✔</td>
<td>✔</td>
<td></td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>三级封锁协议</td>
<td></td>
<td>✔</td>
<td></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="11-4-活锁和死锁"><a href="#11-4-活锁和死锁" class="headerlink" title="11.4 活锁和死锁"></a><a href="#114-%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81"></a>11.4 活锁和死锁</h2><p>封锁技术可以有效地解决并行操作的一致性问题，但也带来一些新的问题</p>
<ul>
<li>活锁:<ul>
<li>有部分事务长期等待锁, 其他事务可以继续运行</li>
<li>避免：FCFS</li>
</ul>
</li>
<li>死锁:<ul>
<li>每个事务持有部分锁, 循环等待</li>
<li>解决方法：<ul>
<li>死锁的预防：破坏产生死锁的条件<ul>
<li>一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行（问题：降低了系统并发度；难于事先精确确定封锁对象）</li>
<li>顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁（问题：维护成本高，难以实现）</li>
</ul>
</li>
<li>死锁的诊断和解除<ul>
<li>诊断：<ul>
<li>超时法</li>
<li>等待图法</li>
</ul>
</li>
<li>解除：<ul>
<li>选择一个处理死锁代价最小的事务，将其撤消</li>
<li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11-5-并发调度的可串行性"><a href="#11-5-并发调度的可串行性" class="headerlink" title="11.5 并发调度的可串行性"></a><a href="#115-%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7"></a>11.5 并发调度的可串行性</h2><h3 id="11-5-1-可串行化调度"><a href="#11-5-1-可串行化调度" class="headerlink" title="11.5.1 可串行化调度"></a><a href="#1151-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"></a>11.5.1 可串行化调度</h3><ul>
<li>可串行化(Serializable)调度<br>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li>
<li>可串行性(Serializability)<br>是并发事务正确调度的准则<br>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li>
</ul>
<h3 id="11-5-2-冲突可串行化调度"><a href="#11-5-2-冲突可串行化调度" class="headerlink" title="11.5.2 冲突可串行化调度"></a><a href="#1152-%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"></a>11.5.2 冲突可串行化调度</h3><ul>
<li><p>冲突操作：不同的事务对同一数据的 读写操作 和 写写操作：</p>
<table><tbody><tr><td class="code"><pre><span class="line">Ri(x)与Wj(x)	       /*事务Ti读x，Tj写x，其中i≠j*/</span><br><span class="line">Wi(x)与Wj(x)        /*事务Ti写x，Tj写x，其中i≠j*/</span><br></pre></td></tr></tbody></table>
</li>
<li><p>不能交换（Swap）的动作:</p>
<ul>
<li>同一事务的两个操作</li>
<li>不同事务的冲突操作</li>
</ul>
</li>
<li><p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化的调度</strong></p>
</li>
</ul>
<h2 id="11-6-两段锁协议"><a href="#11-6-两段锁协议" class="headerlink" title="11.6 两段锁协议"></a><a href="#116-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"></a>11.6 两段锁协议</h2><ul>
<li>两阶段封锁协议<ul>
<li>一阶段: 申请整个过程需要的锁</li>
<li>二阶段: 释放所有锁, 不能再申请</li>
</ul>
</li>
<li>两阶段封锁协议与冲突可串行化的关系: 两阶段任意合法调度S都是冲突可串行化的</li>
</ul>
<h2 id="11-7-封锁的粒度"><a href="#11-7-封锁的粒度" class="headerlink" title="11.7 封锁的粒度"></a><a href="#117-%E5%B0%81%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"></a>11.7 封锁的粒度</h2><p>封锁粒度&#x2F;并发度&#x2F;并发控制实现开销 之间的关系</p>
<ul>
<li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li>
<li>封锁的粒度越小，并发度较高，但系统开销也就越大</li>
</ul>
<h3 id="11-7-1-多粒度封锁"><a href="#11-7-1-多粒度封锁" class="headerlink" title="11.7.1 多粒度封锁"></a><a href="#1171-%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81"></a>11.7.1 多粒度封锁</h3><ul>
<li>多粒度封锁: 同时支持多种封锁粒度供事务选择</li>
<li>多粒度树: 按照封锁粒度的大小构造出一棵”多粒度树”，以树中的每个结点作为封锁对象，可以构成一个”多粒度封锁协议”</li>
</ul>
<h3 id="11-7-2-意向锁"><a href="#11-7-2-意向锁" class="headerlink" title="11.7.2 意向锁"></a><a href="#1172-%E6%84%8F%E5%90%91%E9%94%81"></a>11.7.2 意向锁</h3><ul>
<li><p>意向锁: 节点加意向锁, 其下层节点正被加锁(必须上层先加意向锁, 才能给下层加锁)</p>
<ul>
<li>IS: 下层打算加S</li>
<li>IX: 下层打算加X</li>
<li>SIX: 当前加S, 下层加X</li>
</ul>
</li>
<li><p>意向锁锁相容矩阵:</p>
<table>
<thead>
<tr>
<th>已经有的锁</th>
<th>S</th>
<th>X</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>已经持有S</td>
<td>✔</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
<td>S加了, 当前及其下层没有X</td>
</tr>
<tr>
<td>已经持有X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X排他, 加了别的都没有</td>
</tr>
<tr>
<td>已经持有IS</td>
<td>✔</td>
<td></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>IS加了, 当前没X</td>
</tr>
<tr>
<td>已经持有IX</td>
<td></td>
<td></td>
<td>✔</td>
<td>✔</td>
<td></td>
<td>IX加了, 当前没S没X</td>
</tr>
<tr>
<td>已经持有SIX</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
<td>SIX加了, 相当于同时S和IX</td>
</tr>
</tbody></table>
</li>
<li><p>意向锁锁申请算法，意向锁锁释放算法: 对任何一个节点加锁, 必须先对其父节点加意向锁(也就是从根开始加)</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Krab</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/05/DB/">http://example.com/2021/09/05/DB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DB/">DB</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/04/18/JavaWeb/"><i class="fa fa-chevron-left">  </i><span>JavaWeb</span></a></div><div class="next-post pull-right"><a href="/2021/07/08/SSP/"><span>基于卷积神经网络的孤立词语音识别系统</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2024 By Krab</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>