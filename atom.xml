<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Krab&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-18T01:02:35.501Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Krab</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaWeb</title>
    <link href="http://example.com/2024/04/18/JavaWeb/"/>
    <id>http://example.com/2024/04/18/JavaWeb/</id>
    <published>2024-04-17T16:00:00.000Z</published>
    <updated>2024-04-18T01:02:35.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="P1-JSP环境搭建及入门"><a href="#P1-JSP环境搭建及入门" class="headerlink" title="P1 JSP环境搭建及入门"></a>P1 JSP环境搭建及入门</h1><ul><li><p>静态&#x2F;动态</p><p>  动态网页需要使用到 服务端脚本语言JSP</p></li><li><p>架构</p><p>  CS: Client Server</p><p>  BS: Broswer Server</p><p>  客户端可以通过浏览器直接访问服务端</p></li><li><p>tomcat目录：</p><ul><li>bin: 可执行文件</li><li>conf: 配置文件</li><li>lib: tomcat依赖的jar文件</li><li>log</li><li>temp</li><li>webapps：可执行的项目（将我们开发的项目放入该文件）</li><li>work：存放由jsp翻译成的java，以及编辑成的class文件 【jsp→java→work】</li></ul></li><li><p>配置tomcat</p><ul><li>配置jdk</li><li>配置CATALINA_HOME</li></ul><p>  双击bin&#x2F;startup.bat启动tomcat</p><p>  常见错误：与其他服务的端口号冲突</p><p>  默认端口号8080，建议修改为8888(conf&#x2F;server.xml)  </p></li><li><p>访问tomcat</p><ul><li>localhost:8888</li><li>常见状态码：200：一切正常； 404：资源不存在； 403：权限不足； 300&#x2F;301： 页面重定向； 500：服务器内部错误（代码有误）</li></ul></li><li><p>Jsp</p><ul><li>jsp: 在html中嵌套的java代码</li><li>在WEB-INF&#x2F;web.xml中设置 默认的 初始页面</li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="P2-虚拟路径和虚拟主机"><a href="#P2-虚拟路径和虚拟主机" class="headerlink" title="P2 虚拟路径和虚拟主机"></a>P2 虚拟路径和虚拟主机</h1><ul><li>虚拟路径<ul><li>将web项目配置到webapps以外的目录</li><li>方式一： conf&#x2F;server.xml中配置， host标签中(需要重新启动)</li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\Mydoc\JspProject&quot;</span>, <span class="attr">path</span>=<span class="string">&quot;/JspProject&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方式二：在conf&#x2F;Catalina&#x2F;localhost中新建“项目名.xml”新增上面的一行代码</li></ul></li><li>虚拟主机<ul><li>通过<a href="http://www.test.com访问本机/">www.test.com访问本机</a></li></ul><ol><li><p>conf&#x2F;server.xml</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;www.test.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">&quot;D:\Mydoc\JsaProject&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\Mydoc\JsaProject&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>C:\Windows\System32\drives\etc\host 增加 127.0.0.1    <a href="http://www.test.com/">www.test.com</a></p></li></ol><ul><li>流程：<ul><li><a href="http://www.test.com/">www.test.com</a> → host找映射关系 → server.xml找Engine的defaultHost → 通过“&#x2F;”映射到”D:\Mydoc\JsaProject”</li></ul></li></ul></li><li>JSP执行流程<ul><li>第一次访问：将jsp翻译成java,再将java编译成class文件 （速度慢）<ul><li>jsp - java(Servelet文件) - class</li><li>D:\ProgramFiles\apache-tomcat-8.5.99\work\Catalina\localhost\JspProject\org\apache\jsp</li></ul></li><li>第二次访问：直接访问class文件</li><li>如果服务端代码修改，再访问时将会重新翻译编译</li><li>Jsp和Servelet可以相互转换</li></ul></li></ul><h1 id="P4-使用eclipse开发"><a href="#P4-使用eclipse开发" class="headerlink" title="P4 使用eclipse开发"></a>P4 使用eclipse开发</h1><ul><li><p>在eclipse中创建的web项目：</p><ul><li>浏览器可以直接访问WebContent&#x2F;（src&#x2F;main&#x2F;wenapp）中的文件</li><li>但是WEB-INF中的文件无法通过客户端（浏览器）直接访问，只能通过 请求转发 来访问</li></ul></li><li><p>配置tomcat运行时环境</p></li><li><p>部署 tomcat</p><ul><li>在servers面板 新建一个tomcat示例， 再在该实例中 部署项目（右键→Add）， 之后运行</li></ul></li><li><p>统一字符集编码</p><ul><li>编码分类：<ul><li>设置jsp文件的编码（jsp文件中的pageEncoding属性）:  jsp → java</li><li>设置浏览器读取jsp文件的编码（jsp文件中meta charset属性）</li><li>文本编码：<ul><li>将整个eclipse中的文件 统一设置 （window→referecr→jsp）*</li><li>设置某一个项目</li><li>设置某一个文件</li></ul></li></ul></li></ul></li><li><p>JSP的页面元素:HTML, JAVA代码（scriptlet脚本）， 注释， 指令</p><ul><li><p>脚本Scriptlet</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">全局变量、定义方法</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">局部变量、<span class="title class_">Java</span>代码</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%=输出表达式 %&gt;</span><br></pre></td></tr></table></figure></li></ul><p>  ps: 一般修改web.xml、配置文件、Java需要重启tomcat服务； 但修改Jsp&#x2F;html&#x2F;css&#x2F;js不用</p><p>  out.println不能回车，回车要写”<br/>”， out.println和输出表达式可以直接解析html代码  </p></li><li><p>page指令</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.Date&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><pre><code>  page指定的属性：</code></pre><ul><li><p>language：jsp页面使用的脚本语言</p></li><li><p>import： 导入类</p></li><li><p>pageEncoding： jsp文件自身编码 jsp→java</p></li><li><p>contentType：浏览器解析jsp的编码</p></li><li><p>注释</p><ul><li>html &lt;!—注释—!&gt;</li><li>java：&#x2F;&#x2F;     &#x2F;<em>注释</em>&#x2F;</li><li>jsp： &lt;%—注释—&gt;</li></ul></li><li><p>九大JSP内置对象（自带的，不需要new也能使用）</p><ul><li>out: 输出对象，向客户端输出内容</li><li>request： 请求对象， 存储“客户端向服务端发送的请求信息”<ul><li>常见方法<ul><li>String getParameter(String name)：根据请求的字段名, 返回字段值value</li><li>String[] getParameterValues(String name)：根据请求的字段名，返回多个字段值value（checkbox）</li><li>void setCharacterEncoding(”编码格式utf-8”)： 设置请求编码 （tomcat7以前默认iso-8859-1, 8以后utf-8）</li><li>getRequestDispatcher(”b.jsp”).forward(requset， response): <strong>请求转发</strong>的方式跳转页面A→B</li><li>getServerContext(): 获取项目的ServerContext对象</li></ul></li><li>示例：register.jsp, show.jsp</li></ul></li><li>response： 响应信息<ul><li>常见方法：<ul><li>void addCookie(Cookie cookie); 服务端像客户端增加cookie对象</li><li>void sendRedirect(String location) throws IOException; 页面跳转的一种方式 ，<strong>重定向</strong></li><li>void setContentType(String type): 设置服务端响应的编码</li></ul></li><li>示例：login.jsp, check.jsp, success.jsp</li></ul></li><li>pageContent</li><li>session(服务端)<ul><li><p>Cookie(客户端， 不是内置对象)： Cookie是由服务端生成的，再发给客户端保存。</p><ul><li>相当于 本地缓存 的作用</li><li>作用: 提高访问服务端的效率， 但是安全性较差</li><li>key &#x3D; value</li><li>javax.servlet.http.Cookie<ul><li>public Cookie(String key, String name);</li><li>String getName();</li><li>String getValue();</li><li>String setMaxAge(int expiry); 设置最大有效期（秒）</li></ul></li><li>服务端准备给客户端：<strong>response</strong>.addCookie(Cookie cookie) → 页面跳转 → 客户端获取cookie： <strong>request</strong>.getCookie<strong>s</strong>();<ul><li>自动产生一个name为JSESSIONID的cookie</li></ul></li></ul></li><li><p>session：会话</p><ul><li><p>客户端<strong>第一次</strong>请求服务端时，服务端会产生一个session信息（用于保存该客户的信息）；并且每个session对象都会有一个sessionId(用于区分其他session)；服务端会产生一个cookie，并且该cookie的key&#x3D;JSEESIONID, value&#x3D;服务端sessionid的值；然后，服务端在响应客户端的同时，将该cookie发送给客户端，至此，客户端就有了一个cookie（JSESSIONID）。因此客户端的cookie和服务端的session一一对应。</p><p>  <strong>第二&#x2F;n次请求</strong>服务端时：服务端会先用客户端cookie中的JSESSIONID去服务端的SESSION中匹配sessionid。</p></li><li><p>总结：</p><ul><li>session存储在服务器</li><li>session在同一个用户（客户）请求时共享</li><li>实现机制：第一次客户请求时，产生一个sessionid并复制给cookie的jsessionid然后发给客户端。</li></ul></li><li><p>方法:</p><ul><li>String getId(): 获取sessionid</li><li>boolean isNew(): 判断是否是新用户（第一次访问）</li><li>void invalidate(): 使session失效（退出登录、注销）</li><li>setAttribute()</li><li>getSttribute()</li><li>void setMaxInactiveInterval（秒）：设置最大有效非活动时间</li><li>void getMaxInactiveInterval()</li><li>示例</li></ul></li></ul></li><li><p>cookie vs session</p><table><thead><tr><th></th><th>session</th><th>cookie</th></tr></thead><tbody><tr><td>保存位置</td><td>服务端</td><td>客户端</td></tr><tr><td>安全性</td><td>较安全</td><td>不安全</td></tr><tr><td>保存的内容</td><td>(key&#x3D;String, value&#x3D;Object)</td><td>(String, String)</td></tr></tbody></table></li><li><p>客户端在第一次请求服务端时，如果服务端发现此请求没有JSESSIONID，则会创建一个name&#x3D;JESESSIONID的cookie，并返回给客户端</p></li></ul></li><li>application 全局对象<ul><li>String getContextPath() 虚拟路径</li><li>String getRealPath(String ) 虚拟路径相对的绝对路径</li></ul></li><li>config 配置对象（服务器配置信息）</li><li>page 当前jsp页面对象（相当于java中的this）</li><li>exception 异常对象</li></ul></li><li><p>统一请求的编码 request</p><ul><li>GET方式：如果出现乱码，解决：<ul><li>统一每一个变量的编码 new String(旧编码， 新编码)； 例如：name &#x3D; new String(name.getBytes(“iso-8859-1”), “utf-8”);</li><li>修改server.xml一次性的更改tomcat默认get提交方式的编码(utf-8)</li><li>method&#x3D;”get”和 地址栏、超链接<a href=”xx”>请求方式 默认都属于get提交方式</li></ul></li><li>POST</li><li>get vs post<ul><li>get在地址栏显示请求信息（但地址栏容量有限4-5kb）； post不显示</li><li>文件上传操作，必须是post</li><li>推荐使用post</li></ul></li></ul></li><li><p>请求转发 vs 重定向</p><table><thead><tr><th></th><th>请求转发</th><th>重定向</th></tr></thead><tbody><tr><td>地址栏是否改变</td><td>不变（check.jsp）</td><td>变(success.jsp)</td></tr><tr><td>是否保留第一次请求时候的数据</td><td>保留</td><td>不保留</td></tr><tr><td>请求的次数</td><td>1</td><td>2</td></tr><tr><td>跳转发生的位置</td><td>服务端</td><td>客户端发出的第二次跳转</td></tr></tbody></table><p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled.png" alt="Untitled"></p><p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%201.png" alt="Untitled"></p></li><li><p>四种范围对象(小→大)</p><ul><li>pageContext  JSP页面容器   当前页面有效（页面跳转后无效）</li><li>request         请求对象        同一次请求有效； 其他请求无效（请求转发后有效，重定向后无效）</li><li>session         会话对象        同一次会话有效（关闭&#x2F;切换浏览器后无效； 从登录→退出都有效）</li><li>application   全局对象        全局有效，整个项目运行期间都有效（切换浏览器仍然有效； 关闭服务，其他项目无效）</li></ul><p>  → 多个项目共享，重启后仍然有效：JNDI</p><p>  以上四个方法共有的方法：</p><ul><li>Object getAttribute(String name) 根据属性名，或者属性值</li><li>Object setAttribute(String name, Object obj)</li><li>Object setAttribute(”a”, “b”)</li><li>void removeAttribute(String name)</li></ul><p>  以上的4个范围对象，通过setAttribute赋值，getAttribute取值</p><p>  以上的4个范围对象，尽量使用范围最小的，对象的范围越大，造成的性能损耗越大</p></li></ul><h1 id="P13-JDBC-Java-DataBase-Connectivity"><a href="#P13-JDBC-Java-DataBase-Connectivity" class="headerlink" title="P13 JDBC: Java DataBase Connectivity"></a>P13 JDBC: Java DataBase Connectivity</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%202.png" alt="Untitled"></p><p><a href="https://www.notion.so/">https://www.notion.so</a></p><ul><li><p>JSBC: Java DataBase Connectivity可以为多种关系型数据库提供统一的访问方式，用Java来操作数据</p></li><li><p>JDBC API主要功能。主要是通过以下的类&#x2F;接口实现：</p><ul><li><p>DriveManager: 管理jdbc驱动</p></li><li><p>Connection: 连接</p></li><li><p>Statement(PreparedStatement)：增删改查</p></li><li><p>CallableStatement: 调用数据库中的 存储过程&#x2F;存储函数</p></li><li><p>Result: 返回的结果集</p><p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%203.png" alt="Untitled"></p></li></ul></li><li><p>JDBC访问数据库的具体步骤</p><ul><li>导入驱动，加载具体的驱动类</li><li>与数据库建立连接</li><li>发送sql，执行</li><li>处理结果集（查询）</li></ul></li><li><p>数据库驱动</p></li></ul><table><thead><tr><th></th><th>驱动jar</th><th>具体驱动类</th><th>连接字符串</th></tr></thead><tbody><tr><td>Oracle</td><td>ojdbc-x.jar</td><td>oracle.jdbc.OracleDriver</td><td>jdbc:oracle:thin:@localhost:1521:ORCL</td></tr><tr><td>MySQL</td><td>mysql-connector-java-x.jar</td><td>com.mysql.jdbc.Driver</td><td>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库实例名</td></tr><tr><td>SqlServer</td><td>sqljdbc-x.jar</td><td>come.microsoft.sqlserver.jdbc.SQLServerDriver</td><td>jdbc:microdoft:sqlserver:localhost:1433;databasename&#x3D;数据库实例名</td></tr></tbody></table><ul><li><p>使用jdbc，如果更换了数据库，只需要替换：驱动，具体驱动类、连接字符串、用户名、密码</p></li><li><p>Connection产生操作数据库的对象</p><ul><li>产生Statement对象：createStatement();</li><li>产生PreparedStatement对象：prepareStatement();</li><li>产生CallableStatement对象：prepareCall();</li></ul></li><li><p>Statement操作数据库</p><ul><li>增删改：excuteUpdate()</li><li>查询：excuteQuery()</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt = connection.createStatement();</span><br><span class="line"><span class="comment">//String sql = &quot;insert into student values(1, &#x27;zs&#x27;, 23, &#x27;s1&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//String sql = &quot;insert into student values(2, &#x27;ls&#x27;, 22, &#x27;s2&#x27;)&quot;;</span></span><br><span class="line"><span class="comment">//String sql = &quot;update student set stuname=&#x27;ww&#x27; where stuno=2&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from student where stuno=2&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure></li><li><p>PreparedStatement操作数据库</p><ul><li>public interface PreparedStatement extends Statement<ul><li>增删改：excuteUpdate()</li><li>查询：excuteQuery()</li></ul></li><li>赋值操作setXxx()</li><li>推荐使用，cause：编码简单； 预编译提高性能；安全（防止sql注入）<ul><li><p>statement sql注入：用户名：任意值 ‘ or 1&#x3D;1 —  密码：任意值</p><p>  select count(*) from login where uname&#x3D;’任意值’ or 1&#x3D;1’ and upwd&#x3D;’任意值’</p></li></ul></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into student values(?,?,?,?)&quot;</span>;</span><br><span class="line">pstmt = connection.prepareStatement(sql); <span class="comment">//预编译</span></span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">333</span>);</span><br><span class="line">pstmt.setString(<span class="number">2</span>, <span class="string">&quot;hh&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">3</span>, <span class="number">30</span>);</span><br><span class="line">pstmt.setString(<span class="number">4</span>, <span class="string">&quot;s4&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br></pre></td></tr></table></figure></li><li><p>Result: 保存结果集</p><ul><li>next(): 判断是否有下一条数据</li><li>previous()</li><li>getXxx(字段名&#x2F;位置)</li></ul></li><li><p>DriveManager: 管理jdbc驱动</p></li><li><p>CallableStatement: 调用数据库中的 存储过程&#x2F;存储函数</p></li></ul><hr><ul><li>jdbc总结（模板、八股文）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">a.导入驱动包、加载具体驱动类Class.forName(<span class="string">&quot;具体驱动类&quot;</span>);</span><br><span class="line">b.与数据库建立连接connection = DriverManager.getConnection(...);</span><br><span class="line">c.通过connection，获取操作数据库的对象（Statement\preparedStatement\callablestatement）</span><br><span class="line">stmt = connection.createStatement();</span><br><span class="line">d.(查询)处理结果集rs = pstmt.executeQuery()</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123; rs.getXxx(..) ;&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException e  )</span><br><span class="line">&#123; ...&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开顺序，与关闭顺序相反</span></span><br><span class="line"><span class="keyword">if</span>(rs!=<span class="literal">null</span>)rs.close()</span><br><span class="line"><span class="keyword">if</span>(stmt!=<span class="literal">null</span>) stmt.close();</span><br><span class="line"><span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> ps：jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException</code></pre><ul><li>CallableStatement:调用 存储过程、存储函数<br>connection.prepareCall(参数：存储过程或存储函数名)<br>参数格式：<ul><li>存储过程（无返回值return，用out参数替代）：<br>  { call  存储过程名(参数列表) }</li><li>存储函数（有返回值return）：<br>  { ? &#x3D; call  存储函数名(参数列表) }</li></ul></li><li>存储过程：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `AddNumbers`(<span class="keyword">IN</span> a <span class="type">INT</span>, <span class="keyword">IN</span> b <span class="type">INT</span>, <span class="keyword">OUT</span> sum <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> sum <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>JDBC调用存储过程的步骤：(oracle)<br>a.产生 调用存储过程的对象（CallableStatement） cstmt &#x3D; connection.prepareCall(   “…” ) ;<br>b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);<br>c.通过 registerOutParameter(…)处理输出参数类型<br>d.cstmt.execute()执行<br>e.接受 输出值（返回值）getXxx()</p><ul><li>调存储函数：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">FUNCTION</span> `AddNumbers`(a <span class="type">INT</span>, b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA</span><br><span class="line">    <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li>JDBC调用存储函数：与调存储过程的区别：<br> 在调用时，注意参数：”{? &#x3D;  call addTwoNumfunction(?,?) }”</li></ul><hr><ul><li>处理CLOB&#x2F;BLOB类型<br>处理稍大型数据：<ol><li>存储路径E:\JDK_API_zh_CN.CHM<br>  通过JDBC存储文件路径，然后 根据IO操作处理<br>  例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\JDK_API_zh_CN.CHM”存储到数据库中<br>  获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  <a href="http://2.io/">2.IO</a></li><li>CLOB：大文本数据 （小说-&gt;数据）<br>  BLOB：二进制</li></ol></li><li>clob:大文本数据   字符流 Reader Writer<ul><li>存：<br>  1.先通过pstmt 的? 代替小说内容 （占位符）<br>  2.再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是Int类型</li><li>取：<br>  1.通过Reader reader &#x3D; rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中</li></ul><ol start="2"><li>将Reader通过Writer输出即可。</li></ol></li><li>blob:二进制  字节流 InputStream OutputStream<br>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)</li></ul><h1 id="P18-JSP访问数据库"><a href="#P18-JSP访问数据库" class="headerlink" title="P18 JSP访问数据库"></a>P18 JSP访问数据库</h1><p>JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;%  … %&gt;）</p><ul><li>导包操作：<ul><li>java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path</li><li>Web项目：jar复制到WEB-INF&#x2F;lib</li></ul></li><li>核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt;</li><li>注意：如果jsp出现错误：The import Xxx cannot be resolved， 尝试解决步骤：<br>a.(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入<br>b.清空各种缓存：右键项目-&gt;Clean tomcat… clean  （Project -clean或者 进tomcat目录 删除里面work的子目录）<br>c.删除之前的tomcat，重新解压缩、配置tomcat，重启计算机<br>d.如果类之前没有包，则将该类加入包中</li></ul><hr><ul><li>JavaBean<br>将 jsp中 登录操作的代码  转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean<ul><li>JavaBean的作用：<ul><li>减轻的jsp复杂度</li><li>提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现）</li></ul></li><li>JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean<br>  a. public 修饰的类  ,public 无参构造<br>  b. 所有属性(如果有) 都是private，并且提供set&#x2F;get   (如果boolean 则get 可以替换成is)</li><li>使用层面, 分为2大类：<ul><li>a.封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑)逻辑<br>  可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java）</li><li>b.封装数据的JavaBean   （实体类，Student.java  Person.java  ）数据<br>  对应于数据库中的一张表<br>  Login login &#x3D; new Login(uname,upwd) ;&#x2F;&#x2F;即用Login对象 封装了2个数据（用户名 和密码）</li></ul></li><li>封装数据的JavaBean 对应于数据库中的一张表   (Login(name,pwd))<br>  封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean</li><li>JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java)</li></ul></li></ul><h1 id="P20-MVC设计模式和Servelet执行流程"><a href="#P20-MVC设计模式和Servelet执行流程" class="headerlink" title="P20 MVC设计模式和Servelet执行流程"></a>P20 MVC设计模式和Servelet执行流程</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%204.png" alt="Untitled"></p><ul><li><p>MVC设计模式：</p><table><thead><tr><th>M</th><th>Model</th><th>模型：一个功能</th><th>用JavaBean实现</th></tr></thead><tbody><tr><td>V</td><td>View</td><td>视图： 用于展示、以及与用户交互</td><td>使用html  js  css jsp jquery等前端技术实现</td></tr><tr><td>C</td><td>Controller</td><td>控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果返回给 请求处</td><td>可以用jsp实现，  但是一般建议使用 Servlet实现控制器</td></tr></tbody></table></li></ul><p>Jsp-&gt;Java(Servlet)-&gt;JSP</p><ul><li><p>Servlet: Java类必须符合一定的 规范：<br>a. 必须继承  javax.servlet.http.HttpServlet<br>b. 重写其中的 doGet()或doPost()方法</p></li><li><p>doGet()： 接受 并处 所有get提交方式的请求<br>doPost()：接受 并处 所有post提交方式的请求</p></li><li><p>Servlet要想使用，必须配置<br>Serlvet2.5：web.xml<br>Servle3.0： @WebServlet</p></li><li><p>Serlvet2.5：web.xml:</p><p>  项目的根目录：WebContent 、src</p><p>  <a href="WelcomeServlet">所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet  是去请求项目的根目录。</p><ul><li>Servlet流程：<br>  请求 -&gt;<url-pattern> -&gt; 根据<servlet-mapping>中的<servlet-name> 去匹配  <servlet> 中的<servlet-name>，然后寻找到<servlet-class>，求中将请求交由该<servlet-class>执行。</li></ul></li></ul><p>2个&#x2F;:<br>jsp:&#x2F;  localhost:8888<br>web.xml: &#x2F;   <a href="http://localhost:8888/%E9%A1%B9%E7%9B%AE%E5%90%8D/">http://localhost:8888/项目名/</a></p><h1 id="P21-Servelet25和Servelet30的使用"><a href="#P21-Servelet25和Servelet30的使用" class="headerlink" title="P21 Servelet25和Servelet30的使用"></a>P21 Servelet25和Servelet30的使用</h1><ul><li><p>回顾 纯手工方法 创建第一个Servlet，步骤：<br>编写一个类，继承HttpServlet<br>重写doGet()、doPost()方法<br>编写web.xml 中的servlet映射关系</p></li><li><p>借助于Eclipse快速生成Servlet<br>直接新建Servlet即可！（继承、重写、web.xml  可以借助Eclipse自动生成）</p></li><li><p>Servlet3.0，与Servlet2.5的区别：<br>Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)</p><ul><li>匹配流程：  请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类</li></ul></li><li><p>项目根目录：WebContent、src（即 所有的构建路径）</p><ul><li>例如：<br>  WebContent中有一个文件index.jsp<br>  src中有一个Servlet.java</li><li>如果: index.jsp中请求 <a href="abc">…</a> ，则 寻找范围：既会在src根目录中找  也会在WebContent根目录中找</li><li>如果：index.jsp中请求<a href="a/abc"></a>，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc</li></ul></li><li><p>&#x2F;</p><ul><li>web.xml中的 &#x2F;:  代表项目根路径，例如：<a href="http://localhost:8888/Servlet25Project/">http://localhost:8888/Servlet25Project/</a></li><li>jsp中的&#x2F;: 服务器根路径，<a href="http://localhost:8888/">http://localhost:8888/</a>（&#x2F;a &#x3D; <a href="http://localhost:8888/">http://localhost:8888/</a>a; a&#x3D; <a href="http://localhost:8888/">http://localhost:8888/</a><a href="http://localhost:8888/Servlet25Project/">Servlet25Project&#x2F;</a>webcontent&#x2F;a）</li><li>构建路径、WebContent都属于根目录</li></ul></li><li><p>Servlet生命周期：<strong>5</strong>个阶段<br>加载<br>初始化： init()  ，该方法会在 Servlet被加载并实例化的以后 执行<br>服务  ：service() -&gt;doGet()  doPost<br>销毁  ：destroy()，  Servlet被系统回收时执行<br>卸载</p></li></ul><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%205.png" alt="Untitled"></p><ul><li><p>init():<br>a. 默认第一次访问 Servlet时会被执行 （只执行这一次）<br>b. 可以修改为 Tomcat启动时自动执行</p><ul><li>Servlet2.5：  web.xml</li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">其中的“1”代表第一个。</span><br></pre></td></tr></table></figure><ul><li>Servlet3.0</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value=&quot;/WelcomeServlet&quot;, loadOnStartup=1  )</span></span><br></pre></td></tr></table></figure></li><li><p>service() -&gt;doGet()  doPost ：调用几次，则执行几次</p></li><li><p>destroy()：关闭tomcat服务时，执行一次。</p></li></ul><h1 id="P22-Servlet-API详解与源码分析"><a href="#P22-Servlet-API详解与源码分析" class="headerlink" title="P22 Servlet API详解与源码分析"></a>P22 Servlet API详解与源码分析</h1><ul><li><p>Servlet API：由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包 （即Servlet  API可以适用于 任何 通信协议）<br>我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。</p></li><li><p>Servlet继承关系</p><p>  <img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%206.png" alt="Untitled"></p></li><li><p>ServletConfig:接口</p><ul><li>ServletContext getServletContext():获取Servlet上下文对象   application</li><li>String  getInitParameter(String name):在<strong>当前Servlet</strong>范围内，获取名为name的参数值（初始化参数）</li></ul></li><li><p>ServletContext中的常见方法(application)：</p><ul><li>getContextPath():相对路径</li><li>getRealPath()：绝对路径<br>  setAttribute() 、getAttribute()</li><li>String getInitParameter(String name);在<strong>当前Web容器</strong>范围内，获取名为name的参数值（初始化参数）</li></ul></li></ul><p>Servlet3.0方式 给当前Servlet设置初始值：<br>@WebServlet( …. , initParams&#x3D; {@WebInitParam(name&#x3D;”serveltparaname30”,value&#x3D;”servletparavalue30”)   }   )<br>注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）</p><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%207.png" alt="Untitled"></p><ul><li><p>HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()<br>HttpServletResponse中的方法：同response</p></li><li><p>Servlet使用层面：</p><p>  Eclipse中在src创建一个Servlet，然后重写doGet()  doPost()就可以  （doGet() doPost()只需要编写一个）。</p></li></ul><h1 id="P23-MVC案例"><a href="#P23-MVC案例" class="headerlink" title="P23 MVC案例"></a>P23 MVC案例</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%208.png" alt="Untitled"></p><h1 id="P24-三层架构"><a href="#P24-三层架构" class="headerlink" title="P24 三层架构"></a>P24 三层架构</h1><p>与MVC设计模式的目标一致：都是为了解耦合、提高代码复用；</p><p>区别：两者对项目理解的角度不同</p><ul><li>三层组成<ul><li>表示层（USL, User Show layer; 视图层）<ul><li>前台：对应MVC中的V， 用于和用户交互、界面显示<ul><li>jsp, js, html, css, jquery等前端web技术</li><li>代码位置：webcontent</li></ul></li><li>后台：对应MVC中的C，用于 控制跳转、调用<ul><li>Servlet(Spring MVC Strusts2)</li><li>代码位置：xxx.servlet包</li></ul></li></ul></li><li>业务逻辑层（BLL，Business Logic Layer; Service层）<ul><li>接收表示层的请求 调用</li><li>组装数据访问层，逻辑性操作（增删改查， 删：查+删）</li><li>位于xxx.service包</li></ul></li><li>数据访问层（DAL，Data Access Layer; Dao层）<ul><li>直接访问数据库的操作，原子性操作（增删改查）</li><li>位于xxx.dao包</li></ul></li></ul></li><li>三层的关系：<ul><li>上层将请求传递给下层，下层处理后返回给上层</li><li>上层依赖于下层</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * jsp常见的内置对象都可以在servlet里面拿到</span><br><span class="line"> * out: PrintWriter writer = response.getWriter()</span><br><span class="line"> * session: request.getSession()</span><br><span class="line"> * application: request.getServletContext()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/Untitled%209.png" alt="Untitled"></p><ul><li>一个Servlet对应一个功能</li></ul><h1 id="P29-优化三层（接口和DBUtil）"><a href="#P29-优化三层（接口和DBUtil）" class="headerlink" title="P29 优化三层（接口和DBUtil）"></a>P29 优化三层（接口和DBUtil）</h1><ul><li>加入接口<br>建议面向接口开发：先接口-再实现类<br>–service、dao加入接口<br>–接口与实现类的命名规范<br>接口：interface，起名   I实体类ServiceIStudentService<br>IStudentDao<br>实现类：implements起名   实体类ServiceImplStudentServiceImpl<br>StudentDaoImpl<br>接口：I实体类层所在包名IStudentService、IStudentDao<br>接口所在的包：  xxx.servicexx.dao</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实现类： 实体类层所在包名ImplStudentServiceImpl、StudentDaoImpl</span><br><span class="line">实现类所在的包：xxx.service.implxx.dao.impl</span><br><span class="line"></span><br><span class="line">以后使用接口/实现类时，推荐写法：</span><br><span class="line">接口 x = new 实现类();</span><br><span class="line">IStudentDao studentDao = new StudentDaoImpl();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>DBUtil 通用的数据库帮助类，可以简化Dao层的代码量</p><p>  帮助类 一般建议写在  xxx.util包</p></li><li><p>方法重构：  将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可</p></li></ul><h1 id="P30-Web调试："><a href="#P30-Web调试：" class="headerlink" title="P30 Web调试："></a>P30 Web调试：</h1><p>与java代码的调试 区别：启动方式不同</p><p>index.jsp -&gt;index_jsp.java -&gt;index_jsp.class</p><p>jsp-&gt;java-&gt;class<br>jsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中</p><p>10000</p><h1 id="P21-分页SQL"><a href="#P21-分页SQL" class="headerlink" title="P21 分页SQL"></a>P21 分页SQL</h1><ul><li>分页<br>要实现分页，必须知道  某一页的 数据 从哪里开始 到哪里结束</li><li>页面大小：每页显示的数据量</li></ul><p>假设每页显示10条数据</p><ul><li><p>mysql分页：</p><ul><li><p>mysql:从0开始计数<br>  009<br>  11019<br>  22029<br>  nn*10      (n+1)*10-1</p><p>  结论：<br>  分页：<br>  第n页的数据：  第(n-1)<em>10+1条  – 第n</em>10条</p></li><li><p>MYSQL实现分页的sql：<br>  limit  开始,多少条<br>  第0页<br>  select * from student limit 0,10 ;<br>  第1页<br>  select * from student limit 10,10 ;<br>  第2页<br>  select * from student limit  20,10 ;<br>  第n页<br>  select * from student limit n*10,10</p></li><li><p>mysql的分页语句：</p></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student limit 页数<span class="operator">*</span>页面大小,页面大小</span><br></pre></td></tr></table></figure></li><li><p>oracle分页：</p></li><li><p>SQLServer分页：  3种分页sql</p></li></ul><p>dao和DBUtil的区别：<br>dao 是处理特定 类的 数据库操作类：<br>DBUtil是通用  数据库操作类</p><h1 id="P34-文件上传"><a href="#P34-文件上传" class="headerlink" title="P34 文件上传"></a>P34 文件上传</h1><ul><li><p>上传文件</p><ul><li>引入2个jar<br>  apache: commons-fileupload.jar组件<br>  commons-fileupload.jar依赖 commons-io.jar</li><li>代码：<ul><li>前台jsp：  <input type="file"  name="spicture"/>  表单提交方式必须为post  在表单中必须增加一个属性 entype="multipart/form-data"</li><li>后台servlet：</li></ul></li><li>注意的问题：<br>  上传的目录  upload ：</li></ul><ol><li><p>如果修改代码，则在tomcat重新启动时 会被删除<br>  原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录）</p><p>   2.如果不修改代码，则不会删除<br> 原因： 没有修改代码，class仍然是之前的class</p></li></ol><p>  因此，为了防止 上传目录丢失： a.虚拟路径b.直接更换上传目录 到非tomcat目录  </p></li><li><p>限制上传：<br>类型、<br>大小<br>注意 对文件的限制条件 写再parseRequest之前</p></li><li><p>下载：不需要依赖任何jar<br>a.请求（地址a  form），请求Servlet<br>b.Servlet通过文件的地址  将文件转为输入流 读到Servlet中<br>c.通过输出流 将 刚才已经转为输入流的文件  输出给用户<br>注意：下载文件 需要设置2个 响应头：<br>response.addHeader(“content-Type”,”application&#x2F;octet-stream” );&#x2F;&#x2F;MIME类型:二进制文件（任意文件）<br>response.addHeader(“content-Disposition”,”attachement;filename&#x3D;”+fileName );&#x2F;&#x2F;fileName包含了文件后缀：abc.txt</p></li><li><p>下载时 ，文件名乱码问题：</p><ul><li><p>edge：</p><p>  URLEncoder.encode(fileName,”UTF-8”)</p></li><li><p>firefox：<br>  给文件名 加：<br>  前缀   &#x3D;?UTF-8?B?</p><p>  String构造方法<br>  Base64.encode</p><p>  后缀   ?&#x3D;<br>  示例：<br>  response.addHeader(“content-Disposition”,”attachment;filename&#x3D;&#x3D;?UTF-8?B?”+   new String(  Base64.encodeBase64(fileName.getBytes(“UTF-8”))  ) +”?&#x3D;” );&#x2F;&#x2F;fileName包含了文件后缀：abc.txt</p></li></ul></li></ul><h1 id="P38-EL语法表达式，点操作符和中括号操作符"><a href="#P38-EL语法表达式，点操作符和中括号操作符" class="headerlink" title="P38 EL语法表达式，点操作符和中括号操作符"></a>P38 EL语法表达式，点操作符和中括号操作符</h1><p>EL ：为了消除jsp中的Java代码</p><ul><li>语法：<br>${EL表达式}<br>a.EL不需要导包<br>b.在el中调用属性，其实是调用的getXxx()方法</li><li>${范围.对象.属性.属性的属性 }</li><li>操作符：操作：属性，不是对象<br>. : 使用方便<br>[] : 如果是常量属性，需要使用双引号&#x2F;单引号 引起来;比点操作符更加强大</li><li>[]强大之处:<ul><li>可以容纳一些 特殊符号 （.  ?   -）</li><li>[]可以容纳 变量属性 （可以动态赋值）<br>  String x &#x3D; “a”;<br>  ${requestScope.a}等价于${requestScope[“a”]}等价于${${requestScope[x]}</li><li>可以处理数组<br>  ${requestScope.arr[0] }</li><li>普通对象、map中的变量</li></ul></li><li>关系运算符，逻辑运算符</li><li>empty运算符：判断一个值null&#x2F;不存在→true</li><li>EL表达式的隐式对象（不需要new就能使用的对象，自带的对象）<ul><li>作用域访问的对象（EL域对象）: pageScope,  requestScope, sessionScope, applicationScope<ul><li>如果不指定域对象，则默认 会根据从小到大的顺序 依此取值</li></ul></li><li>参数访问对象： 获取表单数据 （request.getParameter()&#x2F;超链接中传的值&#x2F;地址栏中的值→${param}, request.getParameterValues()→${paramValues}）</li><li>JSP隐式对象：pageContext<ul><li>在jsp中可以通过pageContext获取jsp的其他隐式对象；因此如果要在el中使用jsp隐式对象，可以通过pageContext获取</li><li>例如：${pageContext.request}; pageContext.getSession→${pageContext.session}hia</li><li>还可以获取级联对象：${pageContext.request.serverPort}</li></ul></li></ul></li></ul><h1 id="P40-JSTL基础及set-out-remove"><a href="#P40-JSTL基础及set-out-remove" class="headerlink" title="P40 JSTL基础及set, out, remove"></a>P40 JSTL基础及set, out, remove</h1><ul><li><p>JSTL：比EL更加强大</p><ul><li>需要引入2个jar ：jstl.jar   standard.jar</li><li>引入tablib：&lt;%@ taglib uri&#x3D;”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ prefix&#x3D;”c” %&gt;   (其中prefix&#x3D;”c” :前缀)</li><li>核心标签库：  通用标签库、条件标签库 、迭代标签库</li></ul></li><li><p>通用标签库<br>&lt;c:set&gt;赋值，作用：</p><ul><li><p>在某个作用域之中（4个范围对象），给<strong>某个变量赋值</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;变量名&quot;</span>    value=<span class="string">&quot;变量值&quot;</span>   scope=<span class="string">&quot;4个范围对象的作用域&quot;</span>/&gt;</span><br><span class="line">例如：</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;name&quot;</span>    value=<span class="string">&quot;zhangsan&quot;</span>   scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br><span class="line">等价于：</span><br><span class="line">request.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>) ;</span><br></pre></td></tr></table></figure></li><li><p>给<strong>某个对象的属性</strong>赋值: 在某个作用域之中（4个范围对象），给<strong>某个对象的属性复制</strong> （此种写法，不能指定scope属性）</p><ul><li>给普通对象赋值:</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set target=<span class="string">&quot;对象&quot;</span> property=<span class="string">&quot;对象的属性&quot;</span>  value=<span class="string">&quot;赋值&quot;</span> /&gt;</span><br><span class="line">&lt;c:set target=<span class="string">&quot;$&#123;requestScope.student&#125;&quot;</span> property=<span class="string">&quot;sname&quot;</span>  value=<span class="string">&quot;zxs&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>给map对象赋值:</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set target=<span class="string">&quot;对象&quot;</span> property=<span class="string">&quot;对象的属性&quot;</span>  value=<span class="string">&quot;赋值&quot;</span> /&gt;</span><br><span class="line">&lt;c:set target=<span class="string">&quot;$&#123;requestScope.countries&#125;&quot;</span> property=<span class="string">&quot;cn&quot;</span>  value=<span class="string">&quot;中国&quot;</span> /&gt;    </span><br></pre></td></tr></table></figure></li><li><p>注意 &lt;c:set&gt;可以给<strong>不存在的变量</strong>赋值 （但不能给不存在的对象赋值）</p></li></ul></li><li><p>&lt;c:out&gt;  ：显示</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>:&lt;c:out value=<span class="string">&#x27;&lt;a href=&quot;[https://www.baidu.com](https://www.baidu.com/)&quot;&gt;百度&lt;/a&gt;&#x27;</span> <span class="keyword">default</span>=<span class="string">&quot;当value为空的，显示的默认值&quot;</span> escapeXml=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line"><span class="literal">false</span>：&lt;c:out value=<span class="string">&#x27;&lt;a href=&quot;[https://www.baidu.com](https://www.baidu.com/)&quot;&gt;百度&lt;/a&gt;&#x27;</span> escapeXml=<span class="string">&quot;false&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>&lt;c:remove &gt;：删除属性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:remove <span class="keyword">var</span>=<span class="string">&quot;a&quot;</span> scope=<span class="string">&quot;request&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>选择：<ul><li><p>if(boolean): 单重选择<br>  &lt;c:if test&#x3D;”” &gt;</p></li><li><p>if else if… esle if… else  &#x2F;switch</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test=<span class="string">&quot;...&quot;</span>&gt;   &lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=<span class="string">&quot;...&quot;</span>&gt;   &lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=<span class="string">&quot;...&quot;</span>&gt;   &lt;/c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;   &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure></li><li><p>在使用 test&#x3D;”” 一定要注意后面是否有空格<br>  例如：test&#x3D;”${10&gt;2 }”   true<br>  test&#x3D;”${10&gt;2 } “  非true</p></li></ul></li><li>循环（迭代标签库）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">&lt;c:forEach  begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;5&quot;</span> step=<span class="string">&quot;1&quot;</span> varStatus=<span class="string">&quot;status&quot;</span>&gt;</span><br><span class="line">$&#123;status.index&#125; </span><br><span class="line">test...&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:names)</span><br><span class="line">&lt;c:forEach  <span class="keyword">var</span>=<span class="string">&quot;student&quot;</span> items=<span class="string">&quot;$&#123;requestScope.students &#125;&quot;</span> &gt;</span><br><span class="line">$&#123;student.sname &#125;-$&#123;student.sno &#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h1 id="P42-过滤器"><a href="#P42-过滤器" class="headerlink" title="P42 过滤器"></a>P42 过滤器</h1><p><img src="/JavaWeb%20a0049edb9a814733869816542ecba636/d1517cf2-51f7-48e8-bad8-825bb781ae57.png" alt="Untitled"></p><ul><li>过滤器：<br>实现一个Filter接口<br>init()、destroy() 原理、执行时机 同Servlet<br>配置过滤器，类似servlet<br>通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行</li><li>filter映射<ul><li>只拦截 访问MyServlet的请求<br>  <url-pattern>&#x2F;MyServlet</url-pattern></li><li>拦截一切请求（每一次访问 都会被拦截）<br>  <url-pattern>&#x2F;*</url-pattern></li></ul></li><li>通配符<ul><li>dispatcher请求方式：<ul><li>REQUEST：拦截HTTP请求 get post</li><li>FORWARD：只拦截 通过 请求转发方式 的请求</li><li>INCLUDE: 只拦截通过 request.getRequestDispatcher(“”).include()  、通过&lt;jsp:include page&#x3D;”…” &#x2F;&gt;此种方式发出的请求</li><li>ERROR：只拦截<error-page>发出的请求</li></ul></li></ul></li><li>过滤器中doFilter方法参数：ServletRequest<br>在Servlet中的方法参数：HttpServletRequest</li><li>过滤器链<br>可以配置多个过滤器，过滤器的先后顺序 是由 <filter-mapping>的位置 决定</li></ul><h1 id="P43-监听器"><a href="#P43-监听器" class="headerlink" title="P43 监听器"></a>P43 监听器</h1><ul><li>监听器<ul><li>步骤：<ul><li>编写监听器，实现接口</li><li>配置web.xml</li></ul></li><li>监听对象：request session application<ul><li>request：ServerRequestListener</li><li>session: HttpSessionListener</li><li>application: ServletContextListener;</li><li>每个监听器各自两个方法，监听开始和结束</li><li>ServletContext在servlet容器启动时自动创建</li></ul></li><li>监听属性的变更<ul><li>request：ServerRequestAttributeListener</li><li>session: HttpSessionAttributeListener</li><li>application: ServletContextAttributeListener;</li></ul></li></ul></li></ul><h1 id="P44-session绑定解绑、钝化活化"><a href="#P44-session绑定解绑、钝化活化" class="headerlink" title="P44 session绑定解绑、钝化活化"></a>P44 session绑定解绑、钝化活化</h1><ul><li><p>钝化：内存→硬盘</p></li><li><p>活化：硬盘→内存</p></li><li><p>session对象的四种状态</p><ul><li>session.setAttribute(”a”, xxx) 将对象<strong>绑定</strong>到session中</li><li>session.removeAttribute(”a”) 将对象从session中<strong>解绑</strong></li><li>钝化</li><li>活化</li></ul></li><li><p>监听：</p><ul><li>监听session对象的绑定和解绑：HttpSessionBindingListener  不需要配置web.xml</li><li>监听session对象的钝化活化：HttpSessionActivationListener  不需要配置web.xml</li></ul></li><li><p>如何钝化、活化：配置tomcat安装目录&#x2F;conf&#x2F;context.xml</p></li><li><p>钝化、活化的本质 就是序列化、反序列化，需要实现Serializable接口</p></li><li><p>总结：钝化、活化 实际执行 是通过context.xml中进行配置而进行；</p><p>  HttpSessionActivationListener只是负责在 session钝化 和 活化 时予以监听。</p></li></ul><h1 id="P45-Ajax原理及js方式实现"><a href="#P45-Ajax原理及js方式实现" class="headerlink" title="P45 Ajax原理及js方式实现"></a>P45 Ajax原理及js方式实现</h1><ul><li>Ajax： 异步js 和 xml<ul><li><p>异步刷新可以使得：只刷新需要修改的地方，页面中其他部分保持不变</p><p>  例如:视频点赞</p></li><li><p>实现：</p><ul><li>js： XMLHttpRequest对象<ul><li>XMLHttpRequest对象的方法<ul><li>open(方法名（提交方式get&#x2F;post）, 服务器地址, true)：(与服务段端建立链接)</li><li>send():<ul><li>get: send(null)</li><li>post: send(参数值)</li></ul></li><li>setRequestHeader(header, value)<ul><li>get不需要设置此值</li><li>post<ul><li>如果请求元素中包含了文件上传：setRequestHeader(”Content-Tyoe”, “multipart&#x2F;form-data”)</li><li>不包含：setRequestHeader(”Content-Tyoe”, “application&#x2F;x-www-form-urlencoded”)</li></ul></li></ul></li></ul></li><li>XMLHttpRequest对象的属性<ul><li>readyState:请求状态。 4：请求完毕</li><li>state:响应状态。 200：响应正常</li><li>onreadystatechange: 回调函数</li><li>responseText: 响应格式为text</li><li>responseXML</li></ul></li></ul></li><li>jquery（推荐）  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: 服务器地址，</span><br><span class="line">type：get | post,</span><br><span class="line"><span class="attr">data</span>: 请求数据，</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result, testStatus</span>) &#123;&#125;,</span><br><span class="line"><span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">xhr, errorMessage, e</span>) &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">请求数据,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">result, testStatus</span>) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">预期返回值类型（<span class="title class_">String</span>\xml),</span><br><span class="line">);</span><br><span class="line">$.<span class="title function_">post</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">请求数据,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">result, testStatus</span>) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">预期返回值类型（<span class="title class_">String</span>\xml),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(xxx).<span class="title function_">load</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">请求数据,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>  load: 将服务端的返回值，直接加载到$(xxx)所选择的元素  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(</span><br><span class="line">服务器地址,</span><br><span class="line">json格式的请求数据,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;P1-JSP环境搭建及入门&quot;&gt;&lt;a href=&quot;#P1-JSP环境搭建及入门&quot; class=&quot;headerlink&quot; title=&quot;P1 JSP环境搭建及入门&quot;&gt;&lt;/a&gt;P1 JSP环境搭建及入门&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;静态&amp;#x2F;动态&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="http://example.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>beta</title>
    <link href="http://example.com/2022/09/20/beta/"/>
    <id>http://example.com/2022/09/20/beta/</id>
    <published>2022-09-20T14:33:25.000Z</published>
    <updated>2022-09-20T14:34:44.163Z</updated>
    
    <content type="html"><![CDATA[<p>beta</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;beta&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/09/20/hello-world/"/>
    <id>http://example.com/2022/09/20/hello-world/</id>
    <published>2022-09-20T14:31:15.022Z</published>
    <updated>2022-09-20T14:31:15.022Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DB</title>
    <link href="http://example.com/2021/09/05/DB/"/>
    <id>http://example.com/2021/09/05/DB/</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2024-04-18T02:16:44.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 绪论"></a><a href="#chapter-1-%E7%BB%AA%E8%AE%BA"></a>Chapter 1 绪论</h1><h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a><a href="#11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"></a>1.1 数据库系统概述</h2><h3 id="1-1-1-基本概念"><a href="#1-1-1-基本概念" class="headerlink" title="1.1.1 基本概念"></a><a href="#111-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>1.1.1 基本概念</h3><ul><li><strong>数据</strong>（Data）: 数据库中存储的基本对象, 描述事物的符号记录</li><li><strong>数据库</strong>（Database）: 是长期储存在计算机内、有组织的、可共享的大量数据的集合。</li><li><strong>数据库管理系统</strong>（DBMS）: 位于用户与操作系统之间的一层数据管理软件; 是基础软件，是一个大型复杂的软件系统 。主要功能：<ul><li>数据定义</li><li>数据组织、存储、管理</li><li>数据操纵</li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护</li><li>others</li></ul></li><li><strong>数据库系统</strong>（DBS）: 由数据库、数据库管理系统（及其应用开发工具）、应用程序、数据库管理员组成的存储、管理、处理和维护数据的系统</li></ul><h3 id="1-1-2-数据库管理技术的发展"><a href="#1-1-2-数据库管理技术的发展" class="headerlink" title="1.1.2 数据库管理技术的发展"></a><a href="#112-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95"></a>1.1.2 数据库管理技术的发展</h3><table><thead><tr><th></th><th></th><th>人工管理阶段</th><th>文件系统阶段</th><th>数据库系统阶段</th></tr></thead><tbody><tr><td>背景</td><td>应用背景</td><td>科学计算</td><td>科学计算、数据管理</td><td>大规模数据管理</td></tr><tr><td></td><td>硬件背景</td><td>无直接存取存储设备</td><td>磁盘</td><td>大容量磁盘、磁盘阵列</td></tr><tr><td></td><td>软件背景</td><td>没有操作系统</td><td>有文件系统</td><td>有DBMS</td></tr><tr><td></td><td>处理方式</td><td>批处理</td><td>联机实时处理、批处理</td><td>联机实时处理,分布处理,批处理</td></tr><tr><td>特点</td><td>数据的管理者</td><td>用户</td><td>文件系统，数据可长期保存</td><td>DBMS</td></tr><tr><td></td><td>数据面向的对象</td><td>某一应用程序</td><td>某一应用</td><td>现实世界</td></tr><tr><td></td><td>数据的共享程度</td><td>无共享、冗余度极大</td><td>共享性差、冗余度大</td><td>共享性高、冗余度小</td></tr><tr><td></td><td>数据的独立性</td><td>不独立，完全依赖于程序</td><td>独立性差</td><td>具有高度的物理独立性和一定的逻辑独立性</td></tr><tr><td></td><td>数据的结构化</td><td>无结构</td><td>记录内有结构，整体无结构</td><td>整体结构化，用数据模型描述</td></tr><tr><td></td><td>数据控制能力</td><td>应用程序自己控制</td><td>应用程序自己控制</td><td>有DBMS提供数据安全性、完整性、并发控制和恢复能力</td></tr></tbody></table><h3 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a><a href="#113-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"></a>1.1.3 数据库系统的特点</h3><ul><li>数据结构化</li><li>数据的共享性高，冗余度低且易扩充</li><li>数据独立性高：数据的物理独立性和逻辑独立性</li><li>数据由数据库管理系统统一管理和控制：数据的安全性（Security）保护；数据的完整性（Integrity）检查；并发（Concurrency）控制；数据库恢复（Recovery）</li></ul><h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a><a href="#12-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"></a>1.2 数据模型</h2><h3 id="1-2-1-两类数据模型"><a href="#1-2-1-两类数据模型" class="headerlink" title="1.2.1 两类数据模型"></a><a href="#121-%E4%B8%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"></a>1.2.1 两类数据模型</h3><ul><li><strong>概念模型</strong> 也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</li><li><strong>逻辑模型</strong>和<strong>物理模型</strong><ul><li><strong>逻辑模型</strong>：主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。按计算机系统的观点对数据建模，用于DBMS实现。</li><li><strong>物理模型</strong>：是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul></li></ul><p>现实世界→数据库设计人员概念模型→数据库设计人员+设计工具逻辑模型→DBMS物理模型现实世界 \xrightarrow{数据库设计人员} 概念模型\xrightarrow{数据库设计人员+设计工具} 逻辑模型\xrightarrow{DBMS}物理模型 现实世界数据库设计人员​概念模型数据库设计人员+设计工具​逻辑模型DBMS​物理模型</p><h3 id="1-2-2-概念模型"><a href="#1-2-2-概念模型" class="headerlink" title="1.2.2 概念模型"></a><a href="#122-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"></a>1.2.2 概念模型</h3><p>基本概念:</p><ul><li>实体（Entity）：客观存在并可相互区别的事物</li><li>属性（Attribute）：实体所具有的某一特性</li><li>码（Key）：唯一标识实体的属性集</li><li>实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体</li><li>实体集（Entity Set）：同一类型实体的集合</li><li>联系（Relationship）：实体（型）内部的联系和实体（型）之间的联系</li><li>实体-联系方法（Entity-Relationship Approach）：用E-R图来描述现实世界的概念模型。E-R方法也称为E-R模型</li></ul><h3 id="1-2-3-数据模型的组成要素"><a href="#1-2-3-数据模型的组成要素" class="headerlink" title="1.2.3 数据模型的组成要素"></a><a href="#123-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"></a>1.2.3 数据模型的组成要素</h3><ul><li>数据结构</li><li>数据操作 ：查询、更新（包括插入、删除、修改）</li><li>数据的完整性约束条件</li></ul><h3 id="1-2-4-常用的数据模型"><a href="#1-2-4-常用的数据模型" class="headerlink" title="1.2.4 常用的数据模型"></a><a href="#124-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"></a>1.2.4 常用的数据模型</h3><ul><li>层次模型（Hierarchical Model）</li><li>网状模型（Network Model）</li><li>关系模型（Relational Model)）</li><li>面向对象数据模型（Object Oriented Data Model）</li><li>对象关系数据模型（Object Relational Data Model）</li><li>半结构化数据模型（Semistruture Data Model）</li></ul><h3 id="1-2-5-关系模型"><a href="#1-2-5-关系模型" class="headerlink" title="1.2.5 关系模型"></a><a href="#125-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"></a>1.2.5 关系模型</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"></a>数据结构</h4><ul><li>关系: 由行和列组成的二维表格(表框架 + 元组*n)</li><li>属性: 表框架中的每一列</li><li>值域(域): 元组在某一属性下的取值范围</li><li>元组: 关系中的每一行</li><li>关系数据库模式: 该关系数据库中所有关系的关系模式的集合</li><li>关键字: 能唯一标识关系中的一个元组, 且又不含多余的属性值 的 属性集</li></ul><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a><a href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"></a>完整性约束</h4><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul><h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a><a href="#13-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"></a>1.3 数据库系统的结构</h2><h3 id="1-3-1-数据库系统模式的概念"><a href="#1-3-1-数据库系统模式的概念" class="headerlink" title="1.3.1 数据库系统模式的概念"></a><a href="#131-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5"></a>1.3.1 数据库系统模式的概念</h3><ul><li><p>模式（Schema）：数据库逻辑结构和特征的描述</p></li><li><p>实例（Instance）：模式的一个具体值</p></li></ul><h3 id="1-3-2-数据库系统的三级模式结构"><a href="#1-3-2-数据库系统的三级模式结构" class="headerlink" title="1.3.2 数据库系统的三级模式结构"></a><a href="#132-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"></a>1.3.2 数据库系统的三级模式结构</h3><ul><li>模式（Schema）：整个数据库中数据的全局逻辑结构；一个数据库只有一个模式</li><li>外模式（External Schema）：数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述；一个数据库可以有多个外模式</li><li>内模式（Internal Schema）：是数据物理结构和存储方式的描述；一个数据库只有一个内模式</li></ul><p><img src="https://i.loli.net/2021/08/31/N62AKnC1bakVXxG.png" alt="image-20210831202834790"></p><h3 id="1-3-3-数据库的二级映像"><a href="#1-3-3-数据库的二级映像" class="headerlink" title="1.3.3 数据库的二级映像"></a><a href="#133-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%83%8F"></a>1.3.3 数据库的二级映像</h3><ul><li>外模式／模式映像：多个外模式 -&gt;一个模式</li><li>模式／内模式映像: 数据全局逻辑结构与存储结构之间的对应关系</li></ul><h3 id="1-3-4-功能与数据独立性"><a href="#1-3-4-功能与数据独立性" class="headerlink" title="1.3.4 功能与数据独立性"></a><a href="#134-%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7"></a>1.3.4 功能与数据独立性</h3><ul><li>概念-&gt;内: 物理独立性</li><li>外-&gt;概念: 逻辑独立性</li></ul><h1 id="Chapter-2-关系数据库"><a href="#Chapter-2-关系数据库" class="headerlink" title="Chapter 2 关系数据库"></a><a href="#chapter-2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"></a>Chapter 2 关系数据库</h1><h2 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a><a href="#21-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"></a>2.1 关系数据结构及形式化定义</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>基本概念</h3><ul><li><p><strong>关系</strong>：D1×D2×…×DnD1×D2×…×DnD1×D2×…×Dn的子集叫做在域D1,D2,…,DnD1,D2,…,DnD1,D2,…,Dn上的关系，记做：R(D1，D2，…，Dn)R(D1，D2，…，Dn)R(D1，D2，…，Dn)。</p></li><li><p><strong>候选码</strong>（key）：某一属性组的值能唯一地标识一个元组，而其自己不能，则称该属性组为候选码(candidate key)</p></li><li><p><strong>主码</strong>：若一个关系有多个候选码，则选定其中一个为主码(primary key)，主码只可以有一个</p></li><li><p><strong>主属性</strong>(prime attribute)：候选码的各属性称为（主属性）</p></li><li><p>非主属性：不包含在任何候选码中的属性</p></li><li><p>全码(all key)：关系模式的所有属性是这个关系模式的候选码.</p></li></ul><h3 id="关系的性质："><a href="#关系的性质：" class="headerlink" title="关系的性质："></a><a href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"></a>关系的性质：</h3><ul><li>同质的列</li><li>不同属性应该有不同的名称</li><li>属性是无序的</li><li>元组不能重复</li><li>元组无序</li><li>分量是原子（即每一个分量都必须是不可分的数据项）</li></ul><h2 id="2-2-关系的完整性"><a href="#2-2-关系的完整性" class="headerlink" title="2.2 关系的完整性"></a><a href="#22-%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"></a>2.2 关系的完整性</h2><ul><li><strong>实体完整性</strong>：主属性非空</li><li><strong>参照完整性</strong>：外键要么取空值, 要么是被引用表中的主键值</li><li><strong>用户定义的完整性</strong> ：用户自己定义的属性取值约束</li></ul><h2 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a><a href="#24-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"></a>2.4 关系代数</h2><table><thead><tr><th></th><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>集合运算符</td><td>∪\cup∪</td><td>并</td></tr><tr><td></td><td>−-−</td><td>差</td></tr><tr><td></td><td>∩\cap∩</td><td>交</td></tr><tr><td></td><td>×\times×</td><td>笛卡尔积</td></tr><tr><td>专门的关系运算符</td><td>σ\sigmaσ</td><td>选择</td></tr><tr><td></td><td>Π\PiΠ</td><td>投影</td></tr><tr><td></td><td>⋈\Join⋈</td><td>连接</td></tr><tr><td></td><td>÷\div÷</td><td>除</td></tr></tbody></table><ul><li>选择运算: σF(R)\sigma_{F}(R)σF​(R)<ul><li>由关系R中满足条件F的各元组构成</li></ul></li><li>投影运算：ΠA(R)\Pi_A(R)ΠA​(R)<ul><li>从R中选择出若干属性列®组成新的关系</li><li>注意消除重复元组(行)</li></ul></li><li>连接运算: R⋈SR\Join SR⋈S<ul><li>等值连接</li><li>自然连接：所有同名属性上的取值都一样, 就连接元组, 同名属性保留一份</li><li>悬浮元组(dangling tuple)：因为公共属性组不相等被舍弃的元组</li><li>外连接(outer join)：把悬浮元组保存在结果关系中（ 有”外”的一侧, 其所有元组均出现, 另一侧无匹配元组就用null代替）</li><li>左外连接(left outer join或left join)：只保留左边关系R中的悬浮元组</li><li>右外连接(right outer join或right join)：只保留右边关系S中的悬浮元组</li></ul></li><li>除运算：R÷S=TR\div S &#x3D; TR÷S=T<ul><li>设$ x\in T,则, 则,则∀y\in S(x,y)\in R(x,y)\in R$ 所有满足条件的xxx构成结果</li></ul></li></ul><h1 id="Chapter-3-SQL"><a href="#Chapter-3-SQL" class="headerlink" title="Chapter 3 SQL"></a><a href="#chapter-3-sql"></a>Chapter 3 SQL</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a><a href="#31-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>3.1 基本概念</h2><p>SQL（Structured Query Language）：结构化查询语言，是关系数据库的标准语言</p><table><thead><tr><th>SQL功能</th><th>动词</th></tr></thead><tbody><tr><td>数据查询</td><td>select</td></tr><tr><td>数据定义</td><td>create, drop, alter</td></tr><tr><td>数据操纵</td><td>insert, update, delete</td></tr><tr><td>数据控制</td><td>grant, revoke</td></tr></tbody></table><p>SQL支持数据库三级模式结构</p><table><tbody><tr><td class="code"><pre><span class="line">SQL</span><br><span class="line">视图 (外模式)</span><br><span class="line">基本表 (模式)</span><br><span class="line">存储文件(内模式)</span><br></pre></td></tr></tbody></table><h2 id="3-2-数据定义"><a href="#3-2-数据定义" class="headerlink" title="3.2 数据定义"></a><a href="#32-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"></a>3.2 数据定义</h2><table><thead><tr><th>操作对象</th><th></th><th>操作方式</th><th></th></tr></thead><tbody><tr><td></td><td>创建</td><td>删除</td><td>修改</td></tr><tr><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table><h3 id="3-2-1-模式定义与删除"><a href="#3-2-1-模式定义与删除" class="headerlink" title="3.2.1 模式定义与删除"></a><a href="#321-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%A0%E9%99%A4"></a>3.2.1 模式定义与删除</h3><ul><li><p>模式定义</p><ul><li>&#96;&#96;&#96;sql<br>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]<!--code 1--><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">+   模式删除</span><br><span class="line">    </span><br><span class="line">    +   ```sql</span><br><span class="line">        DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</span><br><span class="line">        &lt;!--code 2--&gt;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-2-基本表的定义、删除与修改"><a href="#3-2-2-基本表的定义、删除与修改" class="headerlink" title="3.2.2 基本表的定义、删除与修改"></a><a href="#322-%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9"></a>3.2.2 基本表的定义、删除与修改</h3><ul><li><p>定义表</p><ul><li>&#96;&#96;&#96;sql<br>CREATE TABLE &lt;表名&gt;<br>  (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]<br>  [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ]<br>      …<br>  [,&lt;表级完整性约束条件&gt; ] );<!--code 3--><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">    +   | 数据类型 | 含义 |</span><br><span class="line">        | --- | --- |</span><br><span class="line">        | CHAR,CHARACTER（n） | 长度为n的定长字符串 |</span><br><span class="line">        | VARCHAR(n), CHARACTERVARYING(n) | 最大长度为n的变长字符串 |</span><br><span class="line">        | CLOB | 字符串大对象 |</span><br><span class="line">        | BLOB | 二进制大对象 |</span><br><span class="line">        | INT，INTEGER | 长整数（4字节） |</span><br><span class="line">        | SMALLINT | 短整数（2字节） |</span><br><span class="line">        | BIGINT | 大整数（8字节） |</span><br><span class="line">        | NUMERIC(p，d) | 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 |</span><br><span class="line">        | DECIMAL(p, d), DEC(p, d) | 同NUMERIC |</span><br><span class="line">        | REAL | 取决于机器精度的单精度浮点数 |</span><br><span class="line">        | DOUBLE PRECISION | 取决于机器精度的双精度浮点数 |</span><br><span class="line">        | FLOAT(n) | 可选精度的浮点数，精度至少为n位数字 |</span><br><span class="line">        | BOOLEAN | 逻辑布尔量 |</span><br><span class="line">        | DATE | 日期，包含年、月、日，格式为YYYY-MM-DD |</span><br><span class="line">        | TIME | 时间，包含一日的时、分、秒，格式为HH:MM:SS |</span><br><span class="line">        | TIMESTAMP | 时间戳类型 |</span><br><span class="line">        | INTERVAL | 时间间隔类型 |</span><br><span class="line">        </span><br><span class="line">+   修改表</span><br><span class="line">    </span><br><span class="line">    +   ```sql</span><br><span class="line">        ALTER TABLE &lt;表名&gt;</span><br><span class="line">        [ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</span><br><span class="line">        [ ADD &lt;表级完整性约束&gt;]</span><br><span class="line">        [ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ]</span><br><span class="line">        [ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ]</span><br><span class="line">        [ ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ;</span><br><span class="line">        &lt;!--code 4--&gt;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除表</p><ul><li>&#96;&#96;&#96;sql<br>DROP TABLE &lt;表名&gt;［ RESTRICT| CASCADE］<!--code 5--><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">    +   例：为学生-课程数据库中的Student，Course，SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引</span><br><span class="line">        </span><br><span class="line">        &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; INDEX  Stusno &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; Student(Sno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; INDEX  Coucno &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; Course(Cno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UNIQUE&lt;/span&gt; INDEX  SCno &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; SC(Sno &lt;span class=&quot;keyword&quot;&gt;ASC&lt;/span&gt;,Cno &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</span><br><span class="line">        </span><br><span class="line">+   修改索引</span><br><span class="line">    </span><br><span class="line">    +   ```sql</span><br><span class="line">        ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</span><br><span class="line">        &lt;!--code 7--&gt;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除索引</p><ul><li><pre><code class="sql">DROP INDEX &lt;索引名&gt;;&lt;!--code 8--&gt;</code></pre></li></ul></li></ul><h2 id="3-3-数据查询"><a href="#3-3-数据查询" class="headerlink" title="3.3 数据查询"></a><a href="#33-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"></a>3.3 数据查询</h2><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line"> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句)      </span><br><span class="line">                   [<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></tbody></table><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询对象（基本表或视图）</li><li>WHERE子句：指定查询条件</li><li>GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。</li><li>HAVING短语：只有满足指定条件的组才予以输出</li><li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序</li></ul><h3 id="3-4-1-单表查询"><a href="#3-4-1-单表查询" class="headerlink" title="3.4.1 单表查询"></a><a href="#341-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"></a>3.4.1 单表查询</h3><h4 id="1-选择表中的若干列"><a href="#1-选择表中的若干列" class="headerlink" title="1. 选择表中的若干列"></a><a href="#1-%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%88%97"></a>1. 选择表中的若干列</h4><ul><li><p>查询指定列：</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询全体学生的学号与姓名</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student;&nbsp;</span><br></pre></td></tr></tbody></table></li><li><p>查询全部列：</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student; </span><br></pre></td></tr></tbody></table></li><li><p>查询经过计算的值 :</p><table><tbody><tr><td class="code"><pre><span class="line"># 查全体学生的姓名及其出生年份。</span><br><span class="line"><span class="keyword">SELECT</span> Sname, <span class="number">2021</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table></li><li><p>使用列别名改变查询结果的列标题:</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">as</span> NAME,<span class="string">'Year of Birth:'</span> <span class="keyword">as</span> BIRTH, <span class="number">2021</span><span class="operator">-</span>Sage <span class="keyword">as</span> BIRTHDAY, <span class="built_in">LOWER</span>(Sdept) DEPARTMENT</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table><blockquote><p>注：as可写可不写</p></blockquote></li></ul><h4 id="2-选择表中的若干元组"><a href="#2-选择表中的若干元组" class="headerlink" title="2. 选择表中的若干元组"></a><a href="#2-%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%85%83%E7%BB%84"></a>2. 选择表中的若干元组</h4><ul><li><p>消除取值重复的行:</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC; </span><br></pre></td></tr></tbody></table></li><li><p>查询满足条件的元组</p><table><thead><tr><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr><td>比较</td><td>=, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, !&#x3D;, &lt;&gt;, !&gt;, !&lt;; NOT+上述比较运算符</td></tr><tr><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr><td>确定集合</td><td>IN, NOT IN</td></tr><tr><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr><td>多重条件（逻辑运算）</td><td>AND, OR, NOT</td></tr></tbody></table><ul><li><p>比较：</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询考试成绩有不及格的学生的学号。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sn</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade<span class="operator">&lt;</span><span class="number">60</span>; </span><br></pre></td></tr></tbody></table></li><li><p>确定范围（<code>BETWEEN AND, NOT BETWEEN AND</code>）：</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询年龄在<span class="number">20</span><span class="operator">~</span><span class="number">23</span>岁（包括<span class="number">20</span>岁和<span class="number">23</span>岁）之间的学生的姓名、系别和年龄</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>   Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>; </span><br></pre></td></tr></tbody></table></li><li><p>确定集合（<code>IN &lt;值表&gt;, NOT IN &lt;值表&gt;</code>）：</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询计算机科学系（CS）、数学系（MA）和信息系（<span class="keyword">IS</span>）学生的姓名和性别。</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="string">'CS'</span>,<span class="string">'MA’,'</span><span class="keyword">IS</span><span class="string">' );</span></span><br></pre></td></tr></tbody></table></li><li><p>字符匹配(<code>[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]</code>):</p><p>&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和 _</p><ul><li><code>%</code> 代表任意长度（长度可以为0）的字符串<br>例如a%b表示以a开头，以b结尾的任意长度的字符串</li><li><code>_</code>代表任意单个字符。<br>例如a_b表示以a开头，以b结尾的长度为3的任意字符串</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> 匹配串为固定字符串</span><br><span class="line">## 查询学号为<span class="number">201215121</span>的学生的详细情况。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>    </span><br><span class="line"><span class="keyword">FROM</span> Student  </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">LIKE</span> ‘<span class="number">201215121</span><span class="string">' </span></span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">2.</span> 匹配串为含通配符的字符串</span><br><span class="line">## 查询所有姓刘学生的姓名、学号和性别</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Sno, Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">'刘%'</span>;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">3.</span> 使用换码字符将通配符转义为普通字符</span><br><span class="line">## 查询DB_Design课程的课程号和学分。</span><br><span class="line"><span class="keyword">SELECT</span> Cno，Ccredit</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">'DB\_Design'</span> <span class="keyword">ESCAPE</span> <span class="string">'\ '</span> ;</span><br></pre></td></tr></tbody></table></li><li><p>涉及空值的查询(<code>IS NULL 或 IS NOT NULL</code>):</p><blockquote><p>注： “IS”不可以用”&#x3D;”代替</p></blockquote><table><tbody><tr><td class="code"><pre><span class="line"># 查所有有成绩的学生学号和课程号。</span><br><span class="line"><span class="keyword">SELECT</span> Sno，Cno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></tbody></table></li><li><p>多重条件查询:</p><p>逻辑运算符：AND和OR来连接多个查询条件(AND的优先级高于OR; 可以用括号改变优先级)</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询计算机系年龄在<span class="number">20</span>岁以下的学生姓名。</span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">'CS'</span> <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br></pre></td></tr></tbody></table></li></ul></li></ul><h4 id="3-ORDER-BY子句"><a href="#3-ORDER-BY子句" class="headerlink" title="3. ORDER BY子句"></a><a href="#3-order-by%E5%AD%90%E5%8F%A5"></a>3. ORDER BY子句</h4><ul><li>可以按一个或多个属性列排序</li><li>升序(默认)：ASC; 降序：DESC</li><li>对于空值，排序时显示的次序由具体系统实现来决定</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了<span class="number">3</span>号课程的学生的学号及其成绩，查询结果按分数降序排列。</span><br><span class="line"><span class="keyword">SELECT</span> Sno, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">' 3 '</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sdept, Sage <span class="keyword">DESC</span>; </span><br></pre></td></tr></tbody></table><h4 id="4-聚集函数"><a href="#4-聚集函数" class="headerlink" title="4. 聚集函数"></a><a href="#4-%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"></a>4. 聚集函数</h4><blockquote><p>注：聚集函数不能用在WHERE子句中的条件表达式中！！！</p></blockquote><ul><li><p>统计元组个数:</p><p>COUNT(*)</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询学生总人数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span>  Student;&nbsp;</span><br></pre></td></tr></tbody></table></li><li><p>统计一列中值的个数:</p><p>COUNT([DISTINCT|ALL] &lt;列名&gt;)</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了课程的学生人数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></tbody></table></li><li><p>计算一列值的总和（此列必须为数值型）:</p><p>SUM([DISTINCT|ALL] &lt;列名&gt;)</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询学生<span class="number">201215012</span>选修课程的总学分数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Ccredit)</span><br><span class="line"><span class="keyword">FROM</span>  SC,Course</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">'201215012'</span> <span class="keyword">AND</span> SC.Cno<span class="operator">=</span>Course.Cno;</span><br></pre></td></tr></tbody></table><p>​</p></li><li><p>计算一列值的平均值（此列必须为数值型）:</p><p>AVG([DISTINCT|ALL] &lt;列名&gt;)</p><table><tbody><tr><td class="code"><pre><span class="line"># 计算<span class="number">1</span>号课程的学生平均成绩。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table></li><li><p>求一列中的最大值和最小值</p><p>MAX([DISTINCT|ALL] &lt;列名&gt;)</p><p>MIN([DISTINCT|ALL] &lt;列名&gt;)</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修<span class="number">1</span>号课程的学生最高分数。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table></li></ul><h4 id="5-GROUP-BY子句"><a href="#5-GROUP-BY子句" class="headerlink" title="5. GROUP BY子句"></a><a href="#5-group-by%E5%AD%90%E5%8F%A5"></a>5. GROUP BY子句</h4><p>细化聚集函数的作用对象</p><ul><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为一组</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 求各个课程号及相应的选课人数。</span><br><span class="line"><span class="keyword">SELECT</span> Cno，<span class="built_in">COUNT</span>(Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;&nbsp;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了<span class="number">3</span>门以上课程的学生学号。</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span><span class="number">3</span>;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># 查询平均成绩大于等于<span class="number">90</span>分的学生学号和平均成绩</span><br><span class="line"><span class="keyword">SELECT</span>  Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></tbody></table><blockquote><p>注：WHERE子句中不能用聚集函数作为条件表达式！！！</p></blockquote><blockquote><p>注：HAVING短语与WHERE子句的区别：作用对象不同</p><ul><li>WHERE子句作用于基表或视图，从中选择满足条件的元组</li><li>HAVING短语作用于组，从中选择满足条件的组。</li></ul></blockquote><h3 id="3-4-2-连接查询"><a href="#3-4-2-连接查询" class="headerlink" title="3.4.2 连接查询"></a><a href="#342-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"></a>3.4.2 连接查询</h3><ul><li>连接查询：同时涉及两个以上的表的查询</li><li>连接条件或连接谓词：用来连接两个表的条件。一般格式：<br>[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;<br>[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li><li>连接字段：连接谓词中的列名称</li><li>连接条件中的各连接字段类型必须是可比的，但名字不必相同</li></ul><h4 id="1-等值与非等值连接查询"><a href="#1-等值与非等值连接查询" class="headerlink" title="1. 等值与非等值连接查询"></a><a href="#1-%E7%AD%89%E5%80%BC%E4%B8%8E%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"></a>1. 等值与非等值连接查询</h4><ul><li><p>等值连接：连接运算符为&#x3D;</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询每个学生及其选修课程的情</span><br><span class="line"><span class="keyword">SELECT</span> Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></tbody></table></li><li><p>自然连接</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></tbody></table></li><li><p>一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修<span class="number">2</span>号课程且成绩在<span class="number">90</span>分以上的所有学生的学号和姓名。</span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student, SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC.Sno  <span class="keyword">AND</span>  SC.Cno<span class="operator">=</span><span class="string">' 2 '</span> <span class="keyword">AND</span> SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></tbody></table></li></ul><h4 id="2-自身连接"><a href="#2-自身连接" class="headerlink" title="2. 自身连接"></a><a href="#2-%E8%87%AA%E8%BA%AB%E8%BF%9E%E6%8E%A5"></a>2. 自身连接</h4><ul><li>自身连接：一个表与其自己进行连接</li><li>需要给表起别名以示区别</li><li>由于所有属性名都是同名属性，因此必须使用别名前缀</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 查询每一门课的间接先修课（即先修课的先修课）</span><br><span class="line"><span class="keyword">SELECT</span> FIRST.Cno, SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course  <span class="keyword">FIRST</span>, Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br></pre></td></tr></tbody></table><h4 id="3-外连接"><a href="#3-外连接" class="headerlink" title="3. 外连接"></a><a href="#3-%E5%A4%96%E8%BF%9E%E6%8E%A5"></a>3. 外连接</h4><p>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出（左外连接、右外连接）</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询每个学生及其选修课程的情</span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student <span class="keyword">LEFT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> (Student.Sno<span class="operator">=</span>SC.Sno); </span><br></pre></td></tr></tbody></table><h4 id="4-多表连接"><a href="#4-多表连接" class="headerlink" title="4. 多表连接"></a><a href="#4-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5"></a>4. 多表连接</h4><table><tbody><tr><td class="code"><pre><span class="line"># 查询每个学生的学号、姓名、选修的课程名及成绩</span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> Student, SC, Course    <span class="comment">/*多表连接*/</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno <span class="keyword">AND</span> SC.Cno <span class="operator">=</span> Course.Cno;</span><br></pre></td></tr></tbody></table><h3 id="3-4-3-嵌套查询"><a href="#3-4-3-嵌套查询" class="headerlink" title="3.4.3 嵌套查询"></a><a href="#343-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"></a>3.4.3 嵌套查询</h3><ul><li><p>一个SELECT-FROM-WHERE语句称为一个<strong>查询块</strong></p></li><li><p>将一个查询块嵌套在另一个查询块的<strong>WHERE</strong>子句或<strong>HAVING</strong>短语的条件中的查询称为<strong>嵌套查询</strong></p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="comment">/*外层查询/父查询*/</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">          <span class="keyword">FROM</span> SC</span><br><span class="line">          <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">' 2 '</span>);</span><br></pre></td></tr></tbody></table></li><li><p>上层的查询块称为<strong>外层查询</strong>或<strong>父查询</strong><br>下层查询块称为<strong>内层查询</strong>或<strong>子查询</strong></p></li><li><p>SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询</p></li><li><p>子查询的限制：不能使用ORDER BY子句！</p></li><li><p><strong>不相关子查询</strong>：子查询的查询条件不依赖于父查询</p><ul><li>由里向外 逐层处理</li><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></li></ul><h4 id="1-带有IN谓词的子查询"><a href="#1-带有IN谓词的子查询" class="headerlink" title="1. 带有IN谓词的子查询"></a><a href="#1-%E5%B8%A6%E6%9C%89in%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>1. 带有IN谓词的子查询</h4><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了课程名为“信息系统”的学生学号和姓名</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname# step3: 最后在Student关系中取出Sno和Sname</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> Sno# step2: 然后在SC关系中找出选修了<span class="number">3</span>号课程的学生学号</span><br><span class="line"> <span class="keyword">FROM</span> SC                         </span><br><span class="line"> <span class="keyword">WHERE</span>  Cno <span class="keyword">IN</span></span><br><span class="line"> (<span class="keyword">SELECT</span> Cno# step1: 首先在Course关系中找出“信息系统”的课程号(<span class="number">3</span>号)</span><br><span class="line">         <span class="keyword">FROM</span> Course           </span><br><span class="line">         <span class="keyword">WHERE</span> Cname<span class="operator">=</span> <span class="string">'信息系统'</span>)</span><br><span class="line">        );</span><br></pre></td></tr></tbody></table><h4 id="2-带有比较运算符的子查询"><a href="#2-带有比较运算符的子查询" class="headerlink" title="2. 带有比较运算符的子查询"></a><a href="#2-%E5%B8%A6%E6%9C%89%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>2. 带有比较运算符的子查询</h4><ul><li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，&#x3D;，&gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&lt; &gt;）</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 找出每个学生超过他选修课程平均成绩的课程号。</span><br><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC  x</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> AVG（Grade） </span><br><span class="line">        <span class="keyword">FROM</span>  SC y</span><br><span class="line">               <span class="keyword">WHERE</span> y.Sno<span class="operator">=</span>x.Sno);</span><br></pre></td></tr></tbody></table><h4 id="3-带有ANY（SOME）或ALL谓词的子查询"><a href="#3-带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="3. 带有ANY（SOME）或ALL谓词的子查询"></a><a href="#3-%E5%B8%A6%E6%9C%89anysome%E6%88%96all%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>3. 带有ANY（SOME）或ALL谓词的子查询</h4><ul><li><p>ANY: 某个; ALL: 所有</p></li><li><p>使用ANY或ALL谓词时必须同时使用比较运算:</p><ul><li><code>&gt; ANY</code> 大于子查询结果中的某个值</li><li><code>&gt; ALL</code> 大于子查询结果中的所有值</li><li><code>!=（或&lt;&gt;）ANY</code> 不等于子查询结果中的某个值</li><li><code>!=（或&lt;&gt;）ALL</code> 不等于子查询结果中的任何一个值</li><li>…</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名和年龄</span><br><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span>  Sage</span><br><span class="line">                  <span class="keyword">FROM</span>    Student</span><br><span class="line">                  <span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">' CS '</span>)</span><br><span class="line">      <span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> ‘CS <span class="string">';</span></span><br></pre></td></tr></tbody></table></li></ul><h4 id="4-带有EXISTS谓词的子查询"><a href="#4-带有EXISTS谓词的子查询" class="headerlink" title="4. 带有EXISTS谓词的子查询"></a><a href="#4-%E5%B8%A6%E6%9C%89exists%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"></a>4. 带有EXISTS谓词的子查询</h4><ul><li><strong>EXISTS</strong>谓词<ul><li>存在量词 ∃\exist∃</li><li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。<ul><li>若内层查询结果非空，则外层的WHERE子句返回真值</li><li>若内层查询结果为空，则外层的WHERE子句返回假值</li></ul></li></ul></li><li><strong>NOT EXISTS</strong>谓词</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 查询没有选修<span class="number">1</span>号课程的学生姓名。</span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">          (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> SC</span><br><span class="line">           <span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">'1'</span>);</span><br></pre></td></tr></tbody></table><ul><li><p>不同形式的查询间的替换</p><ul><li>一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换</li><li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li></ul></li><li><p>用EXISTS&#x2F;NOT EXISTS实现<strong>全称量词</strong></p><ul><li><p>SQL语言中没有全称量词 $\forall $</p></li><li><p>可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：</p><p>(∀x)P≡(∃x(¬P))(\forall x)P \equiv (\exist x (\lnot P)) (∀x)P≡(∃x(¬P))</p></li></ul></li><li><p>用EXISTS&#x2F;NOT EXISTS实现逻辑<strong>蕴涵</strong></p></li><li><p>SQL语言中没有蕴涵（Implication）逻辑运算</p></li><li><p>可以利用谓词演算将逻辑蕴涵谓词等价转换为:</p><p>p \to q \equiv \lnot p \or q</p></li></ul><h3 id="3-4-4-集合查询"><a href="#3-4-4-集合查询" class="headerlink" title="3.4.4 集合查询"></a><a href="#344-%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2"></a>3.4.4 集合查询</h3><ul><li><p>集合操作的种类</p><ul><li>并操作 <strong>UNION</strong></li><li>交操作 <strong>INTERSECT</strong></li><li>差操作 <strong>EXCEPT</strong></li></ul></li><li><p>参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询选修了课程<span class="number">1</span>或者选修了课程<span class="number">2</span>的学生。</span><br><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">' 1 '</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">' 2 '</span>;</span><br></pre></td></tr></tbody></table></li></ul><h3 id="3-4-5-基于派生表的查询"><a href="#3-4-5-基于派生表的查询" class="headerlink" title="3.4.5 基于派生表的查询"></a><a href="#345-%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"></a>3.4.5 基于派生表的查询</h3><ul><li><p>子查询出现在FROM子句中，此时子查询生成的临时派生表（Derived Table）成为主查询的查询对象</p><table><tbody><tr><td class="code"><pre><span class="line"># 找出每个学生超过他自己选修课程平均成绩的课程号</span><br><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC, (<span class="keyword">SELECT</span> Sno, <span class="built_in">Avg</span>(Grade) </span><br><span class="line">  <span class="keyword">FROM</span> SC</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno) <span class="keyword">AS</span> Avg_sc(avg_sno,avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno <span class="operator">=</span> Avg_sc.avg_sno <span class="keyword">and</span> SC.Grade <span class="operator">&gt;=</span>Avg_sc.avg_grade</span><br></pre></td></tr></tbody></table></li><li><p>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性。</p><table><tbody><tr><td class="code"><pre><span class="line"># 查询所有选修了<span class="number">1</span>号课程的学生姓名，可以用如下查询完成：</span><br><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">' 1 '</span>) <span class="keyword">AS</span> SC1</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC1.Sno;</span><br></pre></td></tr></tbody></table></li></ul><h2 id="3-4-数据更新"><a href="#3-4-数据更新" class="headerlink" title="3.4 数据更新"></a><a href="#34-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"></a>3.4 数据更新</h2><h3 id="3-4-1-插入数据"><a href="#3-4-1-插入数据" class="headerlink" title="3.4.1 插入数据"></a><a href="#341-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"></a>3.4.1 插入数据</h3><h4 id="1-插入元组"><a href="#1-插入元组" class="headerlink" title="1. 插入元组"></a><a href="#1-%E6%8F%92%E5%85%A5%E5%85%83%E7%BB%84"></a>1. 插入元组</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>属性列<span class="number">2</span> <span class="operator">&gt;</span>…)]</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>]… );</span><br></pre></td></tr></tbody></table><ul><li>INTO子句:<ul><li>指定要插入数据的表名及属性列</li><li>属性列的顺序可与表定义中的顺序不一致</li><li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致</li><li>指定部分属性列：插入的元组在其余属性列上取空值</li></ul></li><li>VALUES子句：<ul><li>提供的值必须与INTO子句匹配<ul><li>值的个数</li><li>值的类型</li></ul></li></ul></li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 插入一条选课记录（ <span class="string">'200215128'</span>,<span class="string">'1 '</span>）。</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> SC(Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'201215128 '</span>,<span class="string">'1'</span>); # 关系数据库管理系统将在新插入记录的Grade列上自动赋空值</span><br></pre></td></tr></tbody></table><h4 id="2-插入子查询结果（可以一次插入多个元组）"><a href="#2-插入子查询结果（可以一次插入多个元组）" class="headerlink" title="2. 插入子查询结果（可以一次插入多个元组）"></a><a href="#2-%E6%8F%92%E5%85%A5%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8F%AF%E4%BB%A5%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84"></a>2. 插入子查询结果（可以一次插入多个元组）</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>  [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>…  )]</span><br><span class="line">子查询;</span><br></pre></td></tr></tbody></table><ul><li>子查询中 SELECT子句目标列 必须与 INTO子句 匹配<ul><li>值的个数</li><li>值的类型</li></ul></li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 对每一个系，求学生的平均年龄，并把结果存入数据库</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Dept_age(Sdept,Avg_age)</span><br><span class="line"><span class="keyword">SELECT</span> Sdept，<span class="built_in">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sdept;</span><br></pre></td></tr></tbody></table><ul><li>关系数据库管理系统在执行插入语句时会检查所插元组是否破坏表上已定义的完整性规则:实体完整性; 参照完整性; 用户定义的完整性(NOT NULL约束, UNIQUE约束, 值域约束)</li></ul><h3 id="3-4-2-修改数据"><a href="#3-4-2-修改数据" class="headerlink" title="3.4.2 修改数据"></a><a href="#342-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"></a>3.4.2 修改数据</h3><table><tbody><tr><td class="code"><pre><span class="line">UPDATE  <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span>  <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>]…</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></tbody></table><h4 id="1-修改某一个元组的值"><a href="#1-修改某一个元组的值" class="headerlink" title="1. 修改某一个元组的值"></a><a href="#1-%E4%BF%AE%E6%94%B9%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>1. 修改某一个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将学生<span class="number">201215121</span>的年龄改为<span class="number">22</span>岁</span><br><span class="line">UPDATE Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">'201215121'</span>;</span><br></pre></td></tr></tbody></table><h4 id="2-修改多个元组的值"><a href="#2-修改多个元组的值" class="headerlink" title="2. 修改多个元组的值"></a><a href="#2-%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>2. 修改多个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将所有学生的年龄增加<span class="number">1</span>岁</span><br><span class="line">UPDATE Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span>Sage<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></tbody></table><h4 id="3-带子查询的修改语句"><a href="#3-带子查询的修改语句" class="headerlink" title="3. 带子查询的修改语句"></a><a href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BF%AE%E6%94%B9%E8%AF%AD%E5%8F%A5"></a>3. 带子查询的修改语句</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将计算机科学系全体学生的成绩置零。</span><br><span class="line">UPDATE SC</span><br><span class="line"><span class="keyword">SET</span> Grade<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">(SELETE Sno</span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">'CS'</span> );</span><br></pre></td></tr></tbody></table><ul><li>关系数据库管理系统在执行修改语句时会检查修改操作是否破坏表上已定义的完整性规则</li></ul><h3 id="3-4-3-删除数据"><a href="#3-4-3-删除数据" class="headerlink" title="3.4.3 删除数据"></a><a href="#343-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"></a>3.4.3 删除数据</h3><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></tbody></table><h4 id="1-删除某一个元组的值"><a href="#1-删除某一个元组的值" class="headerlink" title="1. 删除某一个元组的值"></a><a href="#1-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>1. 删除某一个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 删除学号为<span class="number">201215128</span>的学生记录。</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span> <span class="number">201215128</span> <span class="string">';</span></span><br></pre></td></tr></tbody></table><h4 id="2-删除多个元组的值"><a href="#2-删除多个元组的值" class="headerlink" title="2. 删除多个元组的值"></a><a href="#2-%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%85%83%E7%BB%84%E7%9A%84%E5%80%BC"></a>2. 删除多个元组的值</h4><table><tbody><tr><td class="code"><pre><span class="line"># 删除所有的学生选课记录。</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></tbody></table><h4 id="3-带子查询的删除语句"><a href="#3-带子查询的删除语句" class="headerlink" title="3. 带子查询的删除语句"></a><a href="#3-%E5%B8%A6%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5"></a>3. 带子查询的删除语句</h4><table><tbody><tr><td class="code"><pre><span class="line"># 删除计算机科学系所有学生的选课记录。</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sno  <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span>  Sno</span><br><span class="line">     <span class="keyword">FROM</span>   Student</span><br><span class="line">     <span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">'CS'</span>) ;</span><br></pre></td></tr></tbody></table><h2 id="3-5-空值的处理"><a href="#3-5-空值的处理" class="headerlink" title="3.5 空值的处理"></a><a href="#35-%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86"></a>3.5 空值的处理</h2><ul><li>判断：<code>IS NULL</code>或<code>IS NOT NULL</code></li><li>约束条件：属性定义（或者域定义）中<ul><li>有NOT NULL约束条件的不能取空值</li><li>加了UNIQUE限制的属性不能取空值</li><li>码属性不能取空值</li></ul></li><li>运算：<ul><li>空值与另一个值（包括另一个空值）的算术运算的结果为空值</li><li>空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。</li><li>有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑</li></ul></li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 选出选修<span class="number">1</span>号课程的不及格的学生以及缺考的学生。</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">'1'</span> <span class="keyword">AND</span> (Grade<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">OR</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></tbody></table><h2 id="3-6-视图"><a href="#3-6-视图" class="headerlink" title="3.6 视图"></a><a href="#36-%E8%A7%86%E5%9B%BE"></a>3.6 视图</h2><ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li></ul><h3 id="3-6-1-定义视图"><a href="#3-6-1-定义视图" class="headerlink" title="3.6.1 定义视图"></a><a href="#361-%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE"></a>3.6.1 定义视图</h3><h4 id="1-建立视图"><a href="#1-建立视图" class="headerlink" title="1. 建立视图"></a><a href="#1-%E5%BB%BA%E7%AB%8B%E8%A7%86%E5%9B%BE"></a>1. 建立视图</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> </span><br><span class="line"> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>  [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>  [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]…)]</span><br><span class="line"><span class="keyword">AS</span>  <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span>  <span class="keyword">CHECK</span>  OPTION];</span><br></pre></td></tr></tbody></table><ul><li><code>WITH CHECK OPTION</code>: 对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</li><li>子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现。</li><li>关系数据库管理系统执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句。</li><li>在对视图查询时，按视图的定义从基本表中将数据查出。</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> 行列子集视图(一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码)</span><br><span class="line">## 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">'IS'</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">2.</span> 基于多个基表的视图</span><br><span class="line">## 建立信息系选修了<span class="number">1</span>号课程的学生的视图（包括学号、姓名、成绩）。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">'IS'</span> <span class="keyword">AND</span> Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span> SC.Cno<span class="operator">=</span> <span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">3.</span> 基于视图的视图</span><br><span class="line">## 建立信息系选修了<span class="number">1</span>号课程且成绩在<span class="number">90</span>分以上的学生的视图。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  IS_S1</span><br><span class="line"><span class="keyword">WHERE</span>  Grade<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># <span class="number">4.</span> 带表达式的视图</span><br><span class="line">## 定义一个反映学生出生年份的视图。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,<span class="number">2014</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># 分组视图</span><br><span class="line">## 将学生的学号及平均成绩定义为一个视图</span><br><span class="line">CREAT  <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line"><span class="keyword">AS</span>  </span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></tbody></table><h4 id="2-删除视图"><a href="#2-删除视图" class="headerlink" title="2. 删除视图"></a><a href="#2-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"></a>2. 删除视图</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span>  <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE];</span><br></pre></td></tr></tbody></table><ul><li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li><li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li></ul><h3 id="3-6-2-查询视图"><a href="#3-6-2-查询视图" class="headerlink" title="3.6.2 查询视图"></a><a href="#362-%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE"></a>3.6.2 查询视图</h3><ul><li>用户角度：查询视图与查询基本表相同</li><li>关系数据库管理系统实现视图查询的方法：<ul><li>视图消解法（View Resolution）：进行有效性检查；转换成等价的对基本表的查询；执行修正后的查询</li><li>视图消解法的局限：有些情况下，视图消解法不能生成正确的查询。（比如：聚集函数不能用于WHERE子句，需转换成HAVING）</li></ul></li></ul><h3 id="3-6-3-更新视图"><a href="#3-6-3-更新视图" class="headerlink" title="3.6.3 更新视图"></a><a href="#363-%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"></a>3.6.3 更新视图</h3><ul><li>允许对行列子集视图进行更新</li><li>对其他类型视图的更新不同系统有不同限制</li></ul><h3 id="3-6-4-视图的作用"><a href="#3-6-4-视图的作用" class="headerlink" title="3.6.4 视图的作用"></a><a href="#364-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"></a>3.6.4 视图的作用</h3><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul><h1 id="Chapter-4-数据库安全性"><a href="#Chapter-4-数据库安全性" class="headerlink" title="Chapter 4 数据库安全性"></a><a href="#chapter-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7"></a>Chapter 4 数据库安全性</h1><ul><li><p>数据库的不安全因素</p><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul></li><li><p>安全标准:TCSEC&#x2F;TDI安全级别划分</p><table><thead><tr><th>安 全 级 别</th><th>定义</th></tr></thead><tbody><tr><td>A1</td><td>验证设计（Verified Design）</td></tr><tr><td>B3</td><td>安全域（Security Domains）</td></tr><tr><td>B2</td><td>结构化保护（Structural Protection）</td></tr><tr><td>B1</td><td>标记安全保护（Labeled Security Protection）</td></tr><tr><td>C2</td><td>受控的存取保护（Controlled Access Protection）</td></tr><tr><td>C1</td><td>自主安全保护（Discretionary Security Protection）</td></tr><tr><td>D</td><td>最小保护（Minimal Protection）</td></tr></tbody></table></li><li><p>计算机系统中，安全措施是一级一级层层设置</p><p><img src="https://i.loli.net/2021/09/04/wGJx7iAsvb51tYV.png" alt="image-20210904162607592"></p></li><li><p>数据库安全性控制的常用方法</p><ul><li><p>用户标识和鉴定: 静态口令鉴别, 动态口令鉴别, 生物特征鉴别,智能卡鉴别</p></li><li><p>存取控制: 定义用户权限，并将用户权限登记到数据字典中; 合法权限检查</p><ul><li>自主存取控制方法: 通过 SQL 的GRANT 语句和REVOKE 语句实现</li><li>强制存取控制方法</li></ul></li><li><p>视图</p></li><li><p>审计</p><ul><li>启用一个专用的审计日志（Audit Log）, 将用户对数据库的所有操作记录在上面</li><li>AUDIT语句：设置审计功能</li><li>NOAUDIT语句：取消审计功能</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 对修改SC表结构或修改SC表数据的操作进行审计</span><br><span class="line">AUDIT <span class="keyword">ALTER</span>,UPDATE  </span><br><span class="line"><span class="keyword">ON</span>  SC;</span><br><span class="line"></span><br><span class="line"># 取消对SC表的一切审计</span><br><span class="line">NOAUDIT  <span class="keyword">ALTER</span>,UPDATE  </span><br><span class="line"><span class="keyword">ON</span>  SC;</span><br></pre></td></tr></tbody></table></li><li><p>数据加密: 存储加密; 传输加密</p></li></ul></li><li><p>授权</p><ul><li><p><code>GRANT</code>:</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]... </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></tbody></table><ul><li>发出GRANT：数据库管理员, 数据库对象创建者（即属主Owner）,拥有该权限的用户</li><li>按受权限的用户: 一个或多个具体用户, PUBLIC（即全体用户）</li><li><code>WITH GRANT OPTION</code>子句:<ul><li>指定：可以再授予</li><li>没有指定：不能传播</li></ul></li><li>不允许循环授权</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 把对Student表和Course表的全部权限授予用户U2和U3</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student,Course </span><br><span class="line"><span class="keyword">TO</span> U2,U3;</span><br><span class="line"></span><br><span class="line"># 把对表SC的查询权限授予所有用户</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> PUBLIC;</span><br><span class="line"></span><br><span class="line"># 把查询Student表和修改学生学号的权限授给用户U4</span><br><span class="line"><span class="keyword">GRANT</span> UPDATE(Sno), <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">TO</span> U4;</span><br><span class="line"></span><br><span class="line"># 把对表SC的<span class="keyword">INSERT</span>权限授予U5用户，并允许他再将此权限授予其他用户</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> U5</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></tbody></table></li><li><p><code>REVOKE</code></p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]... </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...[CASCADE <span class="operator">|</span> RESTRICT];</span><br></pre></td></tr></tbody></table><ul><li>授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 把用户U4修改学生学号的权限收回</span><br><span class="line"><span class="keyword">REVOKE</span> UPDATE(Sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">FROM</span> U4;</span><br><span class="line"></span><br><span class="line"># 收回所有用户对表SC的查询权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">FROM</span> PUBLIC;</span><br><span class="line"></span><br><span class="line"># 把用户U5对SC表的<span class="keyword">INSERT</span>权限收回</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">FROM</span> U5 CASCADE;</span><br></pre></td></tr></tbody></table></li><li><p>创建数据库模式的权限（数据库管理员在创建用户时实现）</p><table><tbody><tr><td class="code"><pre><span class="line"># <span class="keyword">CREATE</span> <span class="keyword">USER</span>语句格式(不是<span class="keyword">SQL</span>标准，各个系统的实现不同)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span> </span><br><span class="line">[<span class="keyword">WITH</span>] [DBA<span class="operator">|</span>RESOURCE<span class="operator">|</span><span class="keyword">CONNECT</span>];</span><br></pre></td></tr></tbody></table><ul><li><p>只有系统的超级用户才有权创建一个新的数据库用户</p></li><li><p>新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA</p><table><thead><tr><th></th><th>CREATE USER</th><th>CREATE SCHEMA</th><th>CREATE TABLE</th><th>登录数据库，执行数据查询和操作</th></tr></thead><tbody><tr><td>DBA</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>RESOURCE</td><td>❌</td><td>❌</td><td>✔</td><td>✔</td></tr><tr><td>CONNECT</td><td>❌</td><td>❌</td><td>❌</td><td>✔(但必须拥有相应权限)</td></tr></tbody></table></li></ul></li></ul></li><li><p>数据库角色</p><ul><li><p>角色的创建</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></li><li><p>给角色授权</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]… </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span>对象名  </span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]…</span><br></pre></td></tr></tbody></table></li><li><p>将一个角色授予其他的角色或用户</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>角色<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="number">2</span><span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="number">3</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span>]… </span><br><span class="line">[<span class="keyword">WITH</span> ADMIN OPTION]# 指定了<span class="keyword">WITH</span> ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色</span><br></pre></td></tr></tbody></table></li><li><p>角色权限的收回</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]…</span><br></pre></td></tr></tbody></table></li></ul></li></ul><h1 id="Chapter-5-数据库完整性"><a href="#Chapter-5-数据库完整性" class="headerlink" title="Chapter 5 数据库完整性"></a><a href="#chapter-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"></a>Chapter 5 数据库完整性</h1><h2 id="5-1-实体完整性"><a href="#5-1-实体完整性" class="headerlink" title="5.1 实体完整性"></a><a href="#51-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"></a>5.1 实体完整性</h2><h3 id="5-1-1-实体完整性定义"><a href="#5-1-1-实体完整性定义" class="headerlink" title="5.1.1 实体完整性定义"></a><a href="#511-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E5%AE%9A%E4%B9%89"></a>5.1.1 实体完整性定义</h3><p>CREATE TABLE 中用<code>PRIMARY KEY</code>定义</p><h4 id="（1）在列级定义主码"><a href="#（1）在列级定义主码" class="headerlink" title="（1）在列级定义主码"></a><a href="#1%E5%9C%A8%E5%88%97%E7%BA%A7%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81"></a>（1）在列级定义主码</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将Student表中的Sno属性定义为码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">( Sno  <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  Sname  <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,     </span><br><span class="line">  Ssex  <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">  Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">  Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table><h4 id="（2）在表级定义主码"><a href="#（2）在表级定义主码" class="headerlink" title="（2）在表级定义主码"></a><a href="#2%E5%9C%A8%E8%A1%A8%E7%BA%A7%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81"></a>（2）在表级定义主码</h4><table><tbody><tr><td class="code"><pre><span class="line"># 将SC表中的Sno，Cno属性组定义为码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">( Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">      Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">      Grade <span class="type">SMALLINT</span>,</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (Sno,Cno)    <span class="comment">/*只能在表级定义主码*/</span></span><br><span class="line">    ); </span><br></pre></td></tr></tbody></table><h3 id="5-1-2-实体完整性检查和违约处理"><a href="#5-1-2-实体完整性检查和违约处理" class="headerlink" title="5.1.2 实体完整性检查和违约处理"></a><a href="#512-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"></a>5.1.2 实体完整性检查和违约处理</h3><ul><li>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：<ul><li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li></ul></li><li>检查记录中主码值是否唯一的一种方法是进行<strong>全表扫描</strong>，依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同</li><li>为避免对基本表进行全表扫描（耗时），RDBMS核心一般都在主码上自动建立一个索引（B+树索引）</li></ul><h2 id="5-2-参照完整性"><a href="#5-2-参照完整性" class="headerlink" title="5.2 参照完整性"></a><a href="#52-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7"></a>5.2 参照完整性</h2><h3 id="5-2-1-参照完整性定义"><a href="#5-2-1-参照完整性定义" class="headerlink" title="5.2.1 参照完整性定义"></a><a href="#521-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%AE%9A%E4%B9%89"></a>5.2.1 参照完整性定义</h3><ul><li>在CREATE TABLE中用<code>FOREIGN KEY</code>短语定义哪些列为外码</li><li>用<code>REFERENCES</code>短语指明这些外码参照哪些表的主码</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 关系SC中（Sno，Cno）是主码。Sno，Cno分别参照Student表的主码和Course表的主码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">( Sno <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  Cno <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">  Grade <span class="type">SMALLINT</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (Sno, Cno),   <span class="comment">/*在表级定义实体完整性*/</span></span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),  <span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)<span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table><h3 id="5-2-2-参照完整性检查和违约处理"><a href="#5-2-2-参照完整性检查和违约处理" class="headerlink" title="5.2.2 参照完整性检查和违约处理"></a><a href="#522-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BF%9D%E7%BA%A6%E5%A4%84%E7%90%86"></a>5.2.2 参照完整性检查和违约处理</h3><table><thead><tr><th>被参照表</th><th></th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr><td>（可能破坏参照完整性）</td><td>←\leftarrow←</td><td>插入元组</td><td>拒绝</td></tr><tr><td>（可能破坏参照完整性）</td><td>←\leftarrow←</td><td>修改外码值</td><td>拒绝</td></tr><tr><td>删除元组</td><td>→\rightarrow→</td><td>（可能破坏参照完整性）</td><td>拒绝&#x2F;级连删除&#x2F;设置为空值</td></tr><tr><td>修改主码值</td><td>→\rightarrow→</td><td>（可能破坏参照完整性）</td><td>拒绝&#x2F;级连删除&#x2F;设置为空值</td></tr></tbody></table><ul><li>参照完整性违约处理<ul><li>拒绝（NO ACTION）执行<br>不允许该操作执行。该策略一般设置为默认策略</li><li>级联（CASCADE）操作<br>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组</li><li>设置为空值（SET-NULL）<br>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</li></ul></li></ul><table><tbody><tr><td class="code"><pre><span class="line"> # 显式说明参照完整性的违约处理示例</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">    ( Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">      Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">      Grade <span class="type">SMALLINT</span>,</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY(Sno,Cno)，</span><br><span class="line">      <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno) </span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE<span class="comment">/*级联删除SC表中相应的元组*/</span></span><br><span class="line">      <span class="keyword">ON</span> UPDATE CASCADE, <span class="comment">/*级联更新SC表中相应的元组*/</span></span><br><span class="line">      <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION<span class="comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span></span><br><span class="line">      <span class="keyword">ON</span> UPDATE CASCADE<span class="comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span></span><br><span class="line">     );</span><br></pre></td></tr></tbody></table><h2 id="5-3-用户定义的完整性"><a href="#5-3-用户定义的完整性" class="headerlink" title="5.3 用户定义的完整性"></a><a href="#53-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"></a>5.3 用户定义的完整性</h2><ul><li>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求</li><li>关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</li></ul><h3 id="5-3-1-属性上的约束条件"><a href="#5-3-1-属性上的约束条件" class="headerlink" title="5.3.1 属性上的约束条件"></a><a href="#531-%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"></a>5.3.1 属性上的约束条件</h3><ul><li><p>CREATE TABLE时定义属性上的约束条件</p><ul><li><p>列值非空（<code>NOT NULL</code>）</p></li><li><p>列值唯一（<code>UNIQUE</code>）</p></li><li><p>检查列值是否满足一个条件表达式（<code>CHECK</code>）:</p><table><tbody><tr><td class="code"><pre><span class="line"># Student表的Ssex只允许取“男”或“女”。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    ( Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">      Sname <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                     </span><br><span class="line">      Ssex <span class="type">CHAR</span>(<span class="number">2</span>)  <span class="keyword">CHECK</span> （Ssex <span class="keyword">IN</span> （‘男’,’女’））, <span class="comment">/*性别属性Ssex只允许取'男'或'女' */</span></span><br><span class="line">      Sage <span class="type">SMALLINT</span>,</span><br><span class="line">      Sdept <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></li></ul></li><li><p>属性上的约束条件检查和违约处理</p><ul><li>插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足</li><li>不满足则拒绝执行</li></ul></li></ul><h3 id="5-3-2-元组上的约束条件"><a href="#5-3-2-元组上的约束条件" class="headerlink" title="5.3.2 元组上的约束条件"></a><a href="#532-%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"></a>5.3.2 元组上的约束条件</h3><ul><li>在CREATE TABLE时可以用<code>CHECK</code>短语定义元组上的约束条件，即元组级的限制; 元组级的限制可以设置不同属性之间的取值的相互约束条件</li></ul><table><tbody><tr><td class="code"><pre><span class="line"># 当学生的性别是男时，其名字不能以Ms.打头。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    ( Sno    <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">      Sname  <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      Ssex   <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">      Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">      Sdept  <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (Sno),</span><br><span class="line">      <span class="keyword">CHECK</span> (Ssex<span class="operator">=</span><span class="string">'女'</span> <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">'Ms.%'</span>) <span class="comment">/*定义了元组中Sname和Ssex两个属性值之间的约束条件*/</span></span><br><span class="line">    );</span><br></pre></td></tr></tbody></table><ul><li>元组上的约束条件检查和违约处理<ul><li>插入元组或修改属性的值时，关系数据库管理系统检查元组上的约束条件是否被满足</li><li>不满足则拒绝执行</li></ul></li></ul><h2 id="5-4-完整性约束命名字句"><a href="#5-4-完整性约束命名字句" class="headerlink" title="5.4 完整性约束命名字句"></a><a href="#54-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%91%BD%E5%90%8D%E5%AD%97%E5%8F%A5"></a>5.4 完整性约束命名字句</h2><ul><li><p>完整性约束命名子句</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束条件名<span class="operator">&gt;</span> <span class="operator">&lt;</span>完整性约束条件<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table><p>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</p><table><tbody><tr><td class="code"><pre><span class="line"># 建立学生登记表Student，要求学号在<span class="number">90000</span><span class="operator">~</span><span class="number">99999</span>之间，姓名不能取空值，年龄小于<span class="number">30</span>，性别只能是“男”或“女”。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">     ( Sno  <span class="type">NUMERIC</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">90000</span> <span class="keyword">AND</span> <span class="number">99999</span>),</span><br><span class="line">       Sname  <span class="type">CHAR</span>(<span class="number">20</span>)  </span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">       Sage  <span class="type">NUMERIC</span>(<span class="number">3</span>)</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;</span> <span class="number">30</span>),</span><br><span class="line">       Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> ( ‘男’,<span class="string">'女'</span>)),</span><br><span class="line">       <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">     );</span><br></pre></td></tr></tbody></table></li><li><p>修改表中的完整性限制：<code>ALTER TABLE</code>语句</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C4;</span><br></pre></td></tr></tbody></table></li></ul><h2 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a><a href="#56-%E6%96%AD%E8%A8%80"></a>5.6 断言</h2><ul><li>SQL中，可以使用<code>CREATE ASSERTION</code>语句，通过声明性断言来指定更具一般性的约束。</li><li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li><li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li></ul><h4 id="1-创建断言"><a href="#1-创建断言" class="headerlink" title="1. 创建断言"></a><a href="#1-%E5%88%9B%E5%BB%BA%E6%96%AD%E8%A8%80"></a>1. 创建断言</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span></span><br><span class="line"># <span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span>中的约束条件与<span class="keyword">WHERE</span>子句的条件表达式类似</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"># 限制数据库课程最多<span class="number">60</span>名学生选修</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="number">60</span> <span class="operator">&gt;=</span> ( <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">   <span class="keyword">from</span> Course,SC</span><br><span class="line">   <span class="keyword">Where</span> SC.Cno<span class="operator">=</span>Course.Cno <span class="keyword">and</span> Course.Cname <span class="operator">=</span><span class="string">'数据库'</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table><h4 id="2-删除断言"><a href="#2-删除断言" class="headerlink" title="2. 删除断言"></a><a href="#2-%E5%88%A0%E9%99%A4%E6%96%AD%E8%A8%80"></a>2. 删除断言</h4><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span>;</span><br></pre></td></tr></tbody></table><h2 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a><a href="#57-%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7 触发器</h2><h3 id="5-7-1-定义触发器"><a href="#5-7-1-定义触发器" class="headerlink" title="5.7.1 定义触发器"></a><a href="#571-%E5%AE%9A%E4%B9%89%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7.1 定义触发器</h3><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span>  </span><br><span class="line">{BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span><span class="operator">&lt;</span>变量<span class="operator">&gt;</span></span><br><span class="line">FOR EACH  {ROW | STATEMENT}</span><br><span class="line">[<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>]<span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table><h3 id="5-7-2-激活触发器"><a href="#5-7-2-激活触发器" class="headerlink" title="5.7.2 激活触发器"></a><a href="#572-%E6%BF%80%E6%B4%BB%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7.2 激活触发器</h3><ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序:<br>（1） 执行该表上的BEFORE触发器;<br>（2） 激活触发器的SQL语句;<br>（3） 执行该表上的AFTER触发器。</li></ul><h3 id="5-7-3-删除触发器"><a href="#5-7-3-删除触发器" class="headerlink" title="5.7.3 删除触发器"></a><a href="#573-%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"></a>5.7.3 删除触发器</h3><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></tbody></table><ul><li>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</li></ul><h1 id="Chapter-6-关系数据理论"><a href="#Chapter-6-关系数据理论" class="headerlink" title="Chapter 6 关系数据理论"></a><a href="#chapter-6-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"></a>Chapter 6 关系数据理论</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a><a href="#61-%E6%A6%82%E8%BF%B0"></a>6.1 概述</h2><ul><li><p>关系模式由五部分组成，是一个五元组：R(U,D,DOM,F)R(U, D, DOM, F)R(U,D,DOM,F)</p><ul><li>关系名R是符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U中的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为属性组U上的一组数据依赖</li></ul></li><li><p>数据依赖</p><ul><li>是一个关系内部 属性与属性之间的一种约束关系<ul><li>通过属性间值的相等与否体现出来的数据间相互联系</li></ul></li><li>是现实世界属性间相互联系的抽象</li><li>是数据内在的性质, 是语义的体现</li><li>数据依赖的主要类型<ul><li>函数依赖（Functional Dependency，简记为FD）</li><li>多值依赖（Multi-Valued Dependency，简记为MVD）</li></ul></li></ul></li></ul><h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a><a href="#62-%E8%A7%84%E8%8C%83%E5%8C%96"></a>6.2 规范化</h2><h3 id="6-2-1-函数依赖"><a href="#6-2-1-函数依赖" class="headerlink" title="6.2.1 函数依赖"></a><a href="#621-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>6.2.1 函数依赖</h3><h4 id="1-函数依赖"><a href="#1-函数依赖" class="headerlink" title="1. 函数依赖"></a><a href="#1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>1. 函数依赖</h4><ul><li><p>一个关系中，两组属性之间的 取值约束</p></li><li><p>定义：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称“X函数确定Y”或“Y函数依赖于X”，记作X→YX \rightarrow YX→Y。</p></li><li><p>若X→YX→YX→Y，并且Y→XY \rightarrow XY→X, 则记为X←→YX \leftarrow \rightarrow YX←→Y。</p></li><li><p>X：决定因素； Y：依赖因素</p></li></ul><h4 id="2-平凡函数依赖与非平凡函数依赖"><a href="#2-平凡函数依赖与非平凡函数依赖" class="headerlink" title="2. 平凡函数依赖与非平凡函数依赖"></a><a href="#2-%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%9D%9E%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>2. 平凡函数依赖与非平凡函数依赖</h4><ul><li>非平凡的函数依赖：X→YX \rightarrow YX→Y，但Y⊊XY\subsetneq XY⊊X。</li><li>平凡的函数依赖：X→YX \rightarrow YX→Y，但Y⊆XY \subseteq XY⊆X。(任一R必成立)</li></ul><h4 id="3-完全函数依赖与部分函数依赖"><a href="#3-完全函数依赖与部分函数依赖" class="headerlink" title="3. 完全函数依赖与部分函数依赖"></a><a href="#3-%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%B8%8E%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>3. 完全函数依赖与部分函数依赖</h4><ul><li><strong>完全函数依赖</strong>：X→YX \rightarrow YX→Y，∀X′⊂X\forall X’ \subset X∀X′⊂X，X’↛YX’ \nrightarrow YX’↛Y，则X→FYX \xrightarrow{F} YXF​Y。</li><li><strong>部分函数依赖</strong>: X→YX \rightarrow YX→Y，∃X′⊂X\exists X’ \subset X∃X′⊂X，X′↛YX’ \nrightarrow YX′↛Y，则X→PYX \xrightarrow{P} YXP​Y。</li></ul><h4 id="4-传递函数依赖"><a href="#4-传递函数依赖" class="headerlink" title="4. 传递函数依赖"></a><a href="#4-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"></a>4. 传递函数依赖</h4><ul><li>在R(U)中，如果X→Y(Y⊊X)X \rightarrow Y(Y \subsetneq X)X→Y(Y⊊X)，Y↛XY \nrightarrow XY↛X，Y→ZY→ZY→Z，Z⊊YZ \subsetneq YZ⊊Y, 则称Z对X<strong>传递函数依赖</strong>(transitive functional dependency)。记为：X→传递ZX \xrightarrow{传递} ZX传递​Z。</li><li>注: 如果Y→XY \rightarrow XY→X, 即X←→YX \leftarrow \rightarrow YX←→Y，则Z直接依赖于X，而不是传递函数依赖。</li></ul><h3 id="6-2-2-码"><a href="#6-2-2-码" class="headerlink" title="6.2.2 码"></a><a href="#622-%E7%A0%81"></a>6.2.2 码</h3><ul><li>设K为R&lt;U,F&gt;中的属性或属性组合。若K→FUK \xrightarrow{F} UKF​U，则K称为R的一个<strong>候选码</strong>(Candidate Key)。</li><li>如果U部分函数依赖于K，即K→PUK \xrightarrow{P} UKP​U,则K称为<strong>超码</strong>(Surpkey）。候选码是最小的超码，即K的任意一个真子集都不是候选码。</li><li>若关系模式R有多个候选码，则选定其中的一个做为<strong>主码</strong>(Primary key)</li><li>包含在任何一个候选码中的属性，称为<strong>主属性</strong>（Prime attribute）,不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</li><li>全码：整个属性组是码，称为<strong>全码</strong>（All-key）</li><li>R中属性或属性组X并非R的码，但是另一个关系模式的码，则称X是R的<strong>外码</strong>。</li></ul><h3 id="6-2-3-范式"><a href="#6-2-3-范式" class="headerlink" title="6.2.3 范式"></a><a href="#623-%E8%8C%83%E5%BC%8F"></a>6.2.3 范式</h3><ul><li><p>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF</p></li><li><p>规范化（normalization）: 一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合</p></li><li><p><strong>1NF</strong>: 属性不可再分</p></li><li><p><strong>2NF</strong>：满足1NF，每个非主属性都完全依赖于关键字</p></li><li><p><strong>3NF</strong>：满足2NF，每个非主属性都不传递依赖于关键字</p></li><li><p><strong>BCNF</strong>: 满足1NF，若X→YX \rightarrow YX→Y,则X必含有该模式的关键字</p><ul><li>BCNF-&gt;3NF</li></ul></li></ul><h3 id="6-2-7-多值依赖"><a href="#6-2-7-多值依赖" class="headerlink" title="6.2.7 多值依赖"></a><a href="#627-%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"></a>6.2.7 多值依赖</h3><ul><li>多值依赖：X→→YX \rightarrow \rightarrow YX→→Y<ul><li>定义：对X的一个取值，存在一组Y与其对应；Y的取值与U-X-Y不相关</li><li>非平凡多值依赖： U-X-Y不为空集</li><li>平凡多值依赖：反之</li></ul></li><li>4NF<ul><li>定义：若X→→YX \rightarrow \rightarrow YX→→Y是非平凡多值依赖，则X必有关键字</li><li>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际上是函数依赖。</li><li>如果一个关系模式是4NF， 则必为BCNF</li></ul></li></ul><h3 id="6-2-8-总结"><a href="#6-2-8-总结" class="headerlink" title="6.2.8 总结"></a><a href="#628-%E6%80%BB%E7%BB%93"></a>6.2.8 总结</h3><ul><li><p>关系模式规范化过程：</p><p><img src="https://i.loli.net/2021/09/06/j87KIQ1NnRaZgYy.png" alt="image-20210906204151632"></p></li><li><p>并不是规范化程度越高的关系模式越好</p></li></ul><h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a><a href="#63-%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"></a>6.3 数据依赖的公理系统</h2><p>Armstrong公理系统</p><ul><li>基本规则：<ul><li>自反律： 若Y⊆X⊆UY \subseteq X \subseteq UY⊆X⊆U, 则X→YX \rightarrow YX→Y为F所蕴含</li><li>增广律： 若X→YX \rightarrow YX→Y为F所蕴涵，且Z⊆UZ \subseteq UZ⊆U，则XZ→YZXZ \rightarrow YZXZ→YZ 为F所蕴涵</li><li>传递律： 若X→YX \rightarrow YX→Y及Y→ZY \rightarrow ZY→Z为F所蕴涵，则X→ZX \rightarrow ZX→Z为F所蕴涵。</li></ul></li><li>推理规则：<ul><li>合并规则（union rule）：由X→YX \rightarrow YX→Y，X→ZX \rightarrow ZX→Z，有X→YZX \rightarrow YZX→YZ。</li><li>伪传递规则（pseudo transitivity rule）：由X→YX \rightarrow YX→Y，WY→ZWY \rightarrow ZWY→Z，有XW→ZX W\rightarrow ZXW→Z</li><li>分解规则（decomposition rule）：由X→YX \rightarrow YX→Y及Z⊆YZ \subseteq YZ⊆Y，有X→ZX \rightarrow ZX→Z。</li></ul></li></ul><h1 id="Chapter-7-数据库设计"><a href="#Chapter-7-数据库设计" class="headerlink" title="Chapter 7 数据库设计"></a><a href="#chapter-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"></a>Chapter 7 数据库设计</h1><h2 id="7-1-需求分析"><a href="#7-1-需求分析" class="headerlink" title="7.1 需求分析"></a><a href="#71-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"></a>7.1 需求分析</h2><ul><li>数据字典<ul><li>内容：数据项，数据结构，数据流，数据存储，处理过程</li></ul></li></ul><h2 id="7-2-概念结构设计"><a href="#7-2-概念结构设计" class="headerlink" title="7.2 概念结构设计"></a><a href="#72-%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>7.2 概念结构设计</h2><ul><li>将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程</li><li>描述概念模型的工具：E-R模型<ul><li>实体之间的联系：<ul><li>两个实体型之间的联系：一对一联系（1∶1），一对多联系（1∶n），多对多联系（m∶n）</li><li>两个以上的实体型之间的联系：同上。</li><li>单个实体型内的联系：同上。</li></ul></li><li>E-R图：<ul><li>实体型：用矩形表示，矩形框内写明实体名。</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来</li><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1∶1，1∶n或m∶n）</li><li>联系可以具有属性</li></ul></li></ul></li></ul><h2 id="7-3-逻辑结构设计"><a href="#7-3-逻辑结构设计" class="headerlink" title="7.3 逻辑结构设计"></a><a href="#73-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>7.3 逻辑结构设计</h2><ul><li><p>把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p></li><li><p>E-R图向关系模型的转换。转换原则：</p><ul><li>一个实体型转换为一个关系模式。<ul><li>关系的属性：实体的属性</li><li>关系的码：实体的码</li></ul></li><li>实体型间的联系：<ul><li>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li><li>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li><li>一个m:n联系转换为一个关系模式</li><li>三个或三个以上实体间的一个多元联系转换为一个关系模式</li><li>具有相同码的关系模式可合并</li></ul></li></ul></li></ul><h2 id="7-4-物理结构设计"><a href="#7-4-物理结构设计" class="headerlink" title="7.4 物理结构设计"></a><a href="#74-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>7.4 物理结构设计</h2><h2 id="7-5-数据库实施"><a href="#7-5-数据库实施" class="headerlink" title="7.5 数据库实施"></a><a href="#75-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%96%BD"></a>7.5 数据库实施</h2><h2 id="7-6-数据库运行和维护"><a href="#7-6-数据库运行和维护" class="headerlink" title="7.6 数据库运行和维护"></a><a href="#76-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BB%B4%E6%8A%A4"></a>7.6 数据库运行和维护</h2><h1 id="Chapter-10-数据库恢复技术"><a href="#Chapter-10-数据库恢复技术" class="headerlink" title="Chapter 10 数据库恢复技术"></a><a href="#chapter-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"></a>Chapter 10 数据库恢复技术</h1><h2 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a><a href="#101-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>10.1 事务的基本概念</h2><h3 id="10-1-1-事务"><a href="#10-1-1-事务" class="headerlink" title="10.1.1 事务"></a><a href="#1011-%E4%BA%8B%E5%8A%A1"></a>10.1.1 事务</h3><ul><li><p>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p></li><li><p>事务 VS 程序</p><ul><li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li><li>一个程序通常包含多个事务</li></ul></li><li><p>事务是恢复和并发控制的基本单位</p></li><li><p>定义</p><ul><li><p>显式定义：</p><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line"><span class="keyword">SQL</span> 语句<span class="number">1</span></span><br><span class="line"><span class="keyword">SQL</span> 语句<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"># 事务正常结束   </span><br><span class="line"># 提交事务的所有操作（读<span class="operator">+</span>更新）</span><br><span class="line"># 事务中所有对数据库的更新写回到磁盘上的物理数据库中</span><br></pre></td></tr></tbody></table><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line"><span class="keyword">SQL</span> 语句<span class="number">1</span></span><br><span class="line"><span class="keyword">SQL</span> 语句<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"># 事务异常终止</span><br><span class="line"># 事务运行的过程中发生了故障，不能继续执行</span><br><span class="line"># 系统将事务中对数据库的所有已完成的操作全部撤销 </span><br><span class="line"># 事务滚回到开始时的状态</span><br></pre></td></tr></tbody></table></li><li><p>隐式定义: 当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务</p></li></ul></li></ul><h3 id="10-1-2-事务的ACID特性"><a href="#10-1-2-事务的ACID特性" class="headerlink" title="10.1.2 事务的ACID特性"></a><a href="#1012-%E4%BA%8B%E5%8A%A1%E7%9A%84acid%E7%89%B9%E6%80%A7"></a>10.1.2 事务的ACID特性</h3><ul><li>原子性（Atomicity）: 事务中包括的诸操作要么都做，要么都不做</li><li>一致性（Consistency）: 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>隔离性（Isolation）: 一个事务的执行不能被其他事务干扰。并发结果与某种串行执行结果相同</li><li>持续性（Durability）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</li></ul><h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a><a href="#103-%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB"></a>10.3 故障的种类</h2><ol><li>事务内部的故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ol><h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a><a href="#104-%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"></a>10.4 恢复的实现技术</h2><ul><li>恢复操作的基本原理：冗余</li><li>数据转储<ul><li>转储： 数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li><li>备用的数据文本称为后备副本(backup)或后援副本</li><li>转储方法：<ul><li>静态转储与动态转储<ul><li>静态转储：在系统中无运行事务时进行的转储操作；转储开始时数据库处于一致性状态；转储期间不允许对数据库的任何存取、修改活动<br>得到的一定是一个数据一致性的副本</li><li>动态转储：转储操作与用户事务并发进行；转储期间允许对数据库进行存取或修改</li></ul></li><li>海量转储与增量转储<ul><li>海量转储: 每次转储全部数据库</li><li>增量转储: 只转储上次转储后更新过的数据</li></ul></li></ul></li></ul></li><li>登记日志文件<ul><li>日志文件(log file)：用来记录事务对数据库的更新操作的文件</li><li>登记日志文件时必须遵循两条原则：<ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul></li></ul></li></ul><h2 id="10-5-恢复策略"><a href="#10-5-恢复策略" class="headerlink" title="10.5 恢复策略"></a><a href="#105-%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"></a>10.5 恢复策略</h2><h3 id="10-5-1-事务故障的恢复"><a href="#10-5-1-事务故障的恢复" class="headerlink" title="10.5.1 事务故障的恢复"></a><a href="#1051-%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"></a>10.5.1 事务故障的恢复</h3><ul><li>事务故障：事务在运行至正常终止点前被终止</li><li>恢复方法<ul><li>由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改</li></ul></li><li>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</li><li>恢复步骤：<ul><li>反向扫描文件日志，查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库<ul><li>插入操作， “更新前的值”为空，则相当于做删除操作</li><li>删除操作，“更新后的值”为空，则相当于做插入操作</li><li>若是修改操作，则相当于用修改前值代替修改后值</li></ul></li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理</li><li>如此处理下去，直至读到此事务的开始标记，恢复完成</li></ul></li></ul><h3 id="10-5-2-系统故障的恢复"><a href="#10-5-2-系统故障的恢复" class="headerlink" title="10.5.2 系统故障的恢复"></a><a href="#1052-%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"></a>10.5.2 系统故障的恢复</h3><ul><li><p>系统故障造成数据库不一致状态的原因</p><ul><li>未完成事务对数据库的更新可能已写入数据库</li><li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li></ul></li><li><p>恢复方法</p><ul><li>Undo 故障发生时未完成的事务</li></ul><ol start="2"><li>Redo 已完成的事务</li></ol></li><li><p>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</p></li><li><p>恢复步骤：</p><ul><li>正向扫描日志文件<ul><li>重做(REDO) 队列: 在故障发生前已经提交的事务（这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录</li><li>撤销 (UNDO)队列:故障发生时尚未完成的事务（这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录</li></ul></li><li>对撤销(UNDO)队列事务进行撤销(UNDO)处理</li><li>对重做(REDO)队列事务进行重做(REDO)处理</li></ul></li></ul><h3 id="10-5-3-介质故障的恢复"><a href="#10-5-3-介质故障的恢复" class="headerlink" title="10.5.3 介质故障的恢复"></a><a href="#1053-%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"></a>10.5.3 介质故障的恢复</h3><ul><li>重装数据库</li><li>重做已完成的事务</li><li>恢复步骤：<ul><li>装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态</li><li>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务</li></ul></li><li>介质故障的恢复需要数据库管理员介入</li></ul><h2 id="10-6-具有检查点的恢复技术"><a href="#10-6-具有检查点的恢复技术" class="headerlink" title="10.6 具有检查点的恢复技术"></a><a href="#106-%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"></a>10.6 具有检查点的恢复技术</h2><ul><li>在日志文件中增加检查点记录（checkpoint）</li><li>增加重新开始文件</li><li>恢复子系统在登录日志文件期间动态地维护日志</li><li>检查点记录的内容<ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志记录的地址</li></ul></li><li>重新开始文件的内容<ul><li>记录各个检查点记录在日志文件中的地址</li></ul></li></ul><h2 id="10-7-数据库镜像"><a href="#10-7-数据库镜像" class="headerlink" title="10.7 数据库镜像"></a><a href="#107-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%95%9C%E5%83%8F"></a>10.7 数据库镜像</h2><ul><li>数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上</li><li>数据库管理系统自动保证镜像数据与主数据的一致性。每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去</li></ul><h1 id="Chapter-11-并发控制"><a href="#Chapter-11-并发控制" class="headerlink" title="Chapter 11 并发控制"></a><a href="#chapter-11-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"></a>Chapter 11 并发控制</h1><h2 id="11-1-并发控制概述"><a href="#11-1-并发控制概述" class="headerlink" title="11.1 并发控制概述"></a><a href="#111-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0"></a>11.1 并发控制概述</h2><ul><li><p>事务是并发控制的基本单位</p></li><li><p>并发操作带来的数据不一致性</p><table><thead><tr><th>不一致现象</th><th>描述</th><th>原因</th></tr></thead><tbody><tr><td>丢失修改（Lost Update）</td><td>一个修改破坏另一个修改结果</td><td>多个事务并发修改同一个数据</td></tr><tr><td>不可重复读（Non-repeatable Read）</td><td>读到错误的数据</td><td>其他事务未提交的修改</td></tr><tr><td>读“脏”数据（Dirty Read）</td><td>前后两次读不一致</td><td>其他事务已提交的写操作</td></tr><tr><td>幻像读</td><td>一个事务中, 执行相同的查询多次, 结果不同</td><td>其他事务已提交的插入操作</td></tr></tbody></table></li><li><p>并发控制的主要技术</p><ul><li>封锁(Locking)</li><li>时间戳(Timestamp)</li><li>乐观控制法</li><li>多版本并发控制(MVCC)</li></ul></li></ul><h2 id="11-2-封锁"><a href="#11-2-封锁" class="headerlink" title="11.2 封锁"></a><a href="#112-%E5%B0%81%E9%94%81"></a>11.2 封锁</h2><ul><li><p>基本封锁类型</p><ul><li>排它锁&#x2F;写锁（Exclusive Locks，简记为X锁）<ul><li>自己可以读写, 其他事务啥也不行</li><li>一个对象同时只能上一次, 维持到事务结束</li></ul></li><li>共享锁&#x2F;读锁（Share Locks，简记为S锁）<ul><li>所有事务只读</li><li>可以与其他S锁并存</li></ul></li></ul></li><li><p>锁的相容矩阵：</p><table><thead><tr><th>T2T_2T2​\ T1T_1T1​</th><th>X</th><th>S</th><th>-</th></tr></thead><tbody><tr><td>X</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>S</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>-</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table></li></ul><h2 id="11-3-封锁协议"><a href="#11-3-封锁协议" class="headerlink" title="11.3 封锁协议"></a><a href="#113-%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"></a>11.3 封锁协议</h2><ul><li><p>封锁协议（Locking Protocol）：在运用X锁和S锁对数据对象加锁时，约定的一些规则</p></li><li><p>三级封锁协议：</p><ul><li>一级封锁协议：写之前加X锁, 事务结束释放</li><li>二级封锁协议：一级 + 读前加S锁, 读完释放</li><li>三级封锁协议：一级 + 读前加S锁, 事务结束释放</li></ul></li><li><p>三级封锁协议的防止的不一致</p><ul><li><p>一级：丢失修改</p></li><li><p>二级：丢失修改，读脏</p></li><li><p>三级：丢失修改，读脏，不可重复读</p><table><thead><tr><th></th><th>X锁</th><th></th><th>S锁</th><th></th><th>一致性保证</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>操作结束释放</td><td>事务结束释放</td><td>操作结束释放</td><td>事务结束释放</td><td>不丢失修改</td><td>不读脏</td><td>可重复读</td></tr><tr><td>一级封锁协议</td><td></td><td>✔</td><td></td><td></td><td>✔</td><td></td><td></td></tr><tr><td>二级封锁协议</td><td></td><td>✔</td><td>✔</td><td></td><td>✔</td><td>✔</td><td></td></tr><tr><td>三级封锁协议</td><td></td><td>✔</td><td></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table></li></ul></li></ul><h2 id="11-4-活锁和死锁"><a href="#11-4-活锁和死锁" class="headerlink" title="11.4 活锁和死锁"></a><a href="#114-%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81"></a>11.4 活锁和死锁</h2><p>封锁技术可以有效地解决并行操作的一致性问题，但也带来一些新的问题</p><ul><li>活锁:<ul><li>有部分事务长期等待锁, 其他事务可以继续运行</li><li>避免：FCFS</li></ul></li><li>死锁:<ul><li>每个事务持有部分锁, 循环等待</li><li>解决方法：<ul><li>死锁的预防：破坏产生死锁的条件<ul><li>一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行（问题：降低了系统并发度；难于事先精确确定封锁对象）</li><li>顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁（问题：维护成本高，难以实现）</li></ul></li><li>死锁的诊断和解除<ul><li>诊断：<ul><li>超时法</li><li>等待图法</li></ul></li><li>解除：<ul><li>选择一个处理死锁代价最小的事务，将其撤消</li><li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="11-5-并发调度的可串行性"><a href="#11-5-并发调度的可串行性" class="headerlink" title="11.5 并发调度的可串行性"></a><a href="#115-%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7"></a>11.5 并发调度的可串行性</h2><h3 id="11-5-1-可串行化调度"><a href="#11-5-1-可串行化调度" class="headerlink" title="11.5.1 可串行化调度"></a><a href="#1151-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"></a>11.5.1 可串行化调度</h3><ul><li>可串行化(Serializable)调度<br>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li><li>可串行性(Serializability)<br>是并发事务正确调度的准则<br>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul><h3 id="11-5-2-冲突可串行化调度"><a href="#11-5-2-冲突可串行化调度" class="headerlink" title="11.5.2 冲突可串行化调度"></a><a href="#1152-%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"></a>11.5.2 冲突可串行化调度</h3><ul><li><p>冲突操作：不同的事务对同一数据的 读写操作 和 写写操作：</p><table><tbody><tr><td class="code"><pre><span class="line">Ri(x)与Wj(x)       /*事务Ti读x，Tj写x，其中i≠j*/</span><br><span class="line">Wi(x)与Wj(x)        /*事务Ti写x，Tj写x，其中i≠j*/</span><br></pre></td></tr></tbody></table></li><li><p>不能交换（Swap）的动作:</p><ul><li>同一事务的两个操作</li><li>不同事务的冲突操作</li></ul></li><li><p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化的调度</strong></p></li></ul><h2 id="11-6-两段锁协议"><a href="#11-6-两段锁协议" class="headerlink" title="11.6 两段锁协议"></a><a href="#116-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"></a>11.6 两段锁协议</h2><ul><li>两阶段封锁协议<ul><li>一阶段: 申请整个过程需要的锁</li><li>二阶段: 释放所有锁, 不能再申请</li></ul></li><li>两阶段封锁协议与冲突可串行化的关系: 两阶段任意合法调度S都是冲突可串行化的</li></ul><h2 id="11-7-封锁的粒度"><a href="#11-7-封锁的粒度" class="headerlink" title="11.7 封锁的粒度"></a><a href="#117-%E5%B0%81%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"></a>11.7 封锁的粒度</h2><p>封锁粒度&#x2F;并发度&#x2F;并发控制实现开销 之间的关系</p><ul><li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li><li>封锁的粒度越小，并发度较高，但系统开销也就越大</li></ul><h3 id="11-7-1-多粒度封锁"><a href="#11-7-1-多粒度封锁" class="headerlink" title="11.7.1 多粒度封锁"></a><a href="#1171-%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81"></a>11.7.1 多粒度封锁</h3><ul><li>多粒度封锁: 同时支持多种封锁粒度供事务选择</li><li>多粒度树: 按照封锁粒度的大小构造出一棵”多粒度树”，以树中的每个结点作为封锁对象，可以构成一个”多粒度封锁协议”</li></ul><h3 id="11-7-2-意向锁"><a href="#11-7-2-意向锁" class="headerlink" title="11.7.2 意向锁"></a><a href="#1172-%E6%84%8F%E5%90%91%E9%94%81"></a>11.7.2 意向锁</h3><ul><li><p>意向锁: 节点加意向锁, 其下层节点正被加锁(必须上层先加意向锁, 才能给下层加锁)</p><ul><li>IS: 下层打算加S</li><li>IX: 下层打算加X</li><li>SIX: 当前加S, 下层加X</li></ul></li><li><p>意向锁锁相容矩阵:</p><table><thead><tr><th>已经有的锁</th><th>S</th><th>X</th><th>IS</th><th>IX</th><th>SIX</th><th></th></tr></thead><tbody><tr><td>已经持有S</td><td>✔</td><td></td><td>✔</td><td></td><td></td><td>S加了, 当前及其下层没有X</td></tr><tr><td>已经持有X</td><td></td><td></td><td></td><td></td><td></td><td>X排他, 加了别的都没有</td></tr><tr><td>已经持有IS</td><td>✔</td><td></td><td>✔</td><td>✔</td><td>✔</td><td>IS加了, 当前没X</td></tr><tr><td>已经持有IX</td><td></td><td></td><td>✔</td><td>✔</td><td></td><td>IX加了, 当前没S没X</td></tr><tr><td>已经持有SIX</td><td></td><td></td><td>✔</td><td></td><td></td><td>SIX加了, 相当于同时S和IX</td></tr></tbody></table></li><li><p>意向锁锁申请算法，意向锁锁释放算法: 对任何一个节点加锁, 必须先对其父节点加意向锁(也就是从根开始加)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-1-绪论&quot;&gt;&lt;a href=&quot;#Chapter-1-绪论&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1 绪论&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#chapter-1-%E7%BB%AA%E8%AE%BA&quot;&gt;&lt;/a&gt;Chapte</summary>
      
    
    
    
    
    <category term="DB" scheme="http://example.com/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>基于卷积神经网络的孤立词语音识别系统</title>
    <link href="http://example.com/2021/07/08/SSP/"/>
    <id>http://example.com/2021/07/08/SSP/</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2024-04-18T02:23:26.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/isxrh/Isolated-Speech-Recongnition">https://github.com/isxrh/Isolated-Speech-Recongnition</a></p></blockquote><p><strong>摘要</strong> 为提高孤立词语音识别正确率，提出将卷积神经网络应用于孤立词语音识别的方法。搭建具有4个卷积层、4个汇聚层和2个全连接层的一维卷积神经网络模型。将语音重采样为相同长度后输入到网络模型中进行识别，在TensorFlow语音识别挑战赛数据集上，实验结果表明，模型的识别正确率为92%。为方便语音识别，基于PyQt5搭建可视化孤立词识别系统，系统简洁易用，识别速度快、准确率高。</p><p><strong>关键词</strong>: 孤立词语音识别; 卷积神经网络; 重采样; 可视化识别系统</p><p>语音识别技术，也被称为自动语音识别或语音转文本识别，其目标是以电脑自动将人类的语音内容转换为相应的文字。孤立词识别是指语音中只包含一个词语的识别。传统的孤立词识别方法主要有两种: 一是动态时间规整(Dynamic Time Warping, DTW)方法, 二是隐马尔可夫模型(Hidden Markov Model, HMM)的方法。前者由于没有一个有效地用统计方法进行训练的框架, 且不方便将低层和顶层的各种知识用到语音识别算法中, 在解决大词汇量、非特定人语音识别等问题时效果较差；而HMM算法比较复杂，需要在训练阶段提供大量的语音数据, 通过反复计算才能得到参数模型。神经网络是机器学习与人工智能领域的一种模型，近几年来，深度神经网络(Deep Neural Networks, DNN)在语音识别领域的应用大幅度地提高了已有语音识别系统的准确率，使得语音识别技术变得更加可用，使用机器学习方法提高语音识别系统性能是一个重要的研究课题, 本文主要研究卷积神经网络(Convolutional Neural Network, CNN)在孤立词语音识别问题中的应用。</p><h2 id="1-基于CNN的孤立词识别模型"><a href="#1-基于CNN的孤立词识别模型" class="headerlink" title="1 基于CNN的孤立词识别模型"></a><a href="#1-%E5%9F%BA%E4%BA%8Ecnn%E7%9A%84%E5%AD%A4%E7%AB%8B%E8%AF%8D%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B"></a>1 基于CNN的孤立词识别模型</h2><h3 id="1-1-卷积神经网络简介"><a href="#1-1-卷积神经网络简介" class="headerlink" title="1.1 卷积神经网络简介"></a><a href="#11-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B"></a>1.1 卷积神经网络简介</h3><p>卷积神经网络是一类包含卷积计算且具有深度结构的前馈神经网络，是深度学习的代表算法之一。CNN将模式识别的特征提取和模型分类两个问题统一到一个网络中来，本质上是一种由一组或多组卷积层和池化层交替连接构成的基于有监督学习的数学模型。</p><p>CNN的基本结构由输入层(input layer)、卷积层(convolutional layer)、汇聚层(pooling layer)、全连接层(full connection layer)以及输出层(output layer)构成。卷积层和汇聚层一般会取若干个，采用卷积层和池化层交替设置，即一个卷积层连接一个池化层，池化层后再连接一个卷积层，依此类推。这些层结构依次堆叠形成一个卷积神经网络。</p><p>通常情况下，语音识别都是基于时频分析后的语音谱完成的，而其中语音时频谱是具有结构特点的。要想提高语音识别率，就是需要克服语音信号所面临各种各样的多样性，包括说话人的多样性(说话人自身、以及说话人间)，环境的多样性等。一个卷积神经网络提供在时间和空间上的平移不变性卷积，将卷积神经网络的思想应用到语音识别的声学建模中，则可以利用卷积的不变性来克服语音信号本身的多样性。从这个角度来看，则可以认为是将整个语音信号分析得到的时频谱当作一张图像一样来处理，采用图像中广泛应用的深层卷积网络对其进行识别。同时，CNN也比较容易实现大规模并行化运算，且CNN的加速运算相对比较成熟，一些通用框架如Tensorflow等都提供CNN的并行化加速，为CNN在语音识别中的尝试提供了可能。</p><h3 id="1-2-基于CNN的孤立词识别模型"><a href="#1-2-基于CNN的孤立词识别模型" class="headerlink" title="1.2 基于CNN的孤立词识别模型"></a><a href="#12-%E5%9F%BA%E4%BA%8Ecnn%E7%9A%84%E5%AD%A4%E7%AB%8B%E8%AF%8D%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B"></a>1.2 基于CNN的孤立词识别模型</h3><p>词语范围固定的孤立词识别问题，本质上属于一个多分类问题，输入为语音信号，输出为语音信号对应的词语文字。针对这一问题，搭建了具有4个卷积层、4个汇聚层和2个全连接层的一维卷积神经网络，网络结构如图 1所示。</p><p>输入为语音的时域信号，首先经过四层卷积层和池化层的深层特征提取和降维，然后进入全连接层把提取到的局部特征进行全局上的整合与变换，最后经过Softmax得到语音属于不同分类的概率。网络搭建的核心代码如下：</p><table><tbody><tr><td class="code"><pre><span class="line">inputs = Input(shape=(<span class="number">8000</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># First Conv1D layer</span></span><br><span class="line">conv = Conv1D(<span class="number">8</span>, <span class="number">13</span>, padding=<span class="string">'valid'</span>, activation=<span class="string">'relu'</span>, strides=<span class="number">1</span>)(inputs)</span><br><span class="line">conv = MaxPooling1D(<span class="number">3</span>)(conv)</span><br><span class="line">conv = Dropout(<span class="number">0.3</span>)(conv)</span><br><span class="line"><span class="comment"># Second Conv1D layer</span></span><br><span class="line">conv = Conv1D(<span class="number">16</span>, <span class="number">11</span>, padding=<span class="string">'valid'</span>, activation=<span class="string">'relu'</span>, strides=<span class="number">1</span>)(conv)</span><br><span class="line">conv = MaxPooling1D(<span class="number">3</span>)(conv)</span><br><span class="line">conv = Dropout(<span class="number">0.3</span>)(conv)</span><br><span class="line"><span class="comment"># Third Conv1D layer</span></span><br><span class="line">conv = Conv1D(<span class="number">32</span>, <span class="number">9</span>, padding=<span class="string">'valid'</span>, activation=<span class="string">'relu'</span>, strides=<span class="number">1</span>)(conv)</span><br><span class="line">conv = MaxPooling1D(<span class="number">3</span>)(conv)</span><br><span class="line">conv = Dropout(<span class="number">0.3</span>)(conv)</span><br><span class="line"><span class="comment"># Fourth Conv1D layer</span></span><br><span class="line">conv = Conv1D(<span class="number">64</span>, <span class="number">7</span>, padding=<span class="string">'valid'</span>, activation=<span class="string">'relu'</span>, strides=<span class="number">1</span>)(conv)</span><br><span class="line">conv = MaxPooling1D(<span class="number">3</span>)(conv)</span><br><span class="line">conv = Dropout(<span class="number">0.3</span>)(conv)</span><br><span class="line"><span class="comment"># Flatten layer</span></span><br><span class="line">conv = Flatten()(conv)</span><br><span class="line"><span class="comment"># First Dense Layer</span></span><br><span class="line">conv = Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>)(conv)</span><br><span class="line">conv = Dropout(<span class="number">0.3</span>)(conv)</span><br><span class="line"><span class="comment"># Second Dense Layer 2</span></span><br><span class="line">conv = Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>)(conv)</span><br><span class="line">conv = Dropout(<span class="number">0.3</span>)(conv)</span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line">outputs = Dense(<span class="built_in">len</span>(labels), activation=<span class="string">'softmax'</span>)(conv)</span><br><span class="line">model = Model(inputs, outputs)</span><br><span class="line">model.summary()</span><br></pre></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/wps1.jpg" alt="图1 用于孤立词识别的CNN结构示意图"></p><h3 id="1-3-模型应用及性能评估"><a href="#1-3-模型应用及性能评估" class="headerlink" title="1.3 模型应用及性能评估"></a><a href="#13-%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"></a>1.3 模型应用及性能评估</h3><p>实验所用的数据集来自TensorFlow语音识别挑战赛。</p><p>上述模型应用于语音处理的流程如图 2所示：</p><p><img src="https://i.loli.net/2021/07/26/yBlsbnfQNTLp82M.jpg" alt="图2 孤立词识别流程图"></p><p>首先，对数据进行预处理。实验选择”yes”, “no”, “up”, “down”四个孤立词识别。首先删除音频长度&lt; 1秒的语音；然后对剩余语音进行重采样处理，由于人类的语音信号的频率大部分在 10000Hz 以下，电话信号的采样率为 8000Hz，因此实验也将原语音信号重采样到8000Hz(原采样率为16000Hz)；最后对输出标签编码，先将输出标签转换为整体编码，再进行One-hot编码处理，同时，输入信号转化为3维。</p><p>然后，划分训练集和数据集，实验以8:2的比例进行划分。</p><p>再将训练集输入到搭建好的模型中进行训练。训练过程中，损失变化如图 3所示：</p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/wps3.jpg" alt="图3 模型损失变化图"></p><p>最后，利用测试集检验模型性能。结果显示，测试集语音总条为1694，其中预测正确条数有1573，预测错误条数有121，即在测试集上的正确率92.86%。</p><h2 id="2-基于PyQt5的孤立词识别系统"><a href="#2-基于PyQt5的孤立词识别系统" class="headerlink" title="2 基于PyQt5的孤立词识别系统"></a><a href="#2-%E5%9F%BA%E4%BA%8Epyqt5%E7%9A%84%E5%AD%A4%E7%AB%8B%E8%AF%8D%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F"></a>2 基于PyQt5的孤立词识别系统</h2><p>为方便识别过程，搭建了基于PyQt5的简易孤立词识别系统，系统主界面如下图所示：</p><p><img src="https://i.loli.net/2021/07/26/pA8yvMRieUGkQq9.jpg" alt="图 4 识别系统主界面图"></p><p>​ 界面左边为语音识别区域，右边为系统使用说明区域。</p><p>​ 点击[Start Recording]按钮即开始录音，录音时间为1s, 录音界面如下图：</p><p><img src="https://i.loli.net/2021/07/26/WbglOKtMBucrAfm.jpg" alt="图 5 录音界面图"></p><p>录音完成，系统调用训练好的CNN孤立词识别模型对语音进行识别，识别完成，立即展示识别结果，如下图所示：</p><p><img src="https://i.loli.net/2021/07/26/2mWP8fk1CqYBSMI.jpg" alt="图 6 识别结果展示界面图"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a><a href="#3-%E6%80%BB%E7%BB%93"></a>3 总结</h2><p>本文提出了基于卷积神经网络的孤立词语音识别方法。搭建了具有4个卷积层、4个汇聚层和2个全连接层的一维卷积神经网络模型。利用TensorFlow语音识别挑战赛数据集对模型进行训练、测试，实验结果表明，模型在测试集上的识别正确率为92%。同时，为模型使用，基于PyQt5搭建了可视化孤立词识别系统，系统简洁易用，识别速度快、准确率高。</p><p>由于时间资源有限，模型仅能用于识别”yes”, “no”, “up”, “down”四个孤立词，如需识别其他词，还有重新训练；另外，卷积神经网络的许多参数还有待改进，以减少训练时间。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"></a>参考文献</h2><p>[1]侯一民,李永平.基于卷积神经网络的孤立词语音识别[J].计算机工程与设计,2019,40(06):1751-1756.</p><p>[2]Semin Ryu,Seung-Chan Kim. Knocking and Listening: Learning Mechanical Impulse Response for Understanding Surface Characteristics[J]. Sensors,2020,20(2).</p><p>[3]朱锡祥,刘凤山,张超,吕钊,吴小培.基于一维卷积神经网络的车载语音识别研究[J].微电子学与计算机,2017,34(11):21-25.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/isxrh/Isolated-Speech-Recongnition&quot;&gt;https://github.com/isxrh/Isolated-Speech-Recongnition&lt;/</summary>
      
    
    
    
    
    <category term="SSP" scheme="http://example.com/tags/SSP/"/>
    
  </entry>
  
  <entry>
    <title>OS</title>
    <link href="http://example.com/2020/12/30/OS/"/>
    <id>http://example.com/2020/12/30/OS/</id>
    <published>2020-12-29T16:00:00.000Z</published>
    <updated>2024-04-18T02:08:33.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-OS基本概念"><a href="#1-1-OS基本概念" class="headerlink" title=" 1.1 OS基本概念"></a><a href="#11-os%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a> 1.1 OS基本概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title=" 概念"></a><a href="#%E6%A6%82%E5%BF%B5"></a> 概念</h3><ul><li>负责管理协调硬件、软件等计算机资源</li><li>为上层用户、应用程序提供简易服务</li><li>是一种系统软件</li></ul><h3 id="功能和目标"><a href="#功能和目标" class="headerlink" title=" 功能和目标"></a><a href="#%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"></a> 功能和目标</h3><ul><li><p>资源的管理者</p><pre><code>*   处理机管理</code></pre><ul><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li><p>向上层提供服务</p><pre><code>*   给普通用户的    *   GUI        *   命令接口            *   联机命令接口    *   脱机命令接口*   给软件/程序员的    *   程序接口（系统调用）            *   是什么？                    *   os对应用程序/程序员提供的接口                *   与库函数区别                *   系统调用实现的功能                    *   设备管理                            *   完成设备的 请求/释放/启动 等功能                        *   文件管理                            *   完成文件的 读/写/创建/删除 等功能                        *   进程控制                            *   完成进程的 创建/撤销/阻塞/唤醒 等功能                        *   进程通信                            *   完成进程之间的 消息传递/信号传递 等功能                        *   内存管理                            *   完成内存的 分配/回收 等功能                *   系统调用的过程                    *   传参        *   陷入指令/Trap/访管        *   由OS内核程序处理系统调用请求        *   返回应用程序</code></pre></li><li><p>对硬件机器的扩展</p><pre><code>*   扩充机器</code></pre></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title=" 特征"></a><a href="#%E7%89%B9%E5%BE%81"></a> 特征</h3><ul><li><p>并发</p></li><li><p>共享</p><pre><code>*   互斥共享方式</code></pre><ul><li>同时共享方式</li></ul></li><li><p>虚拟</p><pre><code>*   时分复用技术</code></pre><ul><li>空分复用技术</li></ul></li><li><p>异步</p></li></ul><h2 id="1-2-OS发展"><a href="#1-2-OS发展" class="headerlink" title=" 1.2 OS发展"></a><a href="#12-os%E5%8F%91%E5%B1%95"></a> 1.2 OS发展</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title=" 手工操作阶段"></a><a href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"></a> 手工操作阶段</h3><ul><li>缺点：人机速度矛盾</li></ul><h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title=" 批处理阶段"></a><a href="#%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"></a> 批处理阶段</h3><ul><li><p>单道批处理系统（引入脱机I&#x2F;O技术）</p><pre><code>*   优点：缓解人机速度矛盾</code></pre><ul><li>缺点：资源利用率依然低</li></ul></li><li><p>多道批处理系统（OS开始出现）</p><pre><code>*   优点：多道程序并发执行，资源利用率高</code></pre><ul><li>缺点：不提供人机交互功能</li></ul></li></ul><h3 id="分时OS"><a href="#分时OS" class="headerlink" title=" 分时OS"></a><a href="#%E5%88%86%E6%97%B6os"></a> 分时OS</h3><ul><li>优点：提供人机交互</li><li>缺点：不能优先处理紧急任务</li></ul><h3 id="实时OS"><a href="#实时OS" class="headerlink" title=" 实时OS"></a><a href="#%E5%AE%9E%E6%97%B6os"></a> 实时OS</h3><ul><li><p>硬实时系统</p><pre><code>*   必须在绝对严格的规定时间内完成处理</code></pre></li><li><p>软实时系统</p><pre><code>*   能偶尔接受违反时间规定</code></pre></li><li><p>优点：能优先处理紧急任务</p></li></ul><h3 id="网络OS"><a href="#网络OS" class="headerlink" title=" 网络OS"></a><a href="#%E7%BD%91%E7%BB%9Cos"></a> 网络OS</h3><h3 id="分布式OS"><a href="#分布式OS" class="headerlink" title=" 分布式OS"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8Fos"></a> 分布式OS</h3><h3 id="个人计算机OS"><a href="#个人计算机OS" class="headerlink" title=" 个人计算机OS"></a><a href="#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BAos"></a> 个人计算机OS</h3><h2 id="1-3-OS运行环境"><a href="#1-3-OS运行环境" class="headerlink" title=" 1.3 OS运行环境"></a><a href="#13-os%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"></a> 1.3 OS运行环境</h2><h3 id="OS运行机制"><a href="#OS运行机制" class="headerlink" title=" OS运行机制"></a><a href="#os%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"></a> OS运行机制</h3><ul><li><p>两类程序</p><pre><code>*   内核程序</code></pre><ul><li>应用程序</li></ul></li><li><p>两类指令</p><pre><code>*   特权指令</code></pre><ul><li>非特权指令</li></ul></li><li><p>两种处理器状态</p><pre><code>*   内核态/核心态/管态</code></pre><ul><li>用户态&#x2F;目态</li></ul></li><li><p>内核（内核(Kernel)是OS最重要最核心的部分，由很多内核程序组成）</p><pre><code>*   时钟管理    *   实现计时功能*   中断处理    *   负责实现中断机制*   原语    *   是一种特殊的程序*   处于OS最底层，最接近硬件的部分*   具有原子性——其运行只能一气呵成，不可中断*   运行时间较短、调用频繁*   对系统资源进行管理的功能    *   进程管理*   存储器管理*   设备管理</code></pre></li><li><p>如何变态</p><pre><code>*   内核态–&amp;gt;用户态    *   一条修改PSW的特权指令*   用户态–&amp;gt;内核态    *   由中断引起，硬件自动完成</code></pre></li></ul><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title=" 中断和异常"></a><a href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"></a> 中断和异常</h3><ul><li><p>中断的作用</p><pre><code>*   让操作系统强行夺回CPU控制权</code></pre><ul><li>使CPU从用户态变为内核态</li></ul></li><li><p>中断的分类</p><pre><code>*   内中断（异常/例外）    *   陷阱、陷入（trap）*   故障（fault）*   终止（abort）*   外中断    *   时钟中断*   I/O请求中断</code></pre></li><li><p>中断机制的基本原理</p><pre><code>*   检查中断信号    *   内中断：CPU在执行指令时会检查是否有异常发生*   外中断：每个指令周期末尾，CPU都会检查是否有外部中断信号需要处理*   找到相应的中断处理程序    *   通过“中断向量表”实现</code></pre></li></ul><h2 id="1-4-OS体系结构"><a href="#1-4-OS体系结构" class="headerlink" title=" 1.4 OS体系结构"></a><a href="#14-os%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"></a> 1.4 OS体系结构</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href="#"></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="#-2"></a></h3><h3 id="大内核"><a href="#大内核" class="headerlink" title=" 大内核"></a><a href="#%E5%A4%A7%E5%86%85%E6%A0%B8"></a> 大内核</h3><ul><li>将OS的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul><h3 id="微内核"><a href="#微内核" class="headerlink" title=" 微内核"></a><a href="#%E5%BE%AE%E5%86%85%E6%A0%B8"></a> 微内核</h3><ul><li>只把最关键的功能保留在内核</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li></ul><h1 id="Ch-2-进程管理"><a href="#Ch-2-进程管理" class="headerlink" title=" Ch 2 进程管理"></a><a href="#ch-2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"></a> Ch 2 进程管理</h1><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:100%; height:400px;" src="https://www.processon.com/embed/611b672e1e0853164d2b50de"></iframe><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title=" 2.1 进程与线程"></a><a href="#21-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"></a> 2.1 进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title=" 进程"></a><a href="#%E8%BF%9B%E7%A8%8B"></a> 进程</h3><ul><li><p>概念</p><pre><code>*   进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</code></pre></li><li><p>进程实体（进程映像）的组成</p><pre><code>*   PCB    *   进程描述信息            *   进程标识符PID    *   用户标识符UID        *   进程控制和管理信息            *   CPU、磁盘、网络流量使用情况统计…    *   进程当前状态：就绪态？阻塞态？…        *   资源分配清单            *   正在使用哪些文件    *   正在使用哪些内存区域    *   正在使用哪些I/O设备        *   处理机相关信息            *   如PSW、PC等各种寄存器的值（用于实现进程切换）*   程序段    *   程序的代码（指令序列）*   数据段    *   运行过程中产生的各种数据（如程序中定义的变量）</code></pre></li><li><p>特征</p><pre><code>*   动态性    *   最基本特征*   并发性*   独立性    *   进程是独立运行、独立获得资源、独立接受调度的基本单位*   异步性    *   各进程以不可预知的速度向前推进，可能导致运行结果的不确定性*   结构性</code></pre></li><li><p>组织方式</p><pre><code>*   链接方式    *   按照进程状态将PCB分为多个队列*   OS持有指向各个队列的指针*   索引方式    *   根据进程状态的不同，简历几张索引表*   OS持有指向各个索引表的指针</code></pre></li><li><p>状态与转换</p><pre><code>*   状态    *   运行态（Running）            *   占有CPU, 并在CPU上运行    *   CPU✅其他所需资源✅        *   就绪态(Ready)            *   已经具备运行条件，但由于没有空闲CPU, 而暂时不能运行    *   CPU❌其他所需资源✅        *   阻塞态（Waiting/Blocked, 又称等待态）            *   CPU❌其他所需资源❌        *   创建态（New, 又称 新建态）            *   进程正在被创建，OS为进程分配资源、初始化PCB        *   终止态（Terminated, 又称结束态）            *   进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB        *   挂起态            *   为减轻系统负载，提高资源利用率，暂时不执行的进程会被调到外存，从而变为“挂起态”*   状态间的转换    *   就绪态➡运行态            *   进程被调度        *   运行态➡就绪态            *   时间片到    *   CPU被其他高优先级的进程抢占        *   运行态➡阻塞态（主动行为）            *   等待系统分配资源    *   等待某件事件发生        *   阻塞态➡就绪态（被动行为）            *   资源分配到位    *   等待的事件发生        *   创建态➡就绪态            *   系统完成创建进程的相关工作        *   运行态➡终止态            *   进程运行结束    *   运行过程遇到不可修复的错误</code></pre></li><li><p>进程控制</p><pre><code>*   基本概念    *   进程控制就是要实现进程状态的转换        *   进程控制用原语实现            *   原语用关/开中断来实现    *   原语是一种特殊的程序    *   源于的执行必须一气呵成，不可中断*   相关原语    *   进程的创建            *   创建原语                    *   申请空白PCB        *   为进程分配所需资源        *   初始化PCB        *   将PCB插入就绪队列                *   引起进程创建的事件                    *   用户登录                            *   分时系统中，用户登陆成功，系统会为其建立一个新的进程                        *   作业调度                            *   多道批处理系统中，有的信作业放入内存是，会为其建立一个新的进程                        *   提供服务                            *   用户向OS提出某些请求时，会建立一个进程处理该请求                        *   应用请求                            *   由用户进程主动请求创建一个子进程        *   进程的终止            *   撤销原语                    *   从PCB中找到终止进程的PCB        *   若进程正在运行，立即剥夺CPU，将CPU分配给其他进程        *   终止其所有子进程        *   将该进程拥有的所有资源归还给父进程或OS        *   删除PCB                *   引起进程终止的事件                    *   正常结束                            *   进程自己请求终止（exit系统调用）                        *   异常结束                            *   整数除以0，非法使用特权指令，然后被OS强行杀掉                        *   外界干预                            *   Ctrl+Alt+delete, 用户选择杀掉进程        *   进程的阻塞            *   阻塞原语                    *   找到要阻塞进程的PCB        *   保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行        *   将PCB插入阻塞队列                *   引起进程阻塞的事件                    *   需要等待系统分配某种资源        *   需要相互合作的其他进程完成工作        *   进程的唤醒            *   唤醒原语                    *   在等待队列中找到PCB        *   将PCB从等待队列中移除，设置进程状态为就绪态        *   将PCB插入就绪队列，等待被调度                *   引起进程唤醒的事件                    *   等待事件的发生        *   进程的切换            *   切换原语                    *   将运行环境信息存入PCB        *   PCB移入相应队列        *   选择另一个进程执行，并更新其PCB        *   根据PCB回复新进程所需的运行环境                *   引起进程切换的事件                    *   当前进程的时间片到        *   有更高优先级的进程到达        *   当前进程阻塞        *   当前进程终止</code></pre></li><li><p>进程通信</p><pre><code>*   共享存储    *   设置一个共享空间        *   要互斥的访问共享空间        *   两种方式            *   基于数据结构（低级）    *   基于存储区的共享（高级）*   管道通信    *   设置一个特殊的共享文件（管道），其实就是一个缓冲区*   一个管道只能实现半双工通信*   实现双向同时通信要建立两个管道*   各进程要互斥的访问管道*   写满时，不能再写；读空时，不能再读*   没写满，不能读；没读空，不能写*   消息传递    *   传递结构化的消息（消息头/消息体）        *   系统提供“发送/接受原语”        *   两种方式            *   直接通信方式                    *   消息直接被挂到接收方的消息队列里                *   间接（信箱）通信方式                    *   消息先发到中间体（信箱）</code></pre></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title=" 线程"></a><a href="#%E7%BA%BF%E7%A8%8B"></a> 线程</h3><ul><li><p>引入线程带来的变化</p><pre><code>*   资源分配、调度    *   传统进程机制中，进程是资源分配的基本单位*   引入线程后，进程时资源分配的基本单位，线程是调度的基本单位*   并发性    *   传统进程机制中，只能进程间并发*   引入线程后，各线程间也能并发，提高了并发度*   系统开销    *   传统的进程间并发，需要切换进程的运行环境，系统开销很大*   线程间并发，如果是同一进程的线程切换，则不需要切换进程环境，系统开销小*   引入线程后，并发带来的系统开销减小</code></pre></li><li><p>线程的属性</p><pre><code>*   线程是处理机调度的单位</code></pre><ul><li>多CPU计算机中，各个线程可以占用不同的CPU</li><li>每个进程都有一个线程ID，线程控制块TCB</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小；切换进程系统开销大</li></ul></li><li><p>实现方式</p><pre><code>*   用户级线程（ULT）    *   用户视角能看到的线程，由线程库实现*   内核级线程(KLT)    *   OS视角看到的线程（由OS实现的内核级线程才是处理机分配的单位*   组合方式</code></pre></li><li><p>多线程模型</p><pre><code>*   一对一模型    *   一个用户级线程映射到一个内核级线程*   优点：各个线程可分配到多核处理机并行执行，并发度高*   缺点：线程管理都需要OS支持，开销大*   多对一模型    *   多个用户级线程映射到一个内核级线程*   优点：线程管理开销小效率高*   缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低）*   多对多模型    *   n个用户级线程映射到m个内核级线程（n&amp;gt;=m）*   集两者之所长</code></pre></li></ul><h2 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title=" 2.2 处理机调度"></a><a href="#22-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"></a> 2.2 处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title=" 基本概念"></a><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a> 基本概念</h3><ul><li>按照某种算法选择一个进程将处理机分配给他们</li></ul><h3 id="三个层次"><a href="#三个层次" class="headerlink" title=" 三个层次"></a><a href="#%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"></a> 三个层次</h3><ul><li><p>高级调度（作业调度）</p><pre><code>*   按照某种规则，从后备队列中选择合适的进程将其数据调回内存</code></pre><ul><li>外存-&gt;内存（面向作业）</li><li>发生频率：最低</li></ul></li><li><p>中级调度（内存调度）</p><pre><code>*   按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</code></pre><ul><li>外存-&gt;内存（面向进程）</li><li>发生频率：中等</li></ul></li><li><p>低级调度（进程调度）</p><pre><code>*   按照某种规则，从就绪队列中选择一个进程为其分配处理机</code></pre><ul><li>内存-&gt;CPU</li><li>发生频率：最高</li></ul></li></ul><h3 id="时机"><a href="#时机" class="headerlink" title=" 时机"></a><a href="#%E6%97%B6%E6%9C%BA"></a> 时机</h3><ul><li><p>什么时候需要进程调度</p><pre><code>*   主动放弃    *   进程正常终止*   运行过程发生异常终止*   主动阻塞（如：等待I/O）*   被动放弃    *   时间片用完*   有更紧急的事情需要处理（如：中断）*   有更高优先级的进程进入就绪队列</code></pre></li><li><p>什么时候不能进行进程调度</p><pre><code>*   处理中断时</code></pre><ul><li>进程在OS内核程序临界区</li><li>原子操作过程中（原语）</li></ul></li></ul><h3 id="方式"><a href="#方式" class="headerlink" title=" 方式"></a><a href="#%E6%96%B9%E5%BC%8F"></a> 方式</h3><ul><li><p>非剥夺调度方式（非抢占式）</p><pre><code>*   只能由当前运行的进程主动放弃CPU</code></pre></li><li><p>剥夺调度方式（抢占式）</p><pre><code>*   可由OS剥夺当前进程的CPU使用权</code></pre></li></ul><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title=" 调度算法的评价指标"></a><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"></a> 调度算法的评价指标</h3><ul><li><p>CPU利用率</p><pre><code>*   利用率=忙碌时间/总时间</code></pre></li><li><p>系统吞吐量</p><pre><code>*   系统吞吐量=总共完成了多少道作业/总共花费时间</code></pre></li><li><p>周转时间</p><pre><code>*   周转时间=作业完成时间-作业提交时间</code></pre><ul><li>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</li><li>带权周转时间&#x3D;作业周转时间&#x2F;作业实际运行时间</li><li>平均带权周转时间&#x3D;各作业带权周转时间之和&#x2F;作业数</li></ul></li><li><p>等待时间</p><pre><code>*   进程/作业等待被服务的时间</code></pre></li><li><p>响应时间</p><pre><code>*   从用户提交请求到首次产出相应所用时间</code></pre></li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title=" 调度算法"></a><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"></a> 调度算法</h3><ul><li><p>先来先服务（FCFS）</p><pre><code>*   算法思想    *   主要从“公平”角度考虑*   算法规则    *   按照作业先后到达顺序进行服务*   可用于作业/进程调度*   非抢占式*   优缺点    *   优点：公平，算法实现简单*   缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即对长作业有利，对短作业不利*   不 会导致饥饿</code></pre></li><li><p>短作业优先（SJF）</p><pre><code>*   算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的 平均平均带权周转时间*   算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求 服务时间最短）*   可用于作业/进程调度（短进程优先SPF）*   非抢占（也有抢占式版本：短剩余时间优先算法SRTN, Shortest Remaining Time Next)*   优缺点    *   优点：“最短的”平均等待时间、平均周转时间*   缺点：不公平。对短作业有利，对长作业不利。*   会 导致饥饿</code></pre></li><li><p>高相应比优先（HRRN）</p><pre><code>*   算法思想    *   综合考虑作业/进程的等待时间和要求服务的时间*   算法规则    *   在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务*   相应比=（等待时间+要求服务时间）/ 要求服务时间*   可用于作业/进程调度*   非抢占*   优缺点    *   综合考虑了等待时间和运行时间。等待时间相同时，要求服务时间短的优先（SJF 的优点） 要求服务时间相同时，等待时间长的优先（FCFS 的优点） 对于长作业来说，随着等待时间越来越久，其响应比也会 越来越大，从而避免了长作业饥饿的问题。*   不会 导致饥饿</code></pre></li><li><p>时间片轮转调度算法(RR)</p><pre><code>*   算法思想    *   公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应*   算法规则    *   按照各进程到达就绪队列的顺序，轮流让各个进程执行一 个时间片（如 100ms）。若进程未在一个时间片内执行完， 则剥夺处理机，将进程重新放到就绪队列队尾重新排队*   用于进程调度*   抢占式*   优缺点    *   优点：公平；响应快，适用于分时操作系统*   缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。*   不会 导致饥饿*   注：时间片大小要合适</code></pre></li><li><p>优先级调度算法</p><pre><code>*   算法思想    *   随着计算机的发展，特别是实时操作系统的出现，越来越 多的应用场景需要根据任务的紧急程度来决定处理顺序*   算法规则    *   子主题 1            *   调度时选择优先级最高的作业/进程*   可用于作业/进程调度*   抢占/非抢占都有    *   区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。*   优缺点    *   优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。*   缺点：若源源不断地有高优先级进程到来，则可能导致饥饿*   会 导致饥饿</code></pre></li><li><p>多级反馈队列调度算法</p><pre><code>*   算法思想    *   对其他算法的折中权衡*   算法规则    *   1.  设置多级就绪队列，各级队列优先级从高到低，时间片从小到大        *   1.  新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时 间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。 如果此时已经是在最下级的队列，则重新放回该队列队尾        *   1.  只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片*   用于进程调度*   抢占式    *   k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾*   优缺点    *   对各类型进程相对公平（FCFS的优点）        *   每个新到达的进程都可以很快就得到响应（RR的优点）        *   短进程只用较少的时间就可完成（SPF的优点）        *   不必实现估计进程的运行时间（避免用户作假）        *   可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程            *   拓展：可以将因I/O而阻塞的进程重新放回原队列，这样        I/O型进程就可以保持较高优先级*   会 导致饥饿</code></pre></li></ul><h2 id="2-3-进程同步与互斥"><a href="#2-3-进程同步与互斥" class="headerlink" title=" 2.3 进程同步与互斥"></a><a href="#23-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"></a> 2.3 进程同步与互斥</h2><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title=" 进程互斥"></a><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"></a> 进程互斥</h3><ul><li><p>概念</p><pre><code>*   （也称 间接制约关系）对临界资源的访问，需要互斥的进行。即同一时间段只能允许一个进程访问该资源</code></pre></li><li><p>对临界资源的访问过程</p><pre><code>*   四个部分    *   进入区            *   检查是否可以进入临界区，若可，需“上锁”        *   临界区            *   访问临界资源        *   退出区            *   解锁        *   剩余区            *   其余代码</code></pre></li><li><p>需遵循的原则</p><pre><code>*   空闲让进*   忙则等待*   优先等待*   让权等待    *   当进程不能进入临界区时，应立即释放处理器，防止进程忙等</code></pre></li><li><p>实现互斥的基本方法</p><pre><code>*   软件实现方法    *   单标志法**   在进入区只做检查，不上锁；在退出区把临界区的使用权转交给另一个进程（相当于在退出区给另一进程“解锁”，给自己上锁）                *   问题                    *   不遵循“空闲让进”原则        *   双标志先检查法**   在进入区先“检查”后“上锁”，退出区“解锁”                *   问题                    *   不遵循“忙则等待”原则        *   双标志后检查法**   在进入区先“上锁”后“检查”，退出区“解锁”                *   问题                    *   不遵循“空闲让进、有限等待”原则        *   Peterson算法**   在进入区“主动争取-主动谦让-检查对方是否想进&amp;amp;己方是否谦让”                *   问题                    *   不遵循“让权等待”原则，会发生“忙等”*   硬件实现方法    *   中断屏蔽方法            *   使用“开/关中断”指令实现    *   优点：简单高效    *   缺点：只适用于单处理机；只适用于OS内核进程        *   硬件指令方法            *   TestAndSet(TS指令/TSL指令)    **   相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。                        *   优点                            *   实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞            *   适用于多处理机环境                        *   缺点                            *   不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。                *   Swap指令（XCHG指令）    **   逻辑同TSL</code></pre></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title=" 信号量机制"></a><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"></a> 信号量机制</h3><ul><li><p>信号量类型</p><pre><code>*   整型信号量    *   用一个整形变量作为信号量，数值表示某种资源数**   与普通整型变量区别：对信号量只能执行初始化、P、V操作        *   问题            *   不满足&quot;让权等待&quot;原则*   记录型信号量</code></pre><p>**   S.value 表示某种资源数，S.L指向等待该资源的队列</p></li><li><p>信号量机制实现进程互斥、同步、前驱关系</p><pre><code>*   实现进程互斥    *   分析问题，确定临界资源*   设置互斥信号量，初值为1*   临界区之前对信号量执行P操作*   临界区之后对信号量执行V操作*   实现进程同步    *   分析问题，找出哪里需要实现&quot;一前一后&quot;的同步关系*   设置同步信号量，初始值为0*   在&quot;前操作&quot;之后执行V操作*   在“后操作”之前执行P操作*   实现进程的前驱关系（本质:多级同步问题）    *   分析问题画出前驱图，把每一对前驱关系都看成一个同步问题*   为每一对前驱关系设置同步信号量，初始值为0*   在&quot;前操作&quot;之后执行V操作*   在“后操作”之前执行P操作</code></pre></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title=" 进程同步"></a><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"></a> 进程同步</h3><ul><li><p>概念</p><pre><code>*   （也称直接制约关系）为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系</code></pre></li><li><p>经典同步问题</p><pre><code>*   生产者-消费者问题</code></pre><ul><li>多生产者-多消费者问题</li><li>吸烟者问题</li><li>读者-写者问题</li><li>哲学家进餐问题</li></ul></li></ul><h3 id="管程"><a href="#管程" class="headerlink" title=" 管程"></a><a href="#%E7%AE%A1%E7%A8%8B"></a> 管程</h3><ul><li><p>为什么引入</p><pre><code>*   解决信号量机制的编程麻烦、易出错的问题</code></pre></li><li><p>组成</p><pre><code>*   共享数据结构</code></pre><ul><li>对数据结构初始化的语句</li><li>一组用来访问数据结构的过程</li></ul></li><li><p>基本特征</p><pre><code>*   各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据</code></pre><ul><li>每次仅允许一个进程在管程内执行某个内部过程</li></ul></li><li><p>补充</p><pre><code>*   可在管程中设置条件变量及等待/唤醒操作以解决同步问题</code></pre></li></ul><h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title=" 2.4 死锁"></a><a href="#24-%E6%AD%BB%E9%94%81"></a> 2.4 死锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title=" 概念"></a><a href="#%E6%A6%82%E5%BF%B5-2"></a> 概念</h3><ul><li>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进</li></ul><h3 id="死锁、饥饿、死循环区别"><a href="#死锁、饥饿、死循环区别" class="headerlink" title=" 死锁、饥饿、死循环区别"></a><a href="#%E6%AD%BB%E9%94%81-%E9%A5%A5%E9%A5%BF-%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8C%BA%E5%88%AB"></a> 死锁、饥饿、死循环区别</h3><ul><li>死锁：至少两个进程，进程处于阻塞态</li><li>饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪</li><li>死循环：可能只有一个进程死循环，死循环的进程可上处理机</li><li>死锁和饥饿是OS要解决的问题，死循环是程序员要解决的问题</li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title=" 死锁产生的必要条件"></a><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"></a> 死锁产生的必要条件</h3><ul><li><p>互斥条件</p></li><li><p>不剥夺条件</p></li><li><p>请求和保持条件</p></li><li><p>循环等待条件</p><pre><code>*   存在一种进程资源的循环等待链</code></pre><ul><li>循环等待未必死锁，死锁一定有循环等待</li></ul></li></ul><h3 id="什么时候发生死锁"><a href="#什么时候发生死锁" class="headerlink" title=" 什么时候发生死锁"></a><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"></a> 什么时候发生死锁</h3><ul><li><p>对不可剥夺资源的不合理分配</p><pre><code>*   对系统资源的竞争</code></pre><ul><li>进程推荐顺序非法</li><li>信号量的使用不当</li></ul></li></ul><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title=" 死锁的处理策略"></a><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"></a> 死锁的处理策略</h3><ul><li><p>不允许死锁发生</p><pre><code>*   预防死锁（静态策略）    *   破坏互斥条件            *   将临界资源改造为可共享使用的资源（SPOOLing技术）    *   缺点：可行性不高，很多时候无法破环互斥条件        *   破坏不剥夺条件            *   方案1：申请的资源得不到满足时，立即释放拥有的所有资源                *   方案2: 申请的资源被其他进程占用时，由OS协助剥夺(考虑优先级)                *   缺点                    *   实现复杂        *   剥夺资源可能导致部分工作失效        *   反复申请和释放导致系统开销大        *   可能导致饥饿        *   破坏请求和保持条件            *   预先静态分配法：运行前分配好所有需要的资源，之后一直保持    *   缺点：资源利用率低; 可能导致饥饿        *   破坏循环等待条件            *   顺序资源分配法：给资源编号，必须按编号从小到大的顺序申请资源                *   缺点：                    *   不方便增加新设备        *   会导致资源浪费        *   用户编程麻烦*   避免死锁（动态策略）    *   银行家算法            *   避免系统进入不安全状态</code></pre></li><li><p>允许死锁发生</p><pre><code>*   死锁的检测和解除    *   如何检测            *   数据结构：资源分配图                    *   两种结点                            *   资源结点            *   进程结点                        *   两种边                            *   请求边（进程结点-&amp;gt;资源结点）            *   分配边（资源结点-&amp;gt;进程结点）                *   死锁检测算法                    *   依次消除与不阻塞进程相连的边，直到无边可消        *   死锁定理：若资源分配图是可不完全简化的，说明发生了死锁        *   如何解除            *   资源剥夺法    *   撤销进程法（终止进程法）    *   进程回退法</code></pre></li></ul><h1 id="ch-3-内存管理"><a href="#ch-3-内存管理" class="headerlink" title=" ch 3 内存管理"></a><a href="#ch-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"></a> ch 3 内存管理</h1><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:100%; height:400px;" src="https://www.processon.com/embed/611b676c0791290d52fadb83"></iframe><h2 id="3-1-进程运行的基本原理"><a href="#3-1-进程运行的基本原理" class="headerlink" title=" 3.1 进程运行的基本原理"></a><a href="#31-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"></a> 3.1 进程运行的基本原理</h2><h3 id="从写程序到程序运行"><a href="#从写程序到程序运行" class="headerlink" title=" 从写程序到程序运行"></a><a href="#%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C"></a> 从写程序到程序运行</h3><ul><li><p>编译</p><pre><code>*   由源代码文件生成目标文件（高级语言“翻译为机器语言”）</code></pre></li><li><p>链接</p><pre><code>*   由目标模块生成装入模块，链接后形成完整的逻辑地址*   三种链接方式    *   静态链接            *   装入前链接成一个完装入模块        *   装入时动态链接            *   运行前边装入边链接        *   运行时动态链接            *   运行时需要目标模块才装入并链接</code></pre></li><li><p>装入</p><pre><code>*   由装入模块装入内存，装入后形成物理地址*   三种装入方式    *   绝对装入            *   编译时产生绝对地址        *   可重定位装入            *   装入时将逻辑地址转换为物理地址        *   动态运行时装入            *   运行时将逻辑地址转换为物理地址，需要设置重定位寄存器</code></pre></li></ul><h2 id="3-2-内存空间的分配与回收"><a href="#3-2-内存空间的分配与回收" class="headerlink" title=" 3.2 内存空间的分配与回收"></a><a href="#32-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"></a> 3.2 内存空间的分配与回收</h2><h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title=" 连续分配方式"></a><a href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"></a> 连续分配方式</h3><p>连续分配：为用户进程分配的必须是一个连续的内存空间。</p><ul><li><p>单一连续分配</p><pre><code>*   只支持单道程序；内存被分为系统区和用户区。 系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；用户区用于存放用户进程相关数据。*   优点    *   实现简单；*   无外部碎片；*   可以采用覆盖技术扩充内存；*   不一定需要采取内存保护（eg：早期的 PC 操作 系统 MS-DOS）*   缺点    *   只能用于单用户、单任务的操作系统中；*   有内部碎片；*   存储器利用率极低</code></pre></li><li><p>固定分区分配</p><pre><code>*   支持多道程序。将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业*   两种分区方式    *   分区大小相等            *   缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合        *   分区大小不等            *   增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分*   优点    *   实现简单；*   无外部碎片*   缺点    *   a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能*   b. 会产生内部碎片，内存利用率低</code></pre></li><li><p>动态分区分配（可变分区分配）</p><pre><code>*   支持多道程序，在进程装入内存时，根据进程大小动态地建立分区*   优缺点    *   无内部碎片，有外部碎片(外部碎片可用“紧凑技术来解决”)*   回收内存分区时的四种情况</code></pre><p>总之，相邻的空闲分区要合并</p><pre><code>    *   回收之后有相邻的空闲分区*   回收之前有相邻的空闲分区*   回收前后都有相邻的空闲分区*   回收前后都无相邻的空闲分区*   动态分区分配算法    *   首次适应算法（First Fit）            *   算法思想                    *   从头到尾找适合的分区                *   分区排序顺序                    *   空闲分区以 地址 递增次序排列                *   优点                    *   综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序        *   最佳适应算法（Best Fit）            *   算法思想                    *   优先使用更小的分区，以保留更多大 分区                *   分区排序顺序                    *   空闲分区以 容量 递增次序排列                *   优点                    *   会有更多的大分区被保留下来，更能满足大进程需求                *   缺点                    *   会产生很多太小的、难以 利用的碎片；            算法开销大， 回收分区后可能需要对空 闲分区队列重新排序        *   最坏适应算法（Worst Fit）            *   算法思想                    *   优先使用更大的分区，以防止产生太小的不可用的碎片                *   分区排序顺序                    *   空闲分区以 容量 递减次序排列                *   优点                    *   可以减少难以利用的 小碎片                *   缺点                    *   大分区容易被用完，不利于大进程；            算法开销大 （原因同上）        *   邻近适应算法（Nest Fit）（循环首次适应）            *   算法思想                    *   由首次适应演变而来，每次从上次查找结束位置开始查找                *   分区排序顺序                    *   空闲分区以 地址 递增次序排列 （可排列成循环链表）                *   优点                    *   不用每次都从低地址 的小分区开始检索。            算法开销小（原因同首次适应算法）                *   缺点                    *   会使高地址的大分区也被用完</code></pre></li></ul><h3 id="非连续分配方式"><a href="#非连续分配方式" class="headerlink" title=" 非连续分配方式"></a><a href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"></a> 非连续分配方式</h3><p>非连续分配：为用户进程分配的可以是一些分散的内存空间。</p><ul><li><p>基本分页存储管理</p><pre><code>*   基本概念    *   基本分页存储管理的思想：把进程分页，各个页面可离散地放到各个内存块中        *   易混淆概念            *   “页、页面”VS“页框、页帧、内存块、物理块、物理页”    *   “页号、页面号”VS“页框号、页帧号、内存块号、物理块号、物理页号”        *   页表            *   页表记录了页面和实际存放的内存块之间的映射关系    *   一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和块号组成    *   每个页表项的大小相同，页号是“隐含”的    *   i号页表存放地址=页表始址+i*页表项大小        *   逻辑地址结构—【页号P，页内偏移量W】            *   页号=逻辑地址/页面大小    *   页内偏移=逻辑地址%页面大小        *   地址转换            *   1.  计算出逻辑地址对应的【页号，页内偏移】                *   1.  找到对应页面在内存中的存放位置（查页表）                *   1.  物理地址=页面始址+页内偏移量*   基本地址变换机构    *   页表寄存器的作用            *   存放页表起始地址    *   存放页表长度        *   地址变换过程**   1.  根据逻辑地址算出页号、页内偏移量                *   1.  检查页号是否合法（对比页表长度），不合法产生越界中断                *   1.  若页号合法，再根据页表起始地址、页号找到对应页表项                *   1.  根据页表项中的内存块号、页内偏移量 得到最终物理地址                *   1.  访问物理内存对应的内存单元        *   访存次数            *   两次        *   其他注意点            *   页内偏移量位移与页面大小之间的关系（要能用其中一个条件退出另一个条件）    *   页式管理中地址是一维的    *   实际应用中，通常使一个页框恰好能放入整数个页表项    *   为了方便找到页表项，页表一般是放在连续的内存块中*   具有快表的地址变换机构    *   快表（又称联想寄存器 TLB， translationlookasidebuffer）            *   一种访问速度比内存快很多的高速缓存（TLB不是内存！）                *   用来存放最近访问的页表项的副本，可以加速地址变换的速度。                *   与此对应，内存中的页表常称为慢表                *   TLB 和 普通 Cache 的区别                    *   TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本        *   地址变换过程**   ①算页号、页内偏移量    *   ②检查页号合法性    *   ③查快表。        若命中，即可知道页面存放的内存块号，可直接进行⑤ ；若未命中则进行④    *   ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中    *   ⑤根据内存块号与页内偏移量得到物理地址    *   ⑥访问目标内存单元        *   访存次数            *   快表命中，只需一次访存快表未命中，需要两次访存*   两级页表    *   单级页表存在的问题            *   所有页表必须连续存放，页表过大时需要很大的连续空间    *   在一段时间内并非所有的页面都用得到，因此没必要让整个页表常驻内存        *   两级页表            *   将页表再分页    *   逻辑地址结构：（一级页号，二级页号，页内偏移量）    *   注意术语：页目录表/外层页表/顶级页表        *   如何实现地址变换            *   ①按照地址结构将逻辑地址拆分成三部分    *   ②从PCB 中读出页目录表始址，再根据一级页号查页目录 表，找到下一级页表在内存中的存放位置    *   ③根据二级页号查二级页表，找到最终想访问的内存块号    *   ④结合页内偏移量得到物理地址        *   几个细节            *   多级页表中，个几页表的大小不能超过一个页面。若两级页表不够，可以分更多级    *   多级页表的访存次数（无快表机构时）：N级页表访问一个逻辑地址需要N+1次访存</code></pre></li><li><p>基本分段存储管理</p><pre><code>*   分段    *   进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址*   内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。*   逻辑地址结构：（段号，段内地址）*   段表    *   1.  每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称 “基址”）和段的长度。        *   1.  各个段表项的长度是相同的。*   地址变换</code></pre><ul><li></li></ul><pre><code>*   分段VS分页    *   分页对用户不可见，分段对用户可见*   分页的地址空间是一维的，分段的地址空间是二维的*   分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）*   分页（单级页表）、分段访问一个逻辑地址都需要两次访存，分段存储也可以引入快表机构</code></pre></li><li><p>段页式存储管理</p><pre><code>*   分段+分页    *   将地址空间按照程序自身的逻辑关系划分为若干个段，再将各段分为大小相等的页面*   将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存*   逻辑地址结构：（段号，页号，页内偏移量）*   段表、页表    *   每个段对应一个段表项。各段表项长度相同，由段号（隐含）、页表长度、页表存放块号（页表起始 地址）组成。*   每个页面对应一个页表项，各页表项长度相同，由页号（隐含）、页面存放的内存块号组成。*   地址变换</code></pre><ul><li></li></ul><pre><code>*   访问一个逻辑地址所需访存次数    *   第一次：查段表、第二次：查页表、第三次：访问目标单元*   可引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存</code></pre></li></ul><h2 id="3-3-内存空间的扩充"><a href="#3-3-内存空间的扩充" class="headerlink" title=" 3.3 内存空间的扩充"></a><a href="#33-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"></a> 3.3 内存空间的扩充</h2><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title=" 覆盖与交换"></a><a href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"></a> 覆盖与交换</h3><ul><li><p>覆盖技术</p><pre><code>*   一个固定区    *   存放最活跃的程序段*   固定区中的程序段在运行过程中不会被调入调出*   若干覆盖区    *   不可能同时被访问的程序段可共享一个覆盖区*   覆盖区中的程序段在运行过程中会根据需要调入调出*   必须由程序员声明覆盖结构，OS完成自动覆盖*   缺点：对用户不透明，增加了用户编程负担</code></pre></li><li><p>交换技术</p><pre><code>*   内存紧张时，换出某些进程以腾出内存空间，再换入某些进程</code></pre><ul><li>磁盘分为文件区和对换区，换出的进程放在对换区</li></ul></li><li><p>覆盖与交换的区别</p><pre><code>*   覆盖是在同一进程或程序中的</code></pre><ul><li>交换在不同的进程（或作业）中</li></ul></li></ul><h3 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title=" 虚拟存储技术"></a><a href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"></a> 虚拟存储技术</h3><ul><li><p>传统存储管理方式的特征和缺点</p><pre><code>*   一次性：作业数据必须一次全部调入内存</code></pre><ul><li>驻留性：作业数据整个运行期间都会常驻内存</li></ul></li><li><p>局部性原理</p><pre><code>*   时间局部性：现在访问的指令、数据不久之后很可能再次访问</code></pre><ul><li>空间局部性：现在访问的内存单元周围的内存空间，很可能在不久之后会被访问</li><li>高速缓存技术：使用频繁的数据放到更高速的存储器中</li></ul></li><li><p>虚拟内存的定义和特征</p><pre><code>*   程序不需要全部装入即可运行，运行时根据需要动态调整调入数据，若内存不过，还需换出一些数据*   特征    *   多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存*   对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换 入、换出*   虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</code></pre></li><li><p>如何实现虚拟内存技术</p><pre><code>*   【请求调页功能】：当所访问的信息不在内存时，由OS负责将所需信息从外存调入内存*   【页面置换功能】：若内存空间不够，由操作系统负责将内存 中暂时用不到的信息换出到外存*   虚拟内存的实现    *   请求分页存储管理            *   页表机制（在基本分页基础上增加了4个表项）                    *   状态位: 是否已调入内存        *   访问字段：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考        *   修改位：页面调入内存后是否被 修改过        *   外存地址：页面在外存中的存放位 置                *   缺页中断机构                    *   找到页表后，检查页面是否已在内存中，若不在，产生一个缺页中断        *   缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面        *   缺页中断属于内中断中的“故障”，即可能被系统修复的异常        *   一条指令执行过程中可能产生多次缺页中断                *   地址变换机构    *                *   页面置换算法    页面的换入、换出需要磁盘 I/O，会有较大的开销，因        此好的页面置换算法应该追求更少的缺页率                    *   最佳置换算法（OPT）                            *   算法规则：优先淘汰最长时间内不会被访问的页面            *   优缺点：缺页率最小，性能最好； 但无法实现                        *   先进先出置换算法（FIFO）                            *   算法规则：优先淘汰最先进入内存的页面            *   优缺点：实现简单；但性能很差， 可能出现Belady异常                        *   最近最久未使用算法（LRU）                            *   算法规则：LRU 优先淘汰最近最久没访问的页面            *   优缺点：性能很好；但需要硬件（寄存器和栈）支持，算法开销大                        *   时钟置换算法（CLOCK）                            *   算法规则：循环扫描各页面，第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描            *   优缺点：实现简单，算法开销小； 但未考虑页面是否被修改过。                        *   改进型的时钟置换算法                            *   算法规则：                若用（访问位, 修改位）的形式表述，则                第一轮：淘汰（0, 0）                第二轮：淘汰（0, 1），并将扫描过的页面访问位都置为0                第三轮：淘汰（0, 0）                第四轮：淘汰（0, 1）            *   优缺点：算法开销较小，性能也不错                *   页面分配策略                    *   驻留集                            *   指请求分页存储管理中给进程分配的物理块的集合                        *   页面分配、置换策略                            *   固定分配 VS 可变分配：区别在于运行期间驻留集大小是否可变            *   局部置换 VS 全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出            *   固定分配局部置换：进程运行前就分配一定数量的物理块，缺页时只能换出进程自己的某一页            *   可变分配全局置换：只要缺页就分配，可能来自空闲物理块，也可能需要换出别的进程的页面            *   可变分配局部置换：频繁却页的进程多分配一些物理块；缺页率低的进程，回收一些物理块。直到缺页率合适                        *   何时调入页面                            *   预调页策略：一般用于进程运行前            *   请求调页策略：进程运行时，发现缺页再调页                        *   从何处调入页面                            *   对换区：读/写 速度更快，采用连续分配方式            *   文件区：读/写 速度更慢，采用离散分配方式            *   对换区足够大：运行前将数据从文件区复制到对换区，之后所有页面的调入、调出都是在内存与对换区之间进行            *   对换区不够大：凡是不会被修改的数据都直接从文件区调入；可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。            *   UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都从文件区调入。被使用过的页面写回对换区，下次需要时从对换区调入                        *   抖动（颠簸现象）                            *   刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸            *   产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）                        *   工作集                            *   指在某段时间间隔里，进程实际访问页面的集合            *   一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页        *   请求分段存储管理        *   请求段页式存储管理</code></pre></li></ul><h2 id="3-4-地址转换"><a href="#3-4-地址转换" class="headerlink" title=" 3.4 地址转换"></a><a href="#34-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"></a> 3.4 地址转换</h2><h3 id="OS负责实现逻辑地址到物理地址的转化"><a href="#OS负责实现逻辑地址到物理地址的转化" class="headerlink" title=" OS负责实现逻辑地址到物理地址的转化"></a><a href="#os%E8%B4%9F%E8%B4%A3%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E5%8C%96"></a> OS负责实现逻辑地址到物理地址的转化</h3><h3 id="三种方式"><a href="#三种方式" class="headerlink" title=" 三种方式"></a><a href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"></a> 三种方式</h3><ul><li><p>绝对装入</p><pre><code>*   编译器负责地址转换（单道程序，无OS）</code></pre></li><li><p>可重定位装入</p><pre><code>*   装入程序负责地址转换（早期多道批处理阶段）</code></pre></li><li><p>动态运行时装入</p><pre><code>*   运行时才进行地址转换（现代OS）</code></pre></li></ul><h2 id="3-5-存储保护"><a href="#3-5-存储保护" class="headerlink" title=" 3.5 存储保护"></a><a href="#35-%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"></a> 3.5 存储保护</h2><h3 id="保证各进程在自己的内存空间内运行，不会越界访问"><a href="#保证各进程在自己的内存空间内运行，不会越界访问" class="headerlink" title=" 保证各进程在自己的内存空间内运行，不会越界访问"></a><a href="#%E4%BF%9D%E8%AF%81%E5%90%84%E8%BF%9B%E7%A8%8B%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%86%85%E8%BF%90%E8%A1%8C%E4%B8%8D%E4%BC%9A%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE"></a> 保证各进程在自己的内存空间内运行，不会越界访问</h3><h3 id="两种方式"><a href="#两种方式" class="headerlink" title=" 两种方式"></a><a href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"></a> 两种方式</h3><ul><li>设置上下限寄存器</li><li>利用重定位寄存器、界地址寄存器进行判断</li></ul><h1 id="ch-4-文件管理"><a href="#ch-4-文件管理" class="headerlink" title=" ch 4 文件管理"></a><a href="#ch-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"></a> ch 4 文件管理</h1><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:100%; height:400px;" src="https://www.processon.com/embed/611b67c0e0b34d01d7802ac7"></iframe><h2 id="4-1-文件的基本概念"><a href="#4-1-文件的基本概念" class="headerlink" title=" 4.1 文件的基本概念"></a><a href="#41-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a> 4.1 文件的基本概念</h2><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title=" 文件的属性"></a><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"></a> 文件的属性</h3><ul><li>文件类型</li><li>文件长度</li><li>文件的物理位置</li><li>文件的创建信息</li></ul><h3 id="文件名"><a href="#文件名" class="headerlink" title=" 文件名"></a><a href="#%E6%96%87%E4%BB%B6%E5%90%8D"></a> 文件名</h3><ul><li>文件名</li><li>扩展名</li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title=" 文件类型"></a><a href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"></a> 文件类型</h3><ul><li><p>按用途分类</p><pre><code>*   系统文件</code></pre><ul><li>用户文件</li><li>库文件</li></ul></li><li><p>按文件中的数据类型分类</p><pre><code>*   源文件</code></pre><ul><li>目标文件</li><li>可执行文件</li></ul></li><li><p>按存取控制属性分类</p><pre><code>*   只执行文件</code></pre><ul><li>只读文件</li><li>读写文件</li></ul></li><li><p>按组织形式和处理方式分类</p><pre><code>*   普通文件</code></pre><ul><li>目录文件</li><li>特殊文件</li></ul></li></ul><h2 id="4-2-文件的逻辑结构"><a href="#4-2-文件的逻辑结构" class="headerlink" title=" 4.2 文件的逻辑结构"></a><a href="#42-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"></a> 4.2 文件的逻辑结构</h2><h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title=" 有结构文件"></a><a href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"></a> 有结构文件</h3><ul><li>文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。</li></ul><h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title=" 无结构文件"></a><a href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"></a> 无结构文件</h3><ul><li><p>由一组相似的记录组成，又称“记录式文件”</p></li><li><p>逻辑结构</p><pre><code>*   顺序文件    *   串结构：记录顺序与关键字无关*   顺序结构：记录按关键字顺序排序*   可变长记录的顺序文件无法实现随机存取，定长记录可以*   定长记录、顺序结构的顺序文件可以快速检索（根据关键字快速记录）*   最大缺点：不方便增加/删除记录*   索引文件    *   建立一张索引表，每个记录对应一个表项。个记录不用保持顺序，方便增加/删除记录*   索引表本身就是定长记录的顺序文件，一个索引表就是一条定长记录，因此，索引文件可以支持随机存取*   若索引表按关键字顺序排列，则可只是快速检索*   解决了文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取。但索引表可能占用很多空间*   顺序索引文件    *   将记录分组，每组对应一个索引表项*   检索记录时先顺序查索引表，找到分组，在顺序查找分组*   当记录过多时，可建立多级索引表</code></pre></li></ul><h2 id="4-3-文件目录"><a href="#4-3-文件目录" class="headerlink" title=" 4.3 文件目录"></a><a href="#43-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"></a> 4.3 文件目录</h2><h3 id="文件目录的实现"><a href="#文件目录的实现" class="headerlink" title=" 文件目录的实现"></a><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0"></a> 文件目录的实现</h3><ul><li>一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成文件目录</li><li>对目录的操作：搜索、创建、删除文件、显示文件、修改文件</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title=" 目录结构"></a><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"></a> 目录结构</h3><ul><li><p>单机目录结构</p><pre><code>*   一个系统只有一张目录表，不允许文件重名</code></pre></li><li><p>两级目录结构</p><pre><code>*   不同用户的文件可以重名，但不能对文件进行分类</code></pre></li><li><p>多级（树形）目录结构</p><pre><code>*   不同目录下的文件可以重名，可以对文件进行分类，不方便文件共享</code></pre><ul><li>系统根据”文件路径”找到目标文件</li><li>从根目录出发的路径是“绝对路径”</li><li>从“当前目录”出发的路径是“相对路径”</li></ul></li><li><p>无环图目录结构</p><pre><code>*   在树形目录结构的基础上，增加一些指向同一节点的有向边，是整个目录成为一个DAG</code></pre><ul><li>为共享结点设置一个共享计数器，计数器为0时才真正删除该节点</li></ul></li></ul><h3 id="索引节点"><a href="#索引节点" class="headerlink" title=" 索引节点"></a><a href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"></a> 索引节点</h3><ul><li>除了文件名之外的所有信息都放到索引节点</li><li>目录项中只包含文件名、索引结点指针，因此目录项的长度答复减少</li><li>由于目录项长度减少，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘的I&#x2F;O次数就少了很多</li></ul><h2 id="4-4-OS需要对磁盘块进行哪些管理？"><a href="#4-4-OS需要对磁盘块进行哪些管理？" class="headerlink" title=" 4.4 OS需要对磁盘块进行哪些管理？"></a><a href="#44-os%E9%9C%80%E8%A6%81%E5%AF%B9%E7%A3%81%E7%9B%98%E5%9D%97%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E7%AE%A1%E7%90%86"></a> 4.4 OS需要对磁盘块进行哪些管理？</h2><h3 id="对非空闲磁盘块的管理：文件的物理结构（文件的分配方式）"><a href="#对非空闲磁盘块的管理：文件的物理结构（文件的分配方式）" class="headerlink" title=" 对非空闲磁盘块的管理：文件的物理结构（文件的分配方式）"></a><a href="#%E5%AF%B9%E9%9D%9E%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"></a> 对非空闲磁盘块的管理：文件的物理结构（文件的分配方式）</h3><ul><li><p>连续分配</p><pre><code>*   连续分配方式要求每个文件在磁盘上占有一组连续的块</code></pre><ul><li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</li><li>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li><li><p>链接分配</p><pre><code>*   隐式链接    *   除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针*   优点：很方便文件拓展，不会有碎片问题，外存利用率高。*   缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。*   显式链接    *   把用于链接文件各物理块的指针显式地存放在一张表中，即 文件分配表（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内 存*   优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接 来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。*   缺点：文件分配表的需要占用一定的存储空间。</code></pre></li><li><p>索引分配</p><pre><code>*   索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块 。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。*   文件太大，索引表项太多时的解决方案    *   链接方案*   多层索引*   混合索引*   优点：支持随机访问，易于实现文件的拓展*   缺点：索引表需占用一定的存储空间。访问数据块前需要先读入索引块。若采用链接方案，查找索引块时可能需要很多次读磁盘操作</code></pre></li></ul><h3 id="对空闲磁盘块的管理：文件存储空间管理"><a href="#对空闲磁盘块的管理：文件存储空间管理" class="headerlink" title=" 对空闲磁盘块的管理：文件存储空间管理"></a><a href="#%E5%AF%B9%E7%A9%BA%E9%97%B2%E7%A3%81%E7%9B%98%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"></a> 对空闲磁盘块的管理：文件存储空间管理</h3><ul><li><p>存储空间的划分与初始化</p><pre><code>*   文件卷（逻辑卷），目录区、文件区的概念</code></pre><ul><li>目录区包含文件目录、空闲表、位示图、超级块等用于文件管理的数据</li></ul></li><li><p>空闲表法</p><pre><code>*   空闲表中记录每个连续空闲区的起始盘块号、盘块数</code></pre><ul><li>分配时可采用首次适应、最佳适应等策略；回收时注意表项的合并</li></ul></li><li><p>空闲链表法</p><pre><code>*   空闲盘块链    *   以盘块为单位组成的一条空闲链*   分配时从链头依次取出空闲块，回收时将空闲块插到链尾*   空闲盘区链    *   以盘区为单位组成的一条空闲链*   分配时可采用首次适应、最佳适应等策略；回收时注意相邻空闲盘区合并的问题</code></pre></li><li><p>位示图法</p><pre><code>*   一个二进制位对应一个盘块。（字号，位号）或（行号，列号）与盘块号一一对应</code></pre><ul><li>注：盘块号 与 （字号，位号）的相互转换</li></ul></li><li><p>成组链接法</p><pre><code>*   UNIX采用的策略，适合大型文件</code></pre></li></ul><h2 id="4-5-文件的基本操作"><a href="#4-5-文件的基本操作" class="headerlink" title=" 4.5 文件的基本操作"></a><a href="#45-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"></a> 4.5 文件的基本操作</h2><h3 id="创建文件（-Create-系统调用）"><a href="#创建文件（-Create-系统调用）" class="headerlink" title=" 创建文件（ Create 系统调用）"></a><a href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6-create-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a> 创建文件（ Create 系统调用）</h3><ul><li>分配外存空间，创建目录项</li></ul><h3 id="删除文件（Delete-系统调用）"><a href="#删除文件（Delete-系统调用）" class="headerlink" title=" 删除文件（Delete 系统调用）"></a><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6delete-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a> 删除文件（Delete 系统调用）</h3><ul><li>回收外存空间，删除目录项</li></ul><h3 id="打开文件（open-系统调用）"><a href="#打开文件（open-系统调用）" class="headerlink" title=" 打开文件（open 系统调用）"></a><a href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6open-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a> 打开文件（open 系统调用）</h3><ul><li>将目录项中的信息复制到内存中的打开文件表中，并将打开文件表中的索引号返回给用户</li><li>打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作</li><li>每个进程都有自己的打开文件表，系统中也有一张总的打开文件表</li><li>进程打开文件表中的特有属性：读写指针、访问权限（只读？只写？）</li><li>进程打开文件表中的特有属性：打开计数器（有多少个进程打开了该文件）</li></ul><h3 id="关闭文件（Close-系统调用）"><a href="#关闭文件（Close-系统调用）" class="headerlink" title=" 关闭文件（Close 系统调用）"></a><a href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6close-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a> 关闭文件（Close 系统调用）</h3><ul><li>将进程打开文件表中的相应表项删除</li><li>系统打开文件表的打开计数器-1，若打开计数器&#x3D;0，则删除系统表的表项</li></ul><h3 id="读文件（read系统调用）"><a href="#读文件（read系统调用）" class="headerlink" title=" 读文件（read系统调用）"></a><a href="#%E8%AF%BB%E6%96%87%E4%BB%B6read%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a> 读文件（read系统调用）</h3><ul><li>根据读指针、读入数据量、内存位置将文件数据从外存读入内存</li></ul><h3 id="写文件（write-系统调用）"><a href="#写文件（write-系统调用）" class="headerlink" title=" 写文件（write 系统调用）"></a><a href="#%E5%86%99%E6%96%87%E4%BB%B6write-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a> 写文件（write 系统调用）</h3><ul><li>根据写指针、写出数据量、内存位置 将文件数据从内存写出外存</li></ul><h2 id="4-6-文件共享"><a href="#4-6-文件共享" class="headerlink" title=" 4.6 文件共享"></a><a href="#46-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"></a> 4.6 文件共享</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title=" 硬链接"></a><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"></a> 硬链接</h3><ul><li>各个用户的目录项指向同一个索引节点</li><li>索引结点中需要有链接计数count</li><li>某用户删除文件时，只是删除该用户的目录项，且count–</li><li>只用count&#x3D;&#x3D;0时，才真正删除文件数据和索引结点，否则会导致指针悬空</li></ul><h3 id="软链接（符号链接）"><a href="#软链接（符号链接）" class="headerlink" title=" 软链接（符号链接）"></a><a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"></a> 软链接（符号链接）</h3><ul><li>在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式）</li><li>OS根据路径一层层查找目录，最终找到共享文件</li><li>即便软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</li><li>由于通过软连接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问共享文件的速度要比硬链接更慢</li></ul><h2 id="4-7-文件保护"><a href="#4-7-文件保护" class="headerlink" title=" 4.7 文件保护"></a><a href="#47-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"></a> 4.7 文件保护</h2><h3 id="口令保护"><a href="#口令保护" class="headerlink" title=" 口令保护"></a><a href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"></a> 口令保护</h3><ul><li>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”，由系统验证口令是否正确</li><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</li><li>缺点：正确的“口令”一般存放在文件对应的 FCB 或索引结点中，即系统内部，不够安全。</li></ul><h3 id="加密保护"><a href="#加密保护" class="headerlink" title=" 加密保护"></a><a href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"></a> 加密保护</h3><ul><li>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密</li><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码&#x2F;译码（加密&#x2F;解密）要花费一定时间。</li></ul><h3 id="访问控制"><a href="#访问控制" class="headerlink" title=" 访问控制"></a><a href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"></a> 访问控制</h3><ul><li>在每个文件的FCB（或索引结点）中增加一个访问控制列表（ACL），记录各个用户（或各组用户）对文件的访问权限</li><li>对文件的访问类型：读&#x2F;写&#x2F;执行&#x2F;执行&#x2F;删除…</li><li>实现灵活可以实现复杂的文件保护功能</li></ul><h2 id="4-8-文件系统的层次结构"><a href="#4-8-文件系统的层次结构" class="headerlink" title=" 4.8 文件系统的层次结构"></a><a href="#48-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"></a> 4.8 文件系统的层次结构</h2><h2 id="4-9-磁盘"><a href="#4-9-磁盘" class="headerlink" title=" 4.9 磁盘"></a><a href="#49-%E7%A3%81%E7%9B%98"></a> 4.9 磁盘</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title=" 基本概念"></a><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"></a> 基本概念</h3><ul><li><p>磁盘、磁道、扇区</p></li><li><p>盘面、柱面</p></li><li><p>磁盘的物理地址</p><pre><code>*   （柱面号，盘面号，扇区号）</code></pre></li></ul><h3 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title=" 磁盘的分类"></a><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB"></a> 磁盘的分类</h3><ul><li><p>根据磁头是否可移动</p><pre><code>*   固定头磁盘（每个磁道有一个磁头）</code></pre><ul><li>移动头磁盘（每个盘面只有一个磁头）</li></ul></li><li><p>根据盘片是否可更换</p><pre><code>*   固定盘磁盘</code></pre><ul><li>可换盘磁盘</li></ul></li></ul><h3 id="一次磁盘读-x2F-写操作需要的时间"><a href="#一次磁盘读-x2F-写操作需要的时间" class="headerlink" title=" 一次磁盘读&#x2F;写操作需要的时间"></a><a href="#%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4"></a> 一次磁盘读&#x2F;写操作需要的时间</h3><ul><li>寻道时间：启动磁臂，移动磁头所花的时间</li><li>延迟时间：将目标扇区转到磁头下面所花的时间</li><li>传输时间：读&#x2F;写 数据花的时间</li></ul><h3 id="减少寻道时间：磁盘调度算法"><a href="#减少寻道时间：磁盘调度算法" class="headerlink" title=" 减少寻道时间：磁盘调度算法"></a><a href="#%E5%87%8F%E5%B0%91%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"></a> 减少寻道时间：磁盘调度算法</h3><ul><li><p>先来先服务（FCFS）</p><pre><code>*   根据进程请求访问磁盘的先后顺序进行调度。</code></pre><ul><li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li><li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长</li></ul></li><li><p>最短寻道时间优先（SSTF）</p><pre><code>*   优先处理的磁道是与当前磁头最近的磁道</code></pre><ul><li>优点：性能较好，平均寻道时间短</li><li>缺点：可能导致饥饿</li></ul></li><li><p>扫描算法（电梯算法，SCAN）</p><pre><code>*   只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动*   优点：性能较好，平均寻道时间较短，不会产生饥饿现象*   缺点：对各个位置磁道的响应频率不平均*   改进算法    *   LOOK算法：只要在磁头移动方向不再有请求，就立即改变磁头方向</code></pre></li><li><p>循环扫描算法（C-SCAN）</p><pre><code>*   规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。*   改进算法    *   C-LOOK算法：只要在磁头移动方向不再有请求，就立即改变磁头方向</code></pre></li></ul><h3 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title=" 减少延迟时间的方法"></a><a href="#%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"></a> 减少延迟时间的方法</h3><ul><li><p>交替编号</p><pre><code>*   让编号相邻的扇区在物理上不相邻</code></pre><ul><li>原理：读完一个扇区后需要一段时间处理才可以继续读下一个扇区</li></ul></li><li><p>错位命名</p><pre><code>*   让相邻盘面的扇区编号“错位”</code></pre><ul><li>原理：读完一个扇区后需要一段时间处理才可以继续读下一个扇区</li></ul></li></ul><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title=" 磁盘的管理"></a><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"></a> 磁盘的管理</h3><ul><li><p>磁盘初始化</p><pre><code>*   低级格式化/物理格式化：划分扇区</code></pre><ul><li>磁盘分区（C盘，D盘…）</li><li>逻辑格式化：建立文件系统（建立根目录文件、建立用于管理存储空间的数据结构）</li></ul></li><li><p>引导块</p><pre><code>*   计算机启动时需要运行初始化程序（自举程序）来完成初始化</code></pre><ul><li>ROM中存放很小的自举装入程序</li><li>完整的自举程序存放在初始化块（引导块）中</li></ul></li><li><p>坏块的管理</p><pre><code>*   简单的磁盘：逻辑格式化时将坏块标记出来</code></pre><ul><li>复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</li></ul></li></ul><h1 id="ch-5-I-x2F-O管理"><a href="#ch-5-I-x2F-O管理" class="headerlink" title=" ch 5 I&#x2F;O管理"></a><a href="#ch-5-io%E7%AE%A1%E7%90%86"></a> ch 5 I&#x2F;O管理</h1><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:100%; height:400px;" src="https://www.processon.com/embed/611b67ec1e0853164d2b5605"></iframe><h2 id="5-1-I-x2F-O设备的概念和基本分类"><a href="#5-1-I-x2F-O设备的概念和基本分类" class="headerlink" title=" 5.1 I&#x2F;O设备的概念和基本分类"></a><a href="#51-io%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB"></a> 5.1 I&#x2F;O设备的概念和基本分类</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title=" 概念"></a><a href="#%E6%A6%82%E5%BF%B5-3"></a> 概念</h3><ul><li>将数据输入&#x2F;输出计算机的外部设备</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title=" 分类"></a><a href="#%E5%88%86%E7%B1%BB"></a> 分类</h3><ul><li><p>按使用特性分</p><pre><code>*   人机交互类外部设备</code></pre><ul><li>存储设备</li><li>网络通信设备</li></ul></li><li><p>按传输速率分</p><pre><code>*   低速设备</code></pre><ul><li>中速设备</li><li>高速设备</li></ul></li><li><p>按信息交换的单位分</p><pre><code>*   块设备（传输快，可寻址）</code></pre><ul><li>字符设备（传输慢，不可寻址，常采用中断驱动方式）</li></ul></li></ul><h2 id="5-2-I-x2F-O设备"><a href="#5-2-I-x2F-O设备" class="headerlink" title=" 5.2 I&#x2F;O设备"></a><a href="#52-io%E8%AE%BE%E5%A4%87"></a> 5.2 I&#x2F;O设备</h2><h3 id="机械部件"><a href="#机械部件" class="headerlink" title=" 机械部件"></a><a href="#%E6%9C%BA%E6%A2%B0%E9%83%A8%E4%BB%B6"></a> 机械部件</h3><ul><li>键盘、鼠标…（用来执行具体I&#x2F;O操作）</li></ul><h3 id="电子部件"><a href="#电子部件" class="headerlink" title=" 电子部件"></a><a href="#%E7%94%B5%E5%AD%90%E9%83%A8%E4%BB%B6"></a> 电子部件</h3><ul><li><p>I&#x2F;O控制器（又称 设备控制器）</p><pre><code>*   主要功能    *   接受和识别CPPU发出的命令            *   如CPU发来的 read/write 命令，I/O控制器中会有相应的 “控制寄存器“ 来存放命令和参数        *   向CPU报告设备的状态            *   I/O控制器中会有相应的 ”状态寄存器“ ，用于记录I/O设备的当前状态。如：1表示空闲，0表示忙碌        *   数据交换            *   I/O控制器中会设置相应的 ”数据寄存器“。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据        *   地址识别            *   类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器*   组成    *   CPU与控制器的接口*   I/O逻辑*   控制器与设备的接口</code></pre></li><li></li></ul><pre><code>    *   两种寄存器编址方式        *   内存映射I/O                *   控制器中的寄存器与内存地址统一编址        *   优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作            *   寄存器独立编址                *   控制器中的寄存器使用单独的地址        *   缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</code></pre><h2 id="5-3-I-x2F-O控制方式"><a href="#5-3-I-x2F-O控制方式" class="headerlink" title=" 5.3 I&#x2F;O控制方式"></a><a href="#53-io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"></a> 5.3 I&#x2F;O控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title=" 程序直接控制方式"></a><a href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"></a> 程序直接控制方式</h3><p>**   CPU干预频率：极高</p><ul><li>每次I&#x2F;O的数据传输单位：字</li><li>数据流向：设备-&gt;CPU-&gt;内存（内存-&gt;CPU-&gt;设备）</li><li>优点：实现简单。在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可</li><li>缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态 ，CPU利用率低。</li></ul><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title=" 中断驱动方式"></a><a href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"></a> 中断驱动方式</h3><p>**   CPU干预频率：高</p><ul><li>每次I&#x2F;O的数据传输单位：字</li><li>数据流向：设备-&gt;内存（内存-&gt;设备）</li><li>优点：CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升</li><li>缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li></ul><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title=" DMA方式"></a><a href="#dma%E6%96%B9%E5%BC%8F"></a> DMA方式</h3><p>**   CPU干预频率：中</p><ul><li>每次I&#x2F;O的数据传输单位：块</li><li>数据流向：设备-&gt;内存（内存-&gt;设备）</li><li>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I&#x2F;O设备的并行性得到提升。</li><li>缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成。</li></ul><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title=" 通道控制方式"></a><a href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"></a> 通道控制方式</h3><p>**   CPU干预频率：低</p><ul><li>每次I&#x2F;O的数据传输单位：一组块</li><li>数据流向：设备-&gt;内存（内存-&gt;设备）</li><li>缺点：实现复杂，需要专门的通道硬件支持</li><li>优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高。</li></ul><h2 id="5-4-I-x2F-O软件层次结构"><a href="#5-4-I-x2F-O软件层次结构" class="headerlink" title=" 5.4 I&#x2F;O软件层次结构"></a><a href="#54-io%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"></a> 5.4 I&#x2F;O软件层次结构</h2><h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title=" 用户层软件"></a><a href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"></a> 用户层软件</h3><ul><li><p>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作</p></li><li><p>假脱机技术（SPOOLing技术）</p><pre><code>*   用软件的方式模拟脱机技术</code></pre><ul><li>输入井&#x2F;输出井——模拟脱机输入&#x2F;输出时的磁带</li><li>输入进程&#x2F;输出进程——模拟脱机输入&#x2F;输出时的外围控制机</li><li>输入缓冲区&#x2F;输出缓冲区——内存中的缓冲区，输出输出时的中转站</li><li>实例：共享打印机（用SPOOLing技术将独占式的打印机”虚拟“成共享打印机）</li></ul></li></ul><h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title=" 设备独立性软件"></a><a href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"></a> 设备独立性软件</h3><ul><li><p>①向上层提供统一的调用接口（如 read&#x2F;write 系统调用）</p></li><li><p>②设备保护</p></li><li><p>③差错处理</p></li><li><p>④设备的分配与回收</p><pre><code>*   应考虑的因素    *   固有属性            *   独占设备、共享设备、虚拟设备        *   分配算法            *   先来先服务、优先级、短任务优先        *   安全性            *   安全分配方式    *   不安全分配方式*   静态分配与动态分配    *   静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏”请求和保持“条件）*   动态分配：进程运行过程中动态申请设备资源*   设备分配管理中的数据结构    *   设备控制表（DCT）            *   系统为每个设备配置一张DCT，用于记录设备情况</code></pre></li><li></li></ul><pre><code>            *   控制器控制表（COCT）                *   每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</code></pre><ul><li></li></ul><pre><code>            *   通道控制表（CHCT）                *   每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</code></pre><ul><li></li></ul><pre><code>            *   系统设备表（SDT）                *   记录了系统中全部设备的情况，每个设备对应一个表目</code></pre><ul><li></li></ul><pre><code>    *   设备分配的步骤        *   ①根据进程请求的物理设备名查找SDT;        ②根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程;        ③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程;        ④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。            *   缺点                *   ①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程 ②若换了一个物理设备，则程序无法运行；③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待            *   改进                *   建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名        *   ①根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）            ②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。            ③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。            ④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</code></pre><ul><li><p>⑤数据缓冲区管理</p><pre><code>*   缓冲区概念    *   一般用内存作为缓冲区*   缓解CPU与设备的速度矛盾、减少CPU的中断频率、解决数据粒度不匹配的问题、提高CPU与I/O设备之间的并行性*   单缓冲    *   设备—(T)—缓冲区—(M)—工作区—©—处理*   处理一块数据平均耗时Max(C, T)+M*   分析的初始状态：工作区满，缓冲区空*   双缓冲    *   处理一块数据平均耗时Max(T，C+M)*   分析的初始状态：工作区空，一个缓冲区满，另一个缓冲区空*   循环缓冲区    *   多个缓冲区链接成循环队列，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区*   缓冲池    *   三个队列：空缓冲队列、输入队列、输出队列        *   四种工作缓冲区            *   用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区    *   用于收容输出数据的工作缓冲区、用于收容输出数据的工作缓冲区</code></pre></li><li><p>⑥建立逻辑设备名到物理设备名的映射关系；</p><p>根据设备类型选择调用相应的驱动程序</p><pre><code>*   逻辑设备表（LUT）    *   整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统*   每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</code></pre></li><li><p>I&#x2F;O调度</p></li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title=" 设备驱动程序"></a><a href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"></a> 设备驱动程序</h3><ul><li>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等</li></ul><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title=" 中断处理程序"></a><a href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"></a> 中断处理程序</h3><ul><li>进行中断处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1-OS基本概念&quot;&gt;&lt;a href=&quot;#1-1-OS基本概念&quot; class=&quot;headerlink&quot; title=&quot; 1.1 OS基本概念&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#11-os%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令</title>
    <link href="http://example.com/2020/09/02/linux/"/>
    <id>http://example.com/2020/09/02/linux/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2024-04-18T02:21:24.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a><a href="#basic"></a>Basic</h2><p><code>ls [选项] [路径]</code></p><p>list 在列出指定路径下的文件&#x2F;文件夹的名称，并以指定的格式进行显示</p><p><code>pwd</code></p><p>print working directory 打印当前工作目录</p><p><code>cd 路径</code></p><p>change directory 改变目录</p><p><code>mkdir 文件夹名/包含文件夹的完整路径</code></p><p>make directory 创建目录</p><p><code>touch 文件名/路径</code></p><p>创建文件</p><p><code>cp 被复制的文档路径 文档被复制到的路径</code></p><p>copy 赋值文件&#x2F;文件夹到指定位置 [注]:复制文件夹时需添加选项 <code>-r</code>(recursive递归复制)</p><p><code>mv 需要移动的文档路径 需要保存的位置路径</code></p><p>move 移动、剪切、<strong>重命名</strong></p><p><code>rm 选项 需要移除的文档路径</code></p><p>remove 移除&#x2F;删除文档</p><p>选项：<code>-f</code>:force强制删除；<code>-r</code>递归</p><p><code>&gt; / &gt;&gt;</code></p><p>输出重定向：<code>&gt;</code>:覆盖输出；<code>&gt;&gt;</code>:追加输出</p><p><code>cat 文件路径</code></p><p>打开文件</p><p><code>cat 待合并的文件路径1 待合并的文件路径2 …. 文件路径n &gt; 合并之后的文件路径</code></p><p>合并文件</p><h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a><a href="#advanced"></a>Advanced</h2><p><code>df</code></p><p>查看磁盘空间 [选项 <code>-h</code> –human-readable]</p><p><code>free</code></p><p>查看内存使用情况 [选项 <code>-m</code>以mb为单位]</p><p><code>head [-n] 文件路径</code></p><p>查看一个文件的前n行，如果不指定n，则默认显示前10行</p><p><code>tail -n 文件的路径</code></p><p>查看一个文件末n行，如果n不指定默认显示后10行</p><p><code>tail -f 文件路径</code></p><p>查看一个文件的动态变化内容</p><p><code>less 需要查看的文件路径</code></p><p>查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、<strong>空格键</strong>+上下方向键）查看更多</p><p><code>wc -lwc 需要统计的文件路径</code></p><p>统计文件内容信息（包含行数lines <code>-l</code>、单词数words <code>-w</code>、字节数bytes <code>-c</code>）</p><p><code>date</code></p><p>输出操作时间，形式：2020年 09月 02日 星期三 20:09:27 CST</p><p><code>date +%F</code>=&#x3D;<code>date &quot;+%Y-%m-%d&quot;</code></p><p>输出：2020-09-02</p><p><code>date &quot;+%F %T&quot;</code>=&#x3D;<code>date +%Y-%m-%d %H:%M:%S</code></p><p>输出：2020-09-02 20:13:12</p><p><code>date -d &quot;-1 day&quot; &quot;+%Y-%m-%d %H:%M:%S&quot;</code></p><p>获取之前(-)或者之后(+)的某天(-d)&#x2F;某月(-m)&#x2F;某年(-y)</p><p>[ <code>%F</code>：表示完整的年月日；<code>%T</code>：表示完整的时分秒；<code>%Y</code>：表示四位年份；<code>%m</code>：表示两位月份（带前导0）；<code>%d</code>：表示日期（带前导0）；<code>%H</code>：表示小时（带前导0）；<code>%M</code>：表示分钟（带前导0）；<code>%S</code>：表示秒数（带前导0）]</p><p><code>cal</code> &#x3D;&#x3D; <code>cal -l</code></p><p>输出当前月份的日历</p><p><code>cal -3</code></p><p>表示输出上一个月+本月+下个月的日历</p><p><code>cal -y 年份</code></p><p>表示输出某一个年份的日历</p><p><code>clear/快捷键ctrl+L</code></p><p>清除终端中已经存在的命令和结果（信息）[注：只是之前的信息的隐藏到了最上面，通过滚动条继续查看以前的信息。]</p><p><code>|</code></p><p><strong>管道符</strong>一般可以用于“<strong>过滤</strong>”，“特殊”，“扩展处理”。不能单独使用主要是辅助作用。</p><p><code>ls / | grep y</code></p><p>查询出根目录下包含“y”字母的文档名称[grep指令：主要用于过滤]</p><p><code>cat 路径|less</code> &#x3D;&#x3D;<code>less 路径</code></p><p><code>ls / | wc -l</code></p><p>统计某个目录下的文档的总个数</p><p><code>man 命令</code></p><p>查询指令用法</p><p><code>reboot</code></p><p>重启</p><p><code>shutdown -h now</code> &#x3D;&#x3D; <code>init 0</code> &#x3D;&#x3D; <code>halt</code> &#x3D;&#x3D;<code>poweroff</code></p><p>关机</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Basic&quot;&gt;&lt;a href=&quot;#Basic&quot; class=&quot;headerlink&quot; title=&quot;Basic&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#basic&quot;&gt;&lt;/a&gt;Basic&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ls [选项] [路径]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;list</summary>
      
    
    
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>GIT</title>
    <link href="http://example.com/2020/08/05/GIT/"/>
    <id>http://example.com/2020/08/05/GIT/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2024-04-18T02:18:57.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、理论基础"><a href="#一、理论基础" class="headerlink" title="一、理论基础"></a><a href="#%E4%B8%80-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"></a>一、理论基础</h2><p>本地仓库有 Git 维护的<strong>三棵“树</strong> <strong>工作区域、暂存区域和 Git 仓库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805140904040.png" alt="三棵树" title="三棵树"></p><p><strong>工作区域（Working Directory</strong>就是你平时存放项目代码的地方。</p><p><strong>暂存区域（Stage</strong>用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息。</p><p><strong>Git 仓库（Repository</strong>就是安全存放数据的位置，这里边有你提交的所有版本的数据。其中，HEAD 指向最新放入仓库的版本（这第三棵树，确切的说，应该是 Git 仓库中 HEAD 指向的版本）。</p><p>Git 的工作流程一般是：</p><ol><li>在工作目录中添加、修改文件；</li><li>将需要进行版本管理的文件放入暂存区域；</li><li>将暂存区域的文件提交到 Git 仓库。</li></ol><p>因此，Git 管理的文件有三种状态：<strong>已修改（modified）</strong>、**已暂存（staged)**和 <strong>已提交（committed）</strong>，依次对应上面的每一个流程。</p><h2 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a><a href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"></a>二、基本操作</h2><h4 id="1、初始化git项目"><a href="#1、初始化git项目" class="headerlink" title="1、初始化git项目"></a><a href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96git%E9%A1%B9%E7%9B%AE"></a>1、初始化git项目</h4><table><tbody><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table><h4 id="2、将工作区的文件加入暂存区域："><a href="#2、将工作区的文件加入暂存区域：" class="headerlink" title="2、将工作区的文件加入暂存区域："></a><a href="#2-%E5%B0%86%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%8A%A0%E5%85%A5%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F"></a>2、将工作区的文件加入暂存区域：</h4><table><tbody><tr><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></tbody></table><h4 id="3、将暂存区内容提交到本地库："><a href="#3、将暂存区内容提交到本地库：" class="headerlink" title="3、将暂存区内容提交到本地库："></a><a href="#3-%E5%B0%86%E6%9A%82%E5%AD%98%E5%8C%BA%E5%86%85%E5%AE%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%BA%93"></a>3、将暂存区内容提交到本地库：</h4><table><tbody><tr><td class="code"><pre><span class="line">git commit -m "你干了啥"</span><br></pre></td></tr></tbody></table><h4 id="4、将工作区的文件放到Git仓库（一步到位）："><a href="#4、将工作区的文件放到Git仓库（一步到位）：" class="headerlink" title="4、将工作区的文件放到Git仓库（一步到位）："></a><a href="#4-%E5%B0%86%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%94%BE%E5%88%B0git%E4%BB%93%E5%BA%93%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D"></a>4、将工作区的文件放到<em>Git</em>仓库（一步到位）：</h4><table><tbody><tr><td class="code"><pre><span class="line">git commit -am "你干了啥"</span><br></pre></td></tr></tbody></table><h4 id="5、查看状态："><a href="#5、查看状态：" class="headerlink" title="5、查看状态："></a><a href="#5-%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81"></a>5、查看状态：</h4><table><tbody><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table><h4 id="6、查看历史操作记录："><a href="#6、查看历史操作记录：" class="headerlink" title="6、查看历史操作记录："></a><a href="#6-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95"></a>6、查看历史操作记录：</h4><table><tbody><tr><td class="code"><pre><span class="line">git log </span><br><span class="line">git reflog  #常用</span><br><span class="line">git log --graph #图形显示,更直观</span><br><span class="line">git log --pretty=oneline #漂亮一行显示</span><br><span class="line">git log --oneline #简洁显示</span><br></pre></td></tr></tbody></table><h2 id="三、-回退–reset"><a href="#三、-回退–reset" class="headerlink" title="三、 回退–reset"></a><a href="#%E4%B8%89-%E5%9B%9E%E9%80%80reset"></a>三、 回退–reset</h2><p>有关回退的命令有两个：<strong>reset 和 checkout</strong>，具体功能如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805143304099.png" alt="image-20200805143304099" title="状态转换"></p><p>先看<strong>reset</strong> :</p><p>操作之前的仓库状态：</p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805145833346.png" alt="image-20200805145833346" title="初始Git仓库"></p><p>此时三棵树：</p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805145904018.png" alt="image-20200805145904018" title="初始三棵树"></p><p>现在我们利用 reset 命令回滚快照(<em>快照即提交的版本，每个版本我们称之为一个快照。</em>)，并看看 Git 仓库和三棵树分别发生了什么。</p><p>执行 <code>git reset HEAD~</code> 命令：</p><p><em>注：HEAD 表示最新提交的快照，而 HEAD~ 表示 HEAD 的上一个快照，HEAD~~表示上上个快照，如果表示上n个快照，则可以用HEAD ~n</em></p><p>此时我们的快找回滚到了第二棵数（暂存区域）</p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805150102706.png" alt="image-20200805150102706" title="此时仓库状态"></p><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805150127577.png" alt="image-20200805150127577" title="此时三棵树"></p><h4 id="1、reset命令的选项："><a href="#1、reset命令的选项：" class="headerlink" title="1、reset命令的选项："></a><a href="#1-reset%E5%91%BD%E4%BB%A4%E7%9A%84%E9%80%89%E9%A1%B9"></a>1、<strong>reset命令的选项</strong>：</h4><table><tbody><tr><td class="code"><pre><span class="line">git reset --soft HEAD~</span><br></pre></td></tr></tbody></table><ul><li>移动HEAD的指向，将其指向上一个快照<br>（只移动 HEAD 的指向，但并不会将快照回滚到暂存区域。相当于撤消了上一次的提交（commit））</li></ul><table><tbody><tr><td class="code"><pre><span class="line">git reset [--mixed] HEAD~</span><br></pre></td></tr></tbody></table><ul><li>移动HEAD的指向，将其指向上一个快照</li><li>将HEAD移动后指向的快照回滚到暂存区域</li></ul><table><tbody><tr><td class="code"><pre><span class="line">git reset --hard HEAD~</span><br></pre></td></tr></tbody></table><ul><li>移动HEAD的指向，将其指向上一个快照</li><li>将HEAD移动后指向的快照回滚到暂存区域</li><li>将暂存区域的文件还原到工作目录</li></ul><h4 id="2、回滚指定快照"><a href="#2、回滚指定快照" class="headerlink" title="2、回滚指定快照"></a><a href="#2-%E5%9B%9E%E6%BB%9A%E6%8C%87%E5%AE%9A%E5%BF%AB%E7%85%A7"></a>2、<strong>回滚指定快照</strong></h4><p>reset 不仅可以回滚指定快照，还可以回滚个别文件。</p><p>命令格式为： <code>git reset 快照 文件名/路径</code></p><p>这样，它就会将忽略移动 HEAD 的指向这一步（因为你只是回滚快照的部分内容，并不是整个快照，所以 HEAD 的指向不应该发生改变），直接将指定快照的指定文件回滚到暂存区域。</p><h4 id="3、往前滚"><a href="#3、往前滚" class="headerlink" title="3、往前滚"></a><a href="#3-%E5%BE%80%E5%89%8D%E6%BB%9A"></a>3、<strong>往前滚</strong></h4><p>即滚向未来，需要知道指定快照的 ID 号。</p><p><strong>不小心把命令窗口关了不记得ID号？</strong><br>命令：<code>git reflog</code><br>Git记录的每一次操作的版本ID号</p><h2 id="四、版本对比"><a href="#四、版本对比" class="headerlink" title="四、版本对比"></a><a href="#%E5%9B%9B-%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"></a>四、版本对比</h2><h3 id="1、比较暂存区域与工作目录的文件内容"><a href="#1、比较暂存区域与工作目录的文件内容" class="headerlink" title="1、比较暂存区域与工作目录的文件内容"></a><a href="#1-%E6%AF%94%E8%BE%83%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"></a>1、比较暂存区域与工作目录的文件内容</h3><table><tbody><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></tbody></table><p>（PS：解决cmd界面中文乱码👇</p><table><tbody><tr><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line">export LESSCHARSET=utf-8 ## linux bash配置环境变量</span><br><span class="line">set LESSCHARSET=utf-8 #windows配置环境变量</span><br></pre></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805155547724.png" alt="image-20200805155547724"></p><p>含义：<br><strong>第一行：</strong><code>diff --git a/README.md b/README.md</code><br>表示对比的是存放在暂存区域的 <code>README.md</code> 和工作目录的 <code>README.md</code></p><p><strong>第二行：</strong><code>index 7966837..472a180 100644</code><br>表示对应文件的 ID 分别是 7966837 和 472a180，左边暂存区域，后边当前目录。最后的 100644 是指定文件的类型和权限。<br><strong>第三行：</strong><code>--- a/README.md</code><br>— 表示该文件是旧文件（存放在暂存区域）<br><strong>第四行：</strong><code>+++ b/README.md</code><br>+++ 表示该文件是新文件（存放在工作区域）<br><strong>第五行：</strong><code>@@ -1 +1,2 @@</code><br>以 @@ 开头和结束，中间的“-”表示旧文件，“+”表示新文件，后边的数字表示“开始行号，显示行数”<br><strong>第六、七行：</strong><br>这是将两个文件合并显示的结果，前边有个 + 的绿色行是新文件独有的，浅灰色的则是两个文件所共有的内容。（旧文件没有自己“独有的”内容会以 前边有个 - 号的 红色字体显示）。<br><strong>第八行：</strong><code>\ No newline at end of file</code><br>文件不是以换行符结束</p><p><strong>最后的（:）</strong><br>意思是窗口太小，没办法显示全部，正在等待命令（Vim编程知识）</p><blockquote><p><strong>移动命令</strong><code>j、k</code>：向下移动一行&#x2F;向上移动一行<br><code>f、b</code>：向下翻页&#x2F;向上翻页<br><code>d、u</code>：向下翻半页&#x2F;向上翻半页<br><strong>跳转命令</strong><code>g、G</code>：跳转到第一行&#x2F;跳转到最后一行<br><code>n g</code>，表示跳转到第 n 行<br><strong>搜索命令</strong><code>/ 关键字</code> : 表示从当前位置向下搜索</p><p><code>？关键字</code> : 表示从当前位置向上搜索。<br>接着输入 n 表示顺着当前的搜索方向快速跳转到下个匹配的位置，大写的 N 则是与当前搜索方向相反。<br><strong>退出</strong><code>q</code>: 表示退出 diff</p><p><strong>帮助</strong></p><p><code>h</code> :表示进入帮助界面，输入 q 可以退出帮助界面。</p></blockquote><h3 id="2、比较两个历史快照"><a href="#2、比较两个历史快照" class="headerlink" title="2、比较两个历史快照"></a><a href="#2-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%8E%86%E5%8F%B2%E5%BF%AB%E7%85%A7"></a>2、比较两个历史快照</h3><table><tbody><tr><td class="code"><pre><span class="line">git diff 快照ID 快照ID</span><br></pre></td></tr></tbody></table><h3 id="3、比较当前工作目录和-Git-仓库中的快照"><a href="#3、比较当前工作目录和-Git-仓库中的快照" class="headerlink" title="3、比较当前工作目录和 Git 仓库中的快照"></a><a href="#3-%E6%AF%94%E8%BE%83%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C-git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E5%BF%AB%E7%85%A7"></a>3、比较当前工作目录和 Git 仓库中的快照</h3><h4 id="1）比较之前版本的快照与当前工作目录内容"><a href="#1）比较之前版本的快照与当前工作目录内容" class="headerlink" title="1）比较之前版本的快照与当前工作目录内容"></a><a href="#1%E6%AF%94%E8%BE%83%E4%B9%8B%E5%89%8D%E7%89%88%E6%9C%AC%E7%9A%84%E5%BF%AB%E7%85%A7%E4%B8%8E%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9"></a>1）比较之前版本的快照与当前工作目录内容</h4><table><tbody><tr><td class="code"><pre><span class="line">git diff 快照ID</span><br></pre></td></tr></tbody></table><h4 id="2）比较当前版本快照与当前工作目录内容"><a href="#2）比较当前版本快照与当前工作目录内容" class="headerlink" title="2）比较当前版本快照与当前工作目录内容"></a><a href="#2%E6%AF%94%E8%BE%83%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E5%BF%AB%E7%85%A7%E4%B8%8E%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9"></a>2）比较当前版本快照与当前工作目录内容</h4><table><tbody><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></tbody></table><h3 id="4、比较Git仓库与暂存区域"><a href="#4、比较Git仓库与暂存区域" class="headerlink" title="4、比较Git仓库与暂存区域"></a><a href="#4-%E6%AF%94%E8%BE%83git%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F"></a>4、比较Git仓库与暂存区域</h3><table><tbody><tr><td class="code"><pre><span class="line">git diff --cached</span><br><span class="line">git diff --cached 快照ID</span><br></pre></td></tr></tbody></table><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a><a href="#5-%E6%80%BB%E7%BB%93"></a>5、总结</h3><p><img src="https://cdn.jsdelivr.net/gh/isxrh/My-Private-Pictures/img/image-20200805164135352.png" alt="image-20200805164135352"></p><h2 id="五、修改最后一次提交、删除文件和重命名文件"><a href="#五、修改最后一次提交、删除文件和重命名文件" class="headerlink" title="五、修改最后一次提交、删除文件和重命名文件"></a><a href="#%E4%BA%94-%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"></a>五、修改最后一次提交、删除文件和重命名文件</h2><h3 id="1、修改最后一次提交"><a href="#1、修改最后一次提交" class="headerlink" title="1、修改最后一次提交"></a><a href="#1-%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"></a>1、修改最后一次提交</h3><table><tbody><tr><td class="code"><pre><span class="line">git commit -amend</span><br></pre></td></tr></tbody></table><p>进入“编辑提交说明界面”，连续按下两个大写Z来退出，或者按下（:）再输入q!退出。</p><table><tbody><tr><td class="code"><pre><span class="line">git commit --ammend -m “新的提交说明” </span><br></pre></td></tr></tbody></table><p>直接提交说明。</p><h3 id="2、删除文件"><a href="#2、删除文件" class="headerlink" title="2、删除文件"></a><a href="#2-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"></a>2、删除文件</h3><h4 id="1）恢复不小心删除的文件"><a href="#1）恢复不小心删除的文件" class="headerlink" title="1）恢复不小心删除的文件"></a><a href="#1%E6%81%A2%E5%A4%8D%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6"></a>1）恢复不小心删除的文件</h4><table><tbody><tr><td class="code"><pre><span class="line">git checkout -- README.md</span><br></pre></td></tr></tbody></table><h4 id="2-彻底删除一个文件"><a href="#2-彻底删除一个文件" class="headerlink" title="2)彻底删除一个文件"></a><a href="#2%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"></a>2)彻底删除一个文件</h4><table><tbody><tr><td class="code"><pre><span class="line">git rm 文件名</span><br></pre></td></tr></tbody></table><p>但是，此时执行<code>git status</code>会发现操作记录，若想删除记录，可以执行 <code>git reset --soft HEAD~</code> 命令将快照回滚到上一个位置，然后重新提交</p><h4 id="3-暂存区域和工作目录文件不同时（add之后又进行了修改）"><a href="#3-暂存区域和工作目录文件不同时（add之后又进行了修改）" class="headerlink" title="3)暂存区域和工作目录文件不同时（add之后又进行了修改）"></a><a href="#3%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C%E6%97%B6add%E4%B9%8B%E5%90%8E%E5%8F%88%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%BF%AE%E6%94%B9"></a>3)暂存区域和工作目录文件不同时（add之后又进行了修改）</h4><table><tbody><tr><td class="code"><pre><span class="line">git rm -f 文件名</span><br></pre></td></tr></tbody></table><p>全部删除</p><h3 id="3、重命名文件"><a href="#3、重命名文件" class="headerlink" title="3、重命名文件"></a><a href="#3-%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"></a>3、重命名文件</h3><table><tbody><tr><td class="code"><pre><span class="line">git mv 旧文件名 新文件名</span><br></pre></td></tr></tbody></table><h2 id="六、Git分支"><a href="#六、Git分支" class="headerlink" title="六、Git分支"></a><a href="#%E5%85%AD-git%E5%88%86%E6%94%AF"></a>六、Git分支</h2><h3 id="1、创建分支"><a href="#1、创建分支" class="headerlink" title="1、创建分支"></a><a href="#1-%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"></a>1、创建分支</h3><table><tbody><tr><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></tbody></table><p>通过<code>git log --decorate</code>命令（<code>git log --decorate --oneline</code>只用一行来显示一个快照记录）查看记录，可以看到最新的快照后边多了一个 <code>(HEAD -&gt; master, 分支名)</code>，表示：目前有两个分支，一个是主分支（master），一个是刚才我们创建的新分支， HEAD 指针仍然指向默认的 master 分支。</p><h3 id="2、切换分支"><a href="#2、切换分支" class="headerlink" title="2、切换分支"></a><a href="#2-%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"></a>2、切换分支</h3><table><tbody><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br><span class="line">git checkout -b 分支名 &nbsp; #创建分支并切换到该分支</span><br></pre></td></tr></tbody></table><p>PS：执行 <code>git log --oneline --decorate --graph --all</code> 命令： 绘制所有分支图并显示。</p><h3 id="3、合并分支"><a href="#3、合并分支" class="headerlink" title="3、合并分支"></a><a href="#3-%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"></a>3、合并分支</h3><table><tbody><tr><td class="code"><pre><span class="line">git merge xxx</span><br><span class="line">#注：要将xxx分支合并到master，就先切换到master，然后执行上述命令</span><br></pre></td></tr></tbody></table><p>冲突问题：</p><p>所谓冲突，无非就是像两个分支中存在同名但内容却不同的文件，Git 不知道你要舍弃哪一个或保留哪一个，所以需要你自己来决定。此时执行 git status 命令也会显示需要你解决的冲突。解决：打开冲突文件，Git 会在有冲突的文件中加入一些标记，以<code>=======</code>为界，上到<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 的内容表示当前分支，下到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 分支名</code>表示待合并的分支，之间的内容就是冲突的地方，删除特殊符号，文件内容改成需要的即可。</p><h3 id="4、删除分支"><a href="#4、删除分支" class="headerlink" title="4、删除分支"></a><a href="#4-%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"></a>4、删除分支</h3><table><tbody><tr><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></tbody></table><h2 id="七、checkout（-amp-reset）"><a href="#七、checkout（-amp-reset）" class="headerlink" title="七、checkout（&amp;reset）"></a><a href="#%E4%B8%83-checkoutreset"></a>七、checkout（&amp;reset）</h2><h3 id="1、再论checkout"><a href="#1、再论checkout" class="headerlink" title="1、再论checkout"></a><a href="#1-%E5%86%8D%E8%AE%BAcheckout"></a>1、再论checkout</h3><p>事实上，checkout 命令有两种功能：</p><ul><li>从历史快照（或者暂存区域）中拷贝文件到工作目录</li><li>切换分支</li></ul><p><strong>1）从历史快照（或者暂存区域）中拷贝文件到工作目录</strong></p><table><tbody><tr><td class="code"><pre><span class="line">git checkout HEAD~ README.md  #将上一个快照中的 README.md 文件复制到工作目录和暂存区域中</span><br><span class="line">git checkout README.md #从暂存区域恢复指定文件到工作目录</span><br></pre></td></tr></tbody></table><p><strong>2）切换分支</strong></p><table><tbody><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br><span class="line">#将HEAD指针切换到指定分支（并将上一个快照中的文件复制到工作目录和暂存区域中</span><br></pre></td></tr></tbody></table><h3 id="2、checkout-与reset区别"><a href="#2、checkout-与reset区别" class="headerlink" title="2、checkout 与reset区别"></a><a href="#2-checkout-%E4%B8%8Ereset%E5%8C%BA%E5%88%AB"></a>2、checkout 与reset区别</h3><p><strong>1）恢复文件</strong></p><p>checkout 命令和 reset 命令都可以用于恢复指定快照的指定文件，并且它们都不会改变 HEAD 指针的指向。</p><p><strong>区别</strong>：reset 命令只将指定文件恢复到暂存区域（–mixed），而 checkout 命令是同时覆盖暂存区域和工作目录。</p><p><em>注意：也许你试图使用 git reset –hard HEAD~ <a href="http://readme.md/">README.md</a> 命令让 reset 同时覆盖工作目录，但 Git 会告诉你这是徒劳（此时 reset 不允许使用 –soft 或 –hard 选项）。</em></p><p>这样看来，在恢复文件方面，reset 命令要比 checkout 命令更安全一些。</p><p><strong>2）恢复快照</strong></p><p>reset 命令是用来”回到过去”的，根据选项的不同，reset 命令将移动 HEAD 指针（–soft） -&gt; 覆盖暂存区域（–mixed，默认）-&gt; 覆盖工作目录（–hard）。</p><p>checkout 命令虽说是用于切换分支，但它事实上也是通过移动 HEAD 指针和覆盖暂存区域、工作目录来实现的。</p><p><strong>区别</strong>：</p><ul><li>对于 reset –hard 命令来说，checkout 命令更安全。因为 checkout 命令在切换分支前会先检查一下当前的工作状态，如果不是“clean”的话，Git 不会允许你这样做；而 reset –hard 命令则是直接覆盖所有数据。</li><li>另一个区别是如何更新 HEAD 指向，reset 命令会移动 HEAD 所在分支的指向，而 checkout 命令只会移动 HEAD 自身来指向另一个分支。</li></ul><h2 id="八、Git-amp-Github"><a href="#八、Git-amp-Github" class="headerlink" title="八、Git&amp;Github"></a><a href="#%E5%85%AB-gitgithub"></a>八、Git&amp;Github</h2><h3 id="1、创建远程库地址别名"><a href="#1、创建远程库地址别名" class="headerlink" title="1、创建远程库地址别名"></a><a href="#1-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%9C%B0%E5%9D%80%E5%88%AB%E5%90%8D"></a>1、创建远程库地址别名</h3><table><tbody><tr><td class="code"><pre><span class="line">git remote -v  #查看远程地址别名</span><br><span class="line">git remote add 别名 远程地址 </span><br><span class="line">#例：git remote add origin https://xx</span><br></pre></td></tr></tbody></table><h3 id="2、-推送"><a href="#2、-推送" class="headerlink" title="2、 推送"></a><a href="#2-%E6%8E%A8%E9%80%81"></a>2、 推送</h3><table><tbody><tr><td class="code"><pre><span class="line">git push 别名 分支名</span><br><span class="line">git push -u 别名 分支名 &nbsp;  #-u指定默认主机</span><br><span class="line">#例：git push origin master</span><br></pre></td></tr></tbody></table><h3 id="3、clone"><a href="#3、clone" class="headerlink" title="3、clone"></a><a href="#3-clone"></a>3、clone</h3><table><tbody><tr><td class="code"><pre><span class="line">git clone  https://xx</span><br></pre></td></tr></tbody></table><p>效果：</p><ul><li>完整的把远程库下载到本地</li><li>创建origin远程地址别名</li><li>初始化本地库</li></ul><h3 id="4、pull-x3D-fetch-merge"><a href="#4、pull-x3D-fetch-merge" class="headerlink" title="4、pull(&#x3D;fetch+merge)"></a><a href="#4-pullfetchmerge"></a>4、pull(&#x3D;fetch+merge)</h3><table><tbody><tr><td class="code"><pre><span class="line">git fetch 别名 分支名  #只是把远程内容下下载到本地，不会修改本地工作区文件</span><br><span class="line">git merge 别名 分支名  #合并</span><br><span class="line">git pull 别名 分支名  #pull=fetch+merge</span><br></pre></td></tr></tbody></table><h3 id="5、解决冲突"><a href="#5、解决冲突" class="headerlink" title="5、解决冲突"></a><a href="#5-%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"></a>5、解决冲突</h3><p>如果不是基于远程库最新版做的修改不能推送，必须先pull下来，pull下来如果进入冲突状态，按照”分支冲突解决”操作解决即可。</p><h3 id="6、SSH"><a href="#6、SSH" class="headerlink" title="6、SSH"></a><a href="#6-ssh"></a>6、SSH</h3><ul><li>输入:<code>ssh-keygen -t rsa -C GitHub邮箱地址</code></li><li>进入<code>.ssh</code>目录，复制<code>id_rsa.pub</code>文件内容</li><li>登录GitHub。<code>Settings</code> –&gt; <code>SSH and GPG keys</code>–&gt; <code>New SSH Key</code></li><li>回到git通过ssh地址创建。<code>git remote add 别名 SSH地址</code></li></ul><h2 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a><a href="#tips"></a>Tips：</h2><p><strong>如何让Git 识别某些格式的文件，然后自主不跟踪它们？</strong><br>比如工作目录中有三个文件1.temp、2.temp 和 3.temp，我们不希望后缀名为 temp 的文件被追踪。</p><p><em><strong>Solution</strong></em>：在工作目录创建一个名为 .gitignore 的文件。</p><blockquote><p>注：windows需要在命令行窗口创建（.）开头的文件。</p></blockquote><p>执行 <code>echo *.temp &gt; .gitignore</code> 命令，创建一个 .gitignore 文件，并让 Git 忽略所有 .temp 后缀的文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#%E4%B8%80-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80&quot;&gt;&lt;/a&gt;一、理论基础</summary>
      
    
    
    
    
    <category term="GIT" scheme="http://example.com/tags/GIT/"/>
    
  </entry>
  
</feed>
